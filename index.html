<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>éº»å°‡å–®æ©Ÿï¼ˆæ‰‹æ©Ÿç‰ˆï¼‰</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700;900&display=swap" rel="stylesheet">
<style>
:root {
  --bg-primary: #0a1628;
  --bg-secondary: #162236;
  --bg-card: #1e3a5f;
  --accent-gold: #f0c14b;
  --accent-jade: #2dd4bf;
  --accent-red: #ef4444;
  --accent-blue: #3b82f6;
  --accent-green: #22c55e;
  --text-primary: #f8fafc;
  --text-secondary: #94a3b8;
  --border-subtle: rgba(255,255,255,0.08);
  --glow-gold: rgba(240,193,75,0.4);
  --glow-jade: rgba(45,212,191,0.3);
  
  --tile-wan: #dc2626;
  --tile-tong: #2563eb;
  --tile-tiao: #16a34a;
  --tile-zi: #78350f;
  
  --safe-bottom: env(safe-area-inset-bottom, 0px);
  --safe-top: env(safe-area-inset-top, 0px);
}

* {
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
}

html, body {
  margin: 0;
  padding: 0;
  overflow-x: hidden;
  overscroll-behavior: none;
}

body {
  font-family: 'Noto Sans TC', system-ui, -apple-system, sans-serif;
  background: var(--bg-primary);
  background-image: 
    radial-gradient(ellipse at 20% 0%, rgba(45,212,191,0.08) 0%, transparent 50%),
    radial-gradient(ellipse at 80% 100%, rgba(240,193,75,0.06) 0%, transparent 50%);
  color: var(--text-primary);
  min-height: 100vh;
  min-height: 100dvh;
  display: flex;
  flex-direction: column;
  padding-top: var(--safe-top);
  padding-bottom: var(--safe-bottom);
}

/* ===== é ‚éƒ¨ç‹€æ…‹åˆ— ===== */
.status-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 16px;
  background: linear-gradient(180deg, rgba(30,58,95,0.95) 0%, rgba(22,34,54,0.9) 100%);
  backdrop-filter: blur(12px);
  border-bottom: 1px solid var(--border-subtle);
  position: sticky;
  top: 0;
  z-index: 100;
}

.round-badge {
  display: flex;
  align-items: center;
  gap: 6px;
  background: linear-gradient(135deg, var(--accent-gold) 0%, #d4a03a 100%);
  color: var(--bg-primary);
  padding: 6px 14px;
  border-radius: 20px;
  font-weight: 700;
  font-size: 13px;
  box-shadow: 0 2px 12px var(--glow-gold);
}

.remain-badge {
  display: flex;
  align-items: center;
  gap: 4px;
  background: rgba(255,255,255,0.08);
  padding: 6px 12px;
  border-radius: 16px;
  font-size: 12px;
  color: var(--text-secondary);
}

.remain-badge strong {
  color: var(--accent-jade);
  font-size: 16px;
}

/* ===== é‡‘ç‰Œå±•ç¤º ===== */
.gold-display {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 8px 12px;
  background: linear-gradient(90deg, transparent, rgba(240,193,75,0.1), transparent);
}

.gold-label {
  font-size: 11px;
  color: var(--accent-gold);
  font-weight: 600;
}

.gold-tiles {
  display: flex;
  gap: 6px;
}

.gold-tile {
  background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffc107 100%);
  color: var(--bg-primary);
  padding: 4px 10px;
  border-radius: 6px;
  font-weight: 800;
  font-size: 14px;
  box-shadow: 0 2px 8px rgba(255,215,0,0.4), inset 0 1px 0 rgba(255,255,255,0.5);
  text-shadow: 0 1px 0 rgba(255,255,255,0.3);
}

/* ===== å°æ‰‹å€åŸŸ ===== */
.opponents-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 8px 12px;
  overflow-y: auto;
  min-height: 0;
}

.opponent-card {
  background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-secondary) 100%);
  border: 1px solid var(--border-subtle);
  border-radius: 12px;
  padding: 10px 12px;
  transition: all 0.3s ease;
}

.opponent-card.active-turn {
  border-color: var(--accent-gold);
  box-shadow: 0 0 20px var(--glow-gold), inset 0 0 30px rgba(240,193,75,0.05);
}

.opponent-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.opponent-name {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  font-size: 14px;
}

.wind-icon {
  width: 26px;
  height: 26px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, var(--accent-jade) 0%, #14b8a6 100%);
  color: var(--bg-primary);
  border-radius: 6px;
  font-weight: 800;
  font-size: 13px;
  box-shadow: 0 2px 8px var(--glow-jade);
}

.dealer-mark {
  background: linear-gradient(135deg, var(--accent-gold) 0%, #d4a03a 100%);
  color: var(--bg-primary);
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 10px;
  font-weight: 700;
}

.listen-mark {
  background: linear-gradient(135deg, var(--accent-red) 0%, #dc2626 100%);
  color: white;
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 10px;
  font-weight: 700;
  animation: pulse-listen 2s infinite;
}

@keyframes pulse-listen {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.opponent-score {
  font-weight: 700;
  font-size: 15px;
  color: var(--accent-jade);
}

.opponent-content {
  display: flex;
  gap: 8px;
}

.discard-zone {
  flex: 1;
  min-height: 36px;
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
  padding: 6px;
  display: flex;
  flex-wrap: wrap;
  gap: 3px;
  align-content: flex-start;
}

.discard-zone-label {
  font-size: 9px;
  color: var(--text-secondary);
  margin-bottom: 4px;
  display: block;
  width: 100%;
}

.meld-zone {
  display: flex;
  flex-direction: column;
  gap: 4px;
  min-width: 80px;
}

.meld-group {
  display: flex;
  gap: 2px;
  padding: 4px;
  background: rgba(45,212,191,0.1);
  border-radius: 6px;
}

/* ===== ç‰Œé¢æ¨£å¼ ===== */
.tile {
  background: linear-gradient(180deg, #ffffff 0%, #f1f5f9 100%);
  border: 1.5px solid #cbd5e1;
  border-radius: 5px;
  font-weight: 700;
  text-align: center;
  box-shadow: 0 2px 4px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.8);
  user-select: none;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.tile-xs {
  min-width: 22px;
  height: 28px;
  font-size: 11px;
  padding: 2px;
}

.tile-sm {
  min-width: 28px;
  height: 36px;
  font-size: 13px;
  padding: 3px;
}

.tile-md {
  min-width: 36px;
  height: 48px;
  font-size: 16px;
  padding: 4px;
  cursor: pointer;
}

.tile-md:hover {
  transform: translateY(-4px);
  box-shadow: 0 8px 16px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.8);
}

.tile-md:active {
  transform: translateY(-2px) scale(0.98);
}

/* èŠ±è‰²é¡è‰² */
.tile.suit-W { color: var(--tile-wan); }
.tile.suit-T { color: var(--tile-tong); }
.tile.suit-B { color: var(--tile-tiao); }
.tile.suit-F, .tile.suit-D { color: var(--tile-zi); }

/* é‡‘ç‰Œ */
.tile.gold {
  background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffc107 100%);
  border-color: #d4a03a;
  box-shadow: 0 2px 12px rgba(255,215,0,0.5), inset 0 1px 0 rgba(255,255,255,0.6);
}

/* æ‘¸åˆ°çš„ç‰Œ */
.tile.drawn {
  border: 2px solid var(--accent-gold);
  box-shadow: 0 0 16px var(--glow-gold), 0 4px 8px rgba(0,0,0,0.2);
  animation: glow-pulse 1.5s ease-in-out infinite;
}

@keyframes glow-pulse {
  0%, 100% { box-shadow: 0 0 16px var(--glow-gold), 0 4px 8px rgba(0,0,0,0.2); }
  50% { box-shadow: 0 0 24px var(--glow-gold), 0 4px 12px rgba(0,0,0,0.25); }
}

/* ===== æˆ°æ³é¢æ¿ ===== */
.log-panel {
  background: rgba(0,0,0,0.3);
  border-top: 1px solid var(--border-subtle);
  padding: 8px 12px;
  max-height: 80px;
  overflow-y: auto;
}

.log-panel::-webkit-scrollbar {
  width: 4px;
}

.log-panel::-webkit-scrollbar-track {
  background: transparent;
}

.log-panel::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.2);
  border-radius: 2px;
}

#log {
  font-size: 11px;
  line-height: 1.6;
  color: var(--text-secondary);
}

#log .my-log {
  color: var(--accent-jade);
}

/* ===== æˆ‘çš„æ‰‹ç‰Œå€ ===== */
.my-hand-area {
  background: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg-card) 100%);
  border-top: 2px solid var(--accent-jade);
  padding: 12px 8px 16px;
  box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
}

.hand-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  padding: 0 8px;
}

.hand-title {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 700;
  font-size: 14px;
}

.hand-title .wind-icon {
  background: linear-gradient(135deg, var(--accent-gold) 0%, #d4a03a 100%);
}

.my-score {
  font-size: 18px;
  font-weight: 800;
  color: var(--accent-jade);
}

.listen-hint {
  text-align: center;
  font-size: 12px;
  color: var(--accent-gold);
  margin-bottom: 8px;
  font-weight: 600;
}

.hand-tiles {
  display: flex;
  justify-content: center;
  gap: 4px;
  flex-wrap: wrap;
  margin-bottom: 10px;
}

.my-melds {
  display: flex;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
  margin-bottom: 8px;
}

.meld-badge {
  display: flex;
  align-items: center;
  gap: 4px;
  background: rgba(45,212,191,0.15);
  border: 1px solid rgba(45,212,191,0.3);
  border-radius: 8px;
  padding: 6px 8px;
}

.meld-label {
  font-size: 10px;
  color: var(--accent-jade);
  font-weight: 600;
}

/* ===== æ§åˆ¶æŒ‰éˆ• ===== */
.controls-bar {
  display: flex;
  gap: 6px;
  padding: 8px;
  flex-wrap: wrap;
  justify-content: center;
}

.btn {
  flex: 1;
  min-width: 60px;
  max-width: 100px;
  padding: 12px 8px;
  border: none;
  border-radius: 12px;
  font-size: 13px;
  font-weight: 700;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
}

.btn:disabled {
  opacity: 0.35;
  cursor: not-allowed;
  transform: none !important;
}

.btn-primary {
  background: linear-gradient(135deg, var(--accent-jade) 0%, #14b8a6 100%);
  color: var(--bg-primary);
  box-shadow: 0 4px 12px var(--glow-jade);
}

.btn-primary:not(:disabled):active {
  transform: scale(0.95);
}

.btn-secondary {
  background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-secondary) 100%);
  color: var(--text-primary);
  border: 1px solid var(--border-subtle);
}

.btn-secondary:not(:disabled):active {
  transform: scale(0.95);
  background: var(--bg-secondary);
}

.btn-gold {
  background: linear-gradient(135deg, var(--accent-gold) 0%, #d4a03a 100%);
  color: var(--bg-primary);
  box-shadow: 0 4px 12px var(--glow-gold);
}

.btn-gold:not(:disabled):active {
  transform: scale(0.95);
}

.btn-danger {
  background: linear-gradient(135deg, var(--accent-red) 0%, #dc2626 100%);
  color: white;
  box-shadow: 0 4px 12px rgba(239,68,68,0.3);
}

.btn.active {
  animation: btn-glow 1s ease-in-out infinite;
  transform: scale(1.05);
}

@keyframes btn-glow {
  0%, 100% { box-shadow: 0 0 20px var(--glow-gold); }
  50% { box-shadow: 0 0 30px var(--glow-gold), 0 0 40px var(--glow-gold); }
}

.btn-icon {
  font-size: 18px;
}

.btn-text {
  font-size: 11px;
}

/* ===== å½ˆçª— ===== */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(4px);
  z-index: 200;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.modal-overlay.show {
  display: flex;
}

.modal-content {
  background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-secondary) 100%);
  border: 1px solid var(--border-subtle);
  border-radius: 20px;
  padding: 24px;
  max-width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
}

.modal-title {
  font-size: 20px;
  font-weight: 800;
  color: var(--accent-gold);
  margin-bottom: 16px;
  text-align: center;
}

.modal-section {
  margin-bottom: 16px;
}

.modal-section-title {
  font-size: 14px;
  font-weight: 700;
  color: var(--accent-jade);
  margin-bottom: 8px;
}

.modal-player {
  background: rgba(0,0,0,0.2);
  border-radius: 12px;
  padding: 12px;
  margin-bottom: 12px;
}

.modal-player.winner {
  border: 2px solid var(--accent-gold);
  box-shadow: 0 0 20px var(--glow-gold);
}

.modal-player-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.modal-player-name {
  font-weight: 700;
  font-size: 15px;
}

.modal-player-score {
  color: var(--accent-jade);
  font-weight: 700;
}

.modal-hand {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin-top: 8px;
}

.modal-btn {
  width: 100%;
  padding: 16px;
  margin-top: 16px;
  background: linear-gradient(135deg, var(--accent-jade) 0%, #14b8a6 100%);
  color: var(--bg-primary);
  border: none;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 700;
  font-family: inherit;
  cursor: pointer;
  box-shadow: 0 4px 16px var(--glow-jade);
}

.modal-btn:active {
  transform: scale(0.98);
}

/* ===== ç‰¹æ•ˆ ===== */
.effect-overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 300;
}

.effect-text {
  font-size: 48px;
  font-weight: 900;
  text-shadow: 0 0 30px currentColor, 0 0 60px currentColor;
  animation: effect-pop 1s ease-out forwards;
}

@keyframes effect-pop {
  0% { transform: scale(0.5); opacity: 0; }
  50% { transform: scale(1.2); opacity: 1; }
  100% { transform: scale(1); opacity: 0; }
}

/* ===== éŸ¿æ‡‰å¼èª¿æ•´ ===== */
@media (max-width: 380px) {
  .tile-md {
    min-width: 32px;
    height: 44px;
    font-size: 14px;
  }
  
  .btn {
    min-width: 50px;
    padding: 10px 6px;
  }
  
  .btn-icon { font-size: 16px; }
  .btn-text { font-size: 10px; }
}

@media (min-width: 500px) {
  .opponents-area {
    flex-direction: row;
    flex-wrap: wrap;
  }
  
  .opponent-card {
    flex: 1 1 calc(50% - 4px);
    min-width: 200px;
  }
}

/* å°ç‰Œåœ–ç¤ºï¼ˆç”¨æ–¼æˆ°æ³è¨˜éŒ„ï¼‰ */
.tile.log-tile {
  display: inline-flex;
  min-width: 20px;
  height: 24px;
  font-size: 10px;
  padding: 2px 4px;
  margin: 0 2px;
  vertical-align: middle;
}

/* éš±è—å…ƒç´  */
.hidden { display: none !important; }
</style>
</head>
<body>

<!-- é ‚éƒ¨ç‹€æ…‹åˆ— -->
<div class="status-bar">
  <div class="round-badge">
    <span id="centerRound">æ±é¢¨æ±</span>
  </div>
  <div class="remain-badge">
    ğŸ´ å‰©é¤˜ <strong id="centerRemain">56</strong> å¼µ
  </div>
  <button class="btn btn-gold" id="newGameBtn" style="padding: 8px 12px; min-width: auto; flex: none;">
    <span style="font-size: 14px;">ğŸ® æ–°å±€</span>
  </button>
</div>

<!-- é‡‘ç‰Œå±•ç¤º -->
<div class="gold-display" id="goldDisplay">
  <span class="gold-label">âœ¨ é‡‘ç‰Œ</span>
  <div class="gold-tiles" id="goldTiles"></div>
</div>

<!-- å°æ‰‹å€åŸŸ -->
<div class="opponents-area" id="opponentsArea">
  <!-- å‹•æ…‹ç”Ÿæˆ -->
</div>

<!-- æˆ°æ³è¨˜éŒ„ -->
<div class="log-panel">
  <div id="log"></div>
</div>

<!-- æˆ‘çš„æ‰‹ç‰Œå€ -->
<div class="my-hand-area">
  <div class="hand-header">
    <div class="hand-title">
      <div class="wind-icon" id="myWind">æ±</div>
      <span id="myName">ä½ </span>
      <span id="myDealerMark" class="dealer-mark hidden">èŠ</span>
      <span id="myListenMark" class="listen-mark hidden">è½</span>
    </div>
    <div class="my-score" id="myScore">100,000</div>
  </div>
  <div class="listen-hint hidden" id="listenHint"></div>
  <div class="hand-tiles" id="yourHand"></div>
  <div class="my-melds" id="yourMelds"></div>
  <div class="controls-bar" id="controls">
    <button class="btn btn-danger" id="btnHu" disabled>
      <span class="btn-icon">ğŸ‰</span>
      <span class="btn-text">èƒ¡ç‰Œ</span>
    </button>
    <button class="btn btn-secondary" id="btnChow" disabled>
      <span class="btn-icon">ğŸœ</span>
      <span class="btn-text">åƒ</span>
    </button>
    <button class="btn btn-secondary" id="btnPong" disabled>
      <span class="btn-icon">ğŸ”¥</span>
      <span class="btn-text">ç¢°</span>
    </button>
    <button class="btn btn-secondary" id="btnKong" disabled>
      <span class="btn-icon">ğŸ’¥</span>
      <span class="btn-text">æ§“</span>
    </button>
    <button class="btn btn-primary" id="btnListen" disabled>
      <span class="btn-icon">ğŸ””</span>
      <span class="btn-text">è½ç‰Œ</span>
    </button>
    <button class="btn btn-secondary" id="btnPass" disabled>
      <span class="btn-icon">â­ï¸</span>
      <span class="btn-text">é</span>
    </button>
  </div>
</div>

<!-- å½ˆçª— -->
<div class="modal-overlay" id="modalOverlay">
  <div class="modal-content" id="modalContent"></div>
</div>

<!-- éš±è—å…ƒç´  -->
<div id="scoreboard" style="display: none;"></div>
<div id="goldbar" style="display: none;"></div>
<div id="roundinfo" style="display: none;"></div>
<div id="table" style="display: none;"></div>
<input type="checkbox" id="goldSwitch" checked style="display: none;">
<div id="reactionPanel" style="display: none;"></div>
<div id="overlay" style="display: none;"></div>

<script>
/* ========= åŸºæœ¬å·¥å…· ========= */
const rng = (n) => Math.floor(Math.random() * n);
const clone = (o) => JSON.parse(JSON.stringify(o));

// éŸ³æ•ˆç³»çµ±
let audioCtx = null;
let soundEnabled = true;
let audioInitialized = false;

function initAudio() {
  if (!audioInitialized) {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
      audioInitialized = true;
    } catch (e) {
      soundEnabled = false;
    }
  }
}

function playSound(freq, duration, type = 'sine') {
  if (!soundEnabled) return;
  if (!audioInitialized) initAudio();
  if (!audioCtx) return;
  try {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = freq;
    osc.type = type;
    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + duration);
  } catch (e) {}
}

function showEffect(text, color, size = '48px') {
  const effect = document.createElement('div');
  effect.className = 'effect-text';
  effect.textContent = text;
  effect.style.color = color;
  effect.style.fontSize = size;
  
  const overlay = document.createElement('div');
  overlay.className = 'effect-overlay';
  overlay.appendChild(effect);
  document.body.appendChild(overlay);
  setTimeout(() => overlay.remove(), 1000);
}

function log(msg) {
  const el = document.getElementById('log');
  const line = document.createElement('div');
  const formatted = formatLogString(msg);
  line.innerHTML = formatted;
  line.style.marginBottom = '4px';
  if (/ä½ /.test(msg)) line.classList.add('my-log');
  el.appendChild(line);
  el.scrollTop = el.scrollHeight;
}

function formatLogString(text) {
  const cnNumMap = { 'ä¸€': 1, 'äºŒ': 2, 'ä¸‰': 3, 'å››': 4, 'äº”': 5, 'å…­': 6, 'ä¸ƒ': 7, 'å…«': 8, 'ä¹': 9 };
  return text.replace(/([1-9]|[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹])([è¬ç­’æ¢ç´¢])|([æ±å—è¥¿åŒ—ä¸­ç™¼ç™½])/g, (m, p1, p2, p3) => {
    if (p1 && p2) {
      const suitChar = p2;
      let suitKey;
      if (suitChar === 'è¬') suitKey = 'W';
      else if (suitChar === 'ç­’') suitKey = 'T';
      else if (suitChar === 'æ¢' || suitChar === 'ç´¢') suitKey = 'B';
      else suitKey = '?';
      return `<span class="tile log-tile suit-${suitKey}">${m}</span>`;
    }
    if (p3) {
      let suitKey;
      if ('æ±å—è¥¿åŒ—'.includes(p3)) suitKey = 'F';
      else if ('ä¸­ç™¼ç™½'.includes(p3)) suitKey = 'D';
      else suitKey = '?';
      return `<span class="tile log-tile suit-${suitKey}">${p3}</span>`;
    }
    return m;
  });
}

/* ========= ç‰Œå‹å®šç¾© ========= */
const SUIT_W = 'W', SUIT_T = 'T', SUIT_B = 'B', SUIT_F = 'F', SUIT_D = 'D';
const WINDS = ['E', 'S', 'W', 'N'];
const DRAGONS = ['C', 'F', 'B'];

function tileKey(t) {
  if (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) return t.suit + String(t.rank);
  if (t.suit === SUIT_F || t.suit === SUIT_D) return t.suit + t.name;
  return '?';
}

function keyToText(k) {
  const s = k[0], v = k.slice(1);
  if (s === SUIT_W) return v + 'è¬';
  if (s === SUIT_T) return v + 'ç­’';
  if (s === SUIT_B) return v + 'æ¢';
  if (s === SUIT_F) {
    const m = { E: 'æ±', S: 'å—', W: 'è¥¿', N: 'åŒ—' };
    return m[v] || k;
  }
  if (s === SUIT_D) {
    const m = { C: 'ä¸­', F: 'ç™¼', B: 'ç™½' };
    return m[v] || k;
  }
  return k;
}

function generateTiles() {
  const tiles = [];
  const push4 = (suit, rank) => {
    for (let i = 0; i < 4; i++) tiles.push({ suit, rank, id: tiles.length });
  };
  for (let r = 1; r <= 9; r++) {
    push4(SUIT_W, r);
    push4(SUIT_T, r);
    push4(SUIT_B, r);
  }
  WINDS.forEach(n => {
    for (let i = 0; i < 4; i++) tiles.push({ suit: SUIT_F, name: n, id: tiles.length });
  });
  DRAGONS.forEach(n => {
    for (let i = 0; i < 4; i++) tiles.push({ suit: SUIT_D, name: n, id: tiles.length });
  });
  return tiles;
}

function shuffle(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = rng(i + 1);
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* ========= éŠæˆ²è¦å‰‡èˆ‡ç‹€æ…‹ ========= */
const RULES = {
  handSize: 16,
  gold: { enabled: true, initial: 3, maxExtra: 2, totalMax: 5, perGold: 1, winOnGold: 3 },
  scoring: {
    SelfDraw: 1,
    MenqingSelfDraw: 3,
    AllPungs: 2,
    SevenPairs: 4,
    HalfFlush: 3,
    PureOneSuit: 5,
    Flower: 1,
    Wind: 1,
    RobKong: 1,
    Rinshan: 1,
    Haitei: 1,
    EarthReady: 4,
    HeavenReady: 8
  },
  points: { base: 2000, perFan: 1000 },
  initialPoints: 100000
};

let S = null;
let seatNames = ['æ±','å—','è¥¿','åŒ—'];

function getNextTurn(currentTurn) {
  const clockwiseOrder = [0, 3, 1, 2];
  const currentIndex = clockwiseOrder.indexOf(currentTurn);
  return clockwiseOrder[(currentIndex + 1) % 4];
}

const NAME_POOL = [
  'å°æ˜','å°è¯','å°ç¾','é˜¿ç','å¿—å¼·','å¿—ç²','å»ºåœ‹','ç‰æ¢…','é˜¿èŠ¬','åœ‹è¯','ç¾æƒ ','æ”¿å®','æ·‘èŠ¬','å¿—è±ª','ç§‹é¦™','ä½©ç²','æ¬£æ€¡','å®¶è±ª','æ˜æ…§','å»ºè±'
];

let randomNames = null;
let dealerStreak = 0;

function startNewHand(isFirstGame = false) {
  const useGold = document.getElementById('goldSwitch').checked;
  
  let newDealer = S?.dealer ?? 0;
  let newRound = S?.round ?? 1;
  const prevNames = S?.names || null;
  
  if (isFirstGame || !S) {
    const dice1 = Math.floor(Math.random() * 6) + 1;
    const dice2 = Math.floor(Math.random() * 6) + 1;
    const diceSum = dice1 + dice2;
    newDealer = (diceSum - 1) % 4;
    newRound = 1;
    const clockwiseOrder = [0, 3, 1, 2];
    seatNames = [];
    for (let offset = 0; offset < 4; offset++) {
      const dealerIndex = clockwiseOrder.indexOf(newDealer);
      const playerPos = clockwiseOrder[(dealerIndex + offset) % 4];
      seatNames[playerPos] = ['æ±', 'å—', 'è¥¿', 'åŒ—'][offset];
    }
    const dealerWindInit = seatNames[newDealer];
    const dealerNameInit = dealerWindInit + 'å®¶' + (newDealer === 0 ? '(ä½ )' : '');
    const pool = NAME_POOL.slice();
    const names = [];
    for (let i = 0; i < 4; i++) {
      const rIndex = Math.floor(Math.random() * pool.length);
      names.push(pool.splice(rIndex, 1)[0]);
    }
    randomNames = names;
    log(`ğŸ² æ“²éª°ï¼š${dice1} + ${dice2} = ${diceSum}ï¼ŒèŠå®¶ç‚º${dealerNameInit}`);
  } else if (S.winner === null) {
    log(`ğŸ” æµå±€é€£èŠï¼ŒèŠå®¶ç¹¼çºŒç•¶èŠ`);
  } else if (S.winner === S.dealer) {
    log(`ğŸ† èŠå®¶èƒ¡ç‰Œï¼Œç¹¼çºŒç•¶èŠ`);
  } else {
    const clockwiseOrder = [0, 3, 1, 2];
    const currentIndex = clockwiseOrder.indexOf(S.dealer);
    newDealer = clockwiseOrder[(currentIndex + 1) % 4];
    if (newDealer === S.initialDealer) {
      newRound++;
      if (newRound > 4) {
        log(`ğŸ å››åœˆå·²æ‰“å®Œï¼ŒéŠæˆ²çµæŸï¼`);
        showFinalScore();
        return;
      }
      log(`ğŸ”„ é€²å…¥ç¬¬${newRound}åœˆ`);
    }
    const rotatedWind = seatNames?.[newDealer] || ['æ±','å—','è¥¿','åŒ—'][newDealer];
    const rotatedName = rotatedWind + 'å®¶' + (newDealer === 0 ? '(ä½ )' : '');
    log(`ğŸ” èŠå®¶è¼ªæ›¿è‡³${rotatedName}`);
  }

  if (isFirstGame || !S) {
    dealerStreak = 0;
  } else {
    if (newDealer === S.dealer) {
      dealerStreak = (dealerStreak || 0) + 1;
    } else {
      dealerStreak = 0;
    }
  }
  
  S = {
    wall: shuffle(generateTiles()),
    deadWall: [],
    players: Array.from({ length: 4 }, (_, i) => ({
      hand: [],
      discards: [],
      flowers: [],
      melds: [],
      points: prevNames ? S.players[i].points : RULES.initialPoints,
      declaredListen: false,
      waitKeys: [],
      tianTing: false,
      diTing: false,
      isAI: i !== 0,
      rinshan: false
    })),
    goldKeys: [],
    kongCount: 0,
    rules: clone(RULES),
    turn: newDealer,
    dealer: newDealer,
    round: newRound,
    initialDealer: (isFirstGame || !S) ? newDealer : (S.initialDealer ?? newDealer),
    dealerStreak: dealerStreak,
    lastDiscard: null,
    waitReact: null,
    winner: null,
    fromPlayer: null,
    winTile: null,
    phase: 'deal',
    remain: 0,
    drawCount: 0,
    anyOpenMeld: false,
    robKong: false,
    lastAction: null,
    lastActor: null,
    names: prevNames || randomNames
  };
  
  if (!randomNames && prevNames) {
    randomNames = prevNames;
  }
  S.names = randomNames ? randomNames.slice() : (prevNames ? prevNames.slice() : []);
  S.rules.gold.enabled = useGold;

  dealTiles();
  if (S.rules.gold.enabled) initGoldTiles();
  S.phase = 'play';
  S.remain = S.wall.length;
  renderAll();
  
  const dealerWind = seatNames?.[S.dealer] || ['æ±', 'å—', 'è¥¿', 'åŒ—'][S.dealer];
  const dealerName = dealerWind + 'å®¶' + (S.dealer === 0 ? '(ä½ )' : '');
  const roundName = ['æ±', 'å—', 'è¥¿', 'åŒ—'][newRound - 1];
  log(`ğŸ® ç¬¬${newRound}åœˆ ${roundName}é¢¨ï¼ŒèŠå®¶ï¼š${dealerName}${S.rules.gold.enabled ? 'ï¼Œå•Ÿç”¨é‡‘ç‰Œ' : ''}`);
  
  if (S.dealer === 0) {
    log(`ğŸ‘‰ èŠå®¶æŒæœ‰17å¼µç‰Œï¼Œè«‹ç›´æ¥å‡ºç‰Œ`);
  } else {
    log(`â³ AIèŠå®¶é–‹å§‹å‡ºç‰Œ...`);
    setTimeout(stepAI, 1000 + Math.random() * 1000);
  }
}

function dealTiles() {
  const dead = 16;
  while (S.wall.length > dead && S.players[0].hand.length < 16) {
    for (let p = 0; p < 4; p++) {
      if (S.wall.length > dead) {
        S.players[p].hand.push(S.wall.pop());
      }
    }
  }
  if (S.wall.length > dead) {
    S.players[S.dealer].hand.push(S.wall.pop());
  }
  const deadWallSize = Math.min(dead, S.wall.length);
  S.deadWall = S.wall.splice(-deadWallSize, deadWallSize);
}

function initGoldTiles() {
  const candidates = [];
  for (let r = 1; r <= 9; r++) {
    candidates.push('W' + r, 'T' + r, 'B' + r);
  }
  WINDS.forEach(n => candidates.push('F' + n));
  DRAGONS.forEach(n => candidates.push('D' + n));
  while (S.goldKeys.length < 3) {
    const k = candidates[rng(candidates.length)];
    if (!S.goldKeys.includes(k)) S.goldKeys.push(k);
  }
}

function playerName(i) {
  const name = (S && S.names && S.names[i]) ? S.names[i] : (seatNames?.[i] || ['æ±', 'å—', 'è¥¿', 'åŒ—'][i]);
  return name + (i === 0 ? '(ä½ )' : '');
}

function countKongs(pl) {
  return pl.melds.filter(m => m.type === 'kong').length;
}

function updateTianDiTing(pid) {
  const pl = S.players[pid];
  if (S.anyOpenMeld) return;
  if (pid === S.dealer && S.drawCount === 1) {
    pl.tianTing = true;
    return;
  }
  if (S.drawCount <= 8) {
    pl.diTing = true;
  }
}

/* ========= èƒ¡ç‰Œåˆ¤å®š ========= */
function isWinningNow(hand, melds, winTile) {
  const tiles = hand.slice().sort((a, b) => tileSortKey(a) - tileSortKey(b));
  if (melds.length === 0 && isSevenPairs(tiles)) return true;
  const neededSets = Math.max(0, 5 - melds.length);
  return canStandardWin(tiles, neededSets);
}

function isListening(hand, melds) {
  const allPossibleTiles = [];
  for (let suit of [SUIT_W, SUIT_T, SUIT_B]) {
    for (let rank = 1; rank <= 9; rank++) {
      allPossibleTiles.push({ suit, rank, id: -1 });
    }
  }
  WINDS.forEach(name => allPossibleTiles.push({ suit: SUIT_F, name, id: -1 }));
  DRAGONS.forEach(name => allPossibleTiles.push({ suit: SUIT_D, name, id: -1 }));
  
  return allPossibleTiles.some(tile => {
    const testHand = hand.concat([tile]);
    return isWinningNow(testHand, melds, tile);
  });
}

function calcWaitingTiles(hand, melds) {
  const waits = [];
  const allPossibleTiles = [];
  for (let suit of [SUIT_W, SUIT_T, SUIT_B]) {
    for (let rank = 1; rank <= 9; rank++) {
      allPossibleTiles.push({ suit, rank, id: -1 });
    }
  }
  WINDS.forEach(name => allPossibleTiles.push({ suit: SUIT_F, name, id: -1 }));
  DRAGONS.forEach(name => allPossibleTiles.push({ suit: SUIT_D, name, id: -1 }));
  const seen = new Set();
  allPossibleTiles.forEach(tile => {
    const testHand = hand.concat([tile]);
    if (isWinningNow(testHand, melds, tile)) {
      const k = tileKey(tile);
      if (!seen.has(k)) {
        waits.push(k);
        seen.add(k);
      }
    }
  });
  waits.sort((a, b) => {
    const parseKey = (k) => {
      const s = k[0];
      const v = k.slice(1);
      if (s === SUIT_W || s === SUIT_T || s === SUIT_B) {
        return { suit: s, rank: parseInt(v), id: -1 };
      }
      if (s === SUIT_F || s === SUIT_D) {
        return { suit: s, name: v, id: -1 };
      }
      return { suit: s, id: -1 };
    };
    const ta = parseKey(a);
    const tb = parseKey(b);
    return tileSortKey(ta) - tileSortKey(tb);
  });
  return waits;
}

function isSevenPairs(tiles) {
  if (tiles.length !== 16) return false;
  const m = countByKey(tiles);
  const vals = Object.values(m);
  return vals.filter(x => x === 2).length === 8 && vals.every(x => x === 2 || x === 0);
}

function canStandardWin(tiles, need = 5) {
  const counts = countByKey(tiles);
  for (const k in counts) {
    if (counts[k] >= 2) {
      counts[k] -= 2;
      if (canSplitMelds(counts, need)) return true;
      counts[k] += 2;
    }
  }
  return false;
}

function canSplitMelds(counts, need) {
  if (need === 0) return Object.values(counts).every(v => v === 0);
  let first = null;
  for (const k in counts) {
    if (counts[k] > 0) {
      first = k;
      break;
    }
  }
  if (!first) return need === 0;
  
  if (counts[first] >= 3) {
    counts[first] -= 3;
    if (canSplitMelds(counts, need - 1)) return true;
    counts[first] += 3;
  }
  
  const s = first[0];
  const v = parseInt(first.slice(1));
  if ((s === SUIT_W || s === SUIT_T || s === SUIT_B) && v <= 7) {
    const k2 = s + (v + 1), k3 = s + (v + 2);
    if ((counts[k2] || 0) > 0 && (counts[k3] || 0) > 0) {
      counts[first]--;
      counts[k2]--;
      counts[k3]--;
      if (canSplitMelds(counts, need - 1)) return true;
      counts[first]++;
      counts[k2]++;
      counts[k3]++;
    }
  }
  return false;
}

function countByKey(tiles) {
  const m = {};
  for (const t of tiles) {
    const k = tileKey(t);
    m[k] = (m[k] || 0) + 1;
  }
  return m;
}

function tileSortKey(t) {
  const order = { W: 0, T: 1, B: 2, F: 3, D: 4, H: 5 };
  const o = order[t.suit];
  const v = (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) ? t.rank : ({ E: 1, S: 2, W: 3, N: 4, C: 5, F: 6, B: 7 }[t.name] || 0);
  return o * 100 + v;
}

/* ========= AI é‚è¼¯ ========= */
function shantenAfterRemove(hand) {
  function approxShanten14(tiles) {
    if (isWinningNow(tiles, [], null)) return 0;
    const m = countByKey(tiles);
    let pairs = 0, triples = 0, singles = 0;
    for (const k in m) {
      const c = m[k];
      if (c >= 3) triples++;
      else if (c === 2) pairs++;
      else singles++;
    }
    let est = Math.max(0, 5 - (pairs + triples));
    est += Math.ceil(singles / 4) * 0.5;
    return est;
  }
  
  let best = 99;
  const n = hand.length;
  for (let i = 0; i < n; i++) {
    const take = hand.filter((_, k) => k !== i);
    best = Math.min(best, approxShanten14(take));
  }
  
  const m = countByKey(hand);
  let pairs = 0;
  for (const k in m) {
    pairs += Math.floor(m[k] / 2);
  }
  const sevenNeed = Math.max(0, 8 - pairs);
  return Math.min(best, sevenNeed);
}

function aiChooseDiscard(pid) {
  const me = S.players[pid];
  const visible = [];
  S.players.forEach(p => visible.push(...p.discards, ...p.flowers));
  
  const listeningPlayers = [];
  for (let i = 0; i < 4; i++) {
    if (i !== pid && S.players[i].declaredListen) {
      listeningPlayers.push(i);
    }
  }
  
  let cands = me.hand.map(t => {
    const after = me.hand.filter(x => x !== t);
    const sh = shantenAfterRemove(after);
    let risk = riskOf(t);
    let waitCount = 0;
    let maxWaitTiles = 0;
    
    let dangerLevel = 0;
    if (listeningPlayers.length > 0) {
      listeningPlayers.forEach(lp => {
        if (canWinOn(lp, t)) {
          dangerLevel += 1000;
        }
      });
    }
    
    const tileKey_t = tileKey(t);
    const discardedSimilar = visible.filter(vt => {
      const vk = tileKey(vt);
      if (vk === tileKey_t) return true;
      if (t.suit === 'W' || t.suit === 'T' || t.suit === 'B') {
        const vt_tile = keyToTile(vk);
        if (vt_tile.suit === t.suit && Math.abs(vt_tile.rank - t.rank) <= 1) {
          return true;
        }
      }
      return false;
    }).length;
    
    if (discardedSimilar > 0) {
      risk *= 0.5;
    }
    
    if (isListening(after, me.melds)) {
      const waits = calcWaitingTiles(after, me.melds);
      waitCount = waits.length;
      waits.forEach(wk => {
        const total = 4;
        const used = visible.filter(vt => tileKey(vt) === wk).length;
        const remain = total - used;
        maxWaitTiles += remain;
      });
    }
    
    const m = countByKey(after);
    let pairs = 0, triples = 0, isolated = 0, sequences = 0;
    const keys = Object.keys(m);
    
    keys.forEach(k => {
      const c = m[k];
      if (c >= 3) triples++;
      else if (c === 2) pairs++;
      else if (c === 1) {
        const tile = keyToTile(k);
        if (tile.suit === 'W' || tile.suit === 'T' || tile.suit === 'B') {
          const rank = tile.rank;
          const hasLeft = m[`${tile.suit}${rank-1}`] || m[`${tile.suit}${rank-2}`];
          const hasRight = m[`${tile.suit}${rank+1}`] || m[`${tile.suit}${rank+2}`];
          if (!hasLeft && !hasRight) isolated++;
          else sequences++;
        } else {
          isolated++;
        }
      }
    });
    
    const structureScore = (triples * 80) + (sequences * 60) + (pairs * 20) - (isolated * 40);
    const score = (waitCount * 500) + (maxWaitTiles * 50) - (sh * 30) - (risk * 5) - dangerLevel + structureScore;
    return { tile: t, score };
  });
  
  cands.sort((a, b) => b.score - a.score);
  return cands[0].tile;
}

function riskOf(tile) {
  if (tile.suit === SUIT_F || tile.suit === SUIT_D) return 0.4;
  if (tile.rank === 1 || tile.rank === 9) return 0.65;
  return 1.0;
}

function keyToTile(k) {
  const s = k[0], v = k.slice(1);
  if (s === 'W' || s === 'T' || s === 'B') return { suit: s, rank: parseInt(v), id: -1 };
  if (s === 'F') return { suit: SUIT_F, name: v, id: -1 };
  if (s === 'D') return { suit: SUIT_D, name: v, id: -1 };
  return { suit: '?', id: -1 };
}

/* ========= åƒç¢°æ§“é‚è¼¯ ========= */
function canChow(pid, tile) {
  const pl = S.players[pid];
  if (pl.melds.length >= 5) return [];
  
  const clockwiseOrder = [0, 3, 1, 2];
  const currentIndex = clockwiseOrder.indexOf(S.turn);
  const nextPlayer = clockwiseOrder[(currentIndex + 1) % 4];
  if (pid !== nextPlayer) return [];
  
  if (tile.suit !== SUIT_W && tile.suit !== SUIT_T && tile.suit !== SUIT_B) return [];
  
  const rank = tile.rank;
  const suit = tile.suit;
  const patterns = [];
  
  if (rank <= 7) {
    const has1 = pl.hand.some(t => t.suit === suit && t.rank === rank + 1);
    const has2 = pl.hand.some(t => t.suit === suit && t.rank === rank + 2);
    if (has1 && has2) patterns.push([rank, rank + 1, rank + 2]);
  }
  
  if (rank >= 2 && rank <= 8) {
    const has1 = pl.hand.some(t => t.suit === suit && t.rank === rank - 1);
    const has2 = pl.hand.some(t => t.suit === suit && t.rank === rank + 1);
    if (has1 && has2) patterns.push([rank - 1, rank, rank + 1]);
  }
  
  if (rank >= 3) {
    const has1 = pl.hand.some(t => t.suit === suit && t.rank === rank - 2);
    const has2 = pl.hand.some(t => t.suit === suit && t.rank === rank - 1);
    if (has1 && has2) patterns.push([rank - 2, rank - 1, rank]);
  }
  
  return patterns;
}

function doChow(pid, tile, pattern) {
  const pl = S.players[pid];
  const suit = tile.suit;
  const tiles = [tile];
  
  pattern.forEach(rank => {
    if (rank !== tile.rank) {
      const idx = pl.hand.findIndex(t => t.suit === suit && t.rank === rank);
      if (idx >= 0) {
        tiles.push(pl.hand.splice(idx, 1)[0]);
      }
    }
  });
  
  tiles.sort((a, b) => a.rank - b.rank);
  const centerIdx = tiles.findIndex(t => t === tile);
  pl.melds.push({ type: 'chow', tiles, centerIdx });
  S.anyOpenMeld = true;
  log(`ğŸœ ${playerName(pid)} åƒäº† ${tiles.map(t => keyToText(tileKey(t))).join(' ')}`);
  showEffect('ğŸœ åƒ', '#22c55e');
  playSound(500, 0.2, 'triangle');
  
  S.turn = pid;
  S.lastDiscard = null;
  S.waitReact = null;
  hideReactionPanel();
  renderAll();
  
  S.lastAction = 'chow';
  S.lastActor = pid;
}

function canPong(pid, tile) {
  const pl = S.players[pid];
  if (pl.melds.length >= 5) return false;
  const k = tileKey(tile);
  const cnt = pl.hand.filter(t => tileKey(t) === k).length;
  return cnt >= 2;
}

function canKong(pid, tile) {
  const pl = S.players[pid];
  if (countKongs(pl) >= 3) return false;
  if (pl.melds.length >= 5) return false;
  const k = tileKey(tile);
  const cnt = pl.hand.filter(t => tileKey(t) === k).length;
  return cnt >= 3;
}

function canConcealedKong(pid) {
  const pl = S.players[pid];
  if (countKongs(pl) >= 3) return [];
  if (pl.melds.length >= 5) return [];
  if ((S.wall.length + S.deadWall.length) <= 3) return [];
  const counts = countByKey(pl.hand);
  return Object.keys(counts).filter(k => counts[k] >= 4);
}

function canAddedKong(pid) {
  const pl = S.players[pid];
  const res = [];
  if ((S.wall.length + S.deadWall.length) <= 3) return res;
  if (countKongs(pl) >= 3) return res;
  pl.melds.forEach((m, idx) => {
    if (m.type === 'pong') {
      const k = tileKey(m.tiles[0]);
      const hasFourth = pl.hand.some(t => tileKey(t) === k);
      if (hasFourth) {
        res.push({ meldIndex: idx, key: k });
      }
    }
  });
  return res;
}

function doConcealedKong(pid, key) {
  const pl = S.players[pid];
  const tiles = [];
  for (let i = pl.hand.length - 1; i >= 0; i--) {
    const t = pl.hand[i];
    if (tileKey(t) === key) {
      tiles.push(pl.hand.splice(i, 1)[0]);
      if (tiles.length === 4) break;
    }
  }
  pl.melds.push({ type: 'kong', tiles: tiles, concealed: true });
  S.kongCount++;
  if (pid === 0) {
    log(`ğŸ’¥ ${playerName(pid)} æš—æ§“ ${keyToText(key)}`);
  } else {
    log(`ğŸ’¥ ${playerName(pid)} æš—æ§“`);
  }
  showEffect('ğŸ’¥ æš—æ§“', '#a855f7');
  playSound(700, 0.3, 'sawtooth');
  
  if (S.deadWall.length > 0) {
    const newTile = S.deadWall.pop();
    pl.hand.push(newTile);
  } else if (S.wall.length > 0) {
    const newTile = S.wall.pop();
    pl.hand.push(newTile);
  }
  S.remain = S.wall.length;
  renderAll();
  
  const t = pl.hand[pl.hand.length - 1];
  if (pid === 0) {
    if (isWinningNow(pl.hand, pl.melds, t)) {
      document.getElementById('btnHu').disabled = false;
      log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
    }
  } else {
    if (isWinningNow(pl.hand, pl.melds, t)) {
      doWin(pid, -1, t, true);
      return;
    }
    setTimeout(stepAI, 1000 + Math.random() * 1000);
  }
  
  S.lastAction = 'concealedKong';
  S.lastActor = pid;
}

function doAddedKong(pid, meldIndex) {
  const pl = S.players[pid];
  const meld = pl.melds[meldIndex];
  if (!meld || meld.type !== 'pong') return;
  const key = tileKey(meld.tiles[0]);
  let idx = -1;
  for (let i = 0; i < pl.hand.length; i++) {
    if (tileKey(pl.hand[i]) === key) {
      idx = i;
      break;
    }
  }
  if (idx < 0) return;
  const tile = pl.hand.splice(idx, 1)[0];
  meld.tiles.push(tile);
  meld.type = 'kong';
  meld.added = true;
  S.anyOpenMeld = true;
  S.kongCount++;
  log(`ğŸ’¥ ${playerName(pid)} åŠ æ§“ ${keyToText(key)}`);
  showEffect('ğŸ’¥ æ§“', '#f97316');
  playSound(650, 0.3, 'sawtooth');
  
  if (S.deadWall.length > 0) {
    const newTile = S.deadWall.pop();
    pl.hand.push(newTile);
  } else if (S.wall.length > 0) {
    const newTile = S.wall.pop();
    pl.hand.push(newTile);
  }
  S.remain = S.wall.length;
  pl.rinshan = true;
  renderAll();
  
  const t = pl.hand[pl.hand.length - 1];
  if (pid === 0) {
    if (isWinningNow(pl.hand, pl.melds, t)) {
      document.getElementById('btnHu').disabled = false;
      log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
    }
  } else {
    if (isWinningNow(pl.hand, pl.melds, t)) {
      doWin(pid, -1, t, true);
      return;
    }
    setTimeout(stepAI, 1000 + Math.random() * 1000);
  }
  
  S.lastAction = 'addedKong';
  S.lastActor = pid;
}

function doPong(pid, tile) {
  const pl = S.players[pid];
  const k = tileKey(tile);
  const tiles = [tile];
  for (let i = 0; i < 2; i++) {
    const idx = pl.hand.findIndex(t => tileKey(t) === k);
    if (idx >= 0) {
      tiles.push(pl.hand.splice(idx, 1)[0]);
    }
  }
  
  S.lastAction = 'pong';
  S.lastActor = pid;
  pl.melds.push({ type: 'pong', tiles });
  S.anyOpenMeld = true;
  log(`ğŸ”¥ ${playerName(pid)} ç¢°äº† ${keyToText(k)}`);
  showEffect('ğŸ”¥ ç¢°', '#f0c14b');
  playSound(550, 0.25, 'square');
  S.turn = pid;
  S.lastDiscard = null;
  S.waitReact = null;
  hideReactionPanel();
  renderAll();
}

function doKong(pid, tile) {
  const pl = S.players[pid];
  const k = tileKey(tile);
  const tiles = [tile];
  for (let i = 0; i < 3; i++) {
    const idx = pl.hand.findIndex(t => tileKey(t) === k);
    if (idx >= 0) {
      tiles.push(pl.hand.splice(idx, 1)[0]);
    }
  }
  pl.melds.push({ type: 'kong', tiles });
  S.anyOpenMeld = true;
  S.kongCount++;
  log(`ğŸ’¥ ${playerName(pid)} æ§“äº† ${keyToText(k)}ï¼Œå¾ç‹ç‰Œè£œç‰Œ`);
  showEffect('ğŸ’¥ æ§“', '#f97316');
  playSound(650, 0.3, 'sawtooth');
  
  if (S.deadWall.length > 0) {
    const newTile = S.deadWall.pop();
    pl.hand.push(newTile);
  } else if (S.wall.length > 0) {
    const newTile = S.wall.pop();
    pl.hand.push(newTile);
  }
  S.remain = S.wall.length;
  S.lastAction = 'kong';
  S.lastActor = pid;
  S.turn = pid;
  S.lastDiscard = null;
  S.waitReact = null;
  hideReactionPanel();
  renderAll();
  
  if (pid === 0) {
    const me = S.players[0];
    const t = me.hand[me.hand.length - 1];
    if (isWinningNow(me.hand, me.melds, t)) {
      document.getElementById('btnHu').disabled = false;
      log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
    }
    if (!me.declaredListen) {
      const kongCount = countKongs(me);
      const totalTiles = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
      const expectedFull = 17 + kongCount;
      if (totalTiles === expectedFull) {
        const canListenNow = me.hand.some(tile2 => {
          const testHand = me.hand.filter(t => t !== tile2);
          return isListening(testHand, me.melds);
        });
        if (canListenNow) showListenPanel();
      }
    }
  }
}

/* ========= å‡ºç‰Œèˆ‡åæ‡‰ ========= */
function discard(p, tile) {
  const hand = S.players[p].hand;
  const i = hand.indexOf(tile);
  if (i < 0) return;
  hand.splice(i, 1);
  S.players[p].drawnTile = null;
  S.players[p].discards.push(tile);
  S.lastDiscard = { tile, from: p };
  playSound(400, 0.1, 'square');
  
  S.lastAction = 'discard';
  S.lastActor = p;
  log(`ğŸ´ ${playerName(p)} æ‰“å‡º ${keyToText(tileKey(tile))}`);
  
  S.players[p].rinshan = false;
  renderAll();
  
  {
    const pl = S.players[p];
    const kc = countKongs(pl);
    const totalP = pl.hand.length + pl.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    const expFull = 17 + kc;
    const expEmpty = 16 + kc;
    let ting = false;
    if (totalP === expFull) {
      ting = pl.hand.some(tt => {
        const test = pl.hand.filter(x => x !== tt);
        return isListening(test, pl.melds);
      });
    } else if (totalP === expEmpty) {
      ting = isListening(pl.hand, pl.melds);
    }
    if (ting) {
      const waits = calcWaitingTiles(pl.hand, pl.melds);
      pl.waitKeys = waits.slice();
      if (waits.length > 0 && p === 0) {
        const waitText = waits.map(k => keyToText(k)).join(' ');
        log('ğŸ‘‚ ç­‰ç‰Œï¼š' + waitText);
      }
    } else {
      pl.waitKeys = [];
    }
  }
  
  let reactions = [];
  for (let k = 1; k <= 3; k++) {
    const pid = (p + k) % 4;
    if (pid === p) continue;
    
    if (canWinOn(pid, tile)) {
      reactions.push({ pid, type: 'hu', tile });
    }
    if (canKong(pid, tile)) {
      reactions.push({ pid, type: 'kong', tile });
    }
    if (canPong(pid, tile)) {
      reactions.push({ pid, type: 'pong', tile });
    }
    const chowPatterns = canChow(pid, tile);
    if (chowPatterns.length > 0) {
      reactions.push({ pid, type: 'chow', tile, patterns: chowPatterns });
    }
  }
  
  if (reactions.length > 0) {
    S.waitReact = reactions;
    if (reactions.some(r => r.pid === 0)) {
      showReactionPanel(reactions.filter(r => r.pid === 0));
    } else {
      setTimeout(() => handleAIReaction(reactions), 1000 + Math.random() * 1000);
    }
  } else {
    S.turn = getNextTurn(S.turn);
    stepNext();
  }
}

function showReactionPanel(reactions) {
  const me = S.players[0];
  if (me.declaredListen) {
    reactions = reactions.filter(r => r.type === 'hu');
    if (reactions.length === 0) {
      clearReactionButtons();
      S.turn = getNextTurn(S.lastDiscard.from);
      S.lastDiscard = null;
      S.waitReact = null;
      stepNext();
      return;
    }
  }
  
  clearReactionButtons();
  S.currentReactions = reactions;
  
  reactions.forEach(r => {
    if (r.type === 'hu') {
      document.getElementById('btnHu').classList.add('active');
      document.getElementById('btnHu').disabled = false;
    } else if (r.type === 'pong') {
      document.getElementById('btnPong').classList.add('active');
      document.getElementById('btnPong').disabled = false;
    } else if (r.type === 'kong') {
      document.getElementById('btnKong').classList.add('active');
      document.getElementById('btnKong').disabled = false;
    } else if (r.type === 'chow') {
      document.getElementById('btnChow').classList.add('active');
      document.getElementById('btnChow').disabled = false;
    }
  });
  
  document.getElementById('btnPass').classList.add('active');
  document.getElementById('btnPass').disabled = false;
}

function hideReactionPanel() {
  document.getElementById('modalOverlay').classList.remove('show');
}

function clearReactionButtons() {
  const buttons = ['btnHu', 'btnChow', 'btnPong', 'btnKong', 'btnPass'];
  buttons.forEach(id => {
    const btn = document.getElementById(id);
    if (btn) {
      btn.classList.remove('active');
      btn.disabled = true;
    }
  });
}

function handleChowClick() {
  if (!S.currentReactions) return;
  const chowReact = S.currentReactions.find(r => r.type === 'chow');
  if (!chowReact) return;
  
  if (chowReact.patterns && chowReact.patterns.length > 1) {
    showChowSelectionPanel(chowReact);
  } else {
    doChow(chowReact.pid, chowReact.tile, chowReact.patterns[0]);
    clearReactionButtons();
  }
}

function showChowSelectionPanel(chowReact) {
  const overlay = document.getElementById('modalOverlay');
  const content = document.getElementById('modalContent');
  
  let html = '<div class="modal-title">ğŸœ é¸æ“‡åƒæ³•</div>';
  html += '<div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">';
  chowReact.patterns.forEach((pat, idx) => {
    const patText = [...pat].sort((a, b) => a - b).map(r => r).join('-');
    html += `<button class="btn btn-secondary chowOpt" data-idx="${idx}" style="min-width: 80px;">ğŸœ ${patText}</button>`;
  });
  html += '</div>';
  html += '<button class="modal-btn" id="cancelChow" style="background: var(--bg-card); margin-top: 12px;">å–æ¶ˆ</button>';
  
  content.innerHTML = html;
  overlay.classList.add('show');
  
  const opts = content.querySelectorAll('.chowOpt');
  opts.forEach(btn => {
    const idx = parseInt(btn.getAttribute('data-idx'));
    btn.onclick = () => {
      doChow(chowReact.pid, chowReact.tile, chowReact.patterns[idx]);
      overlay.classList.remove('show');
      clearReactionButtons();
    };
  });
  
  document.getElementById('cancelChow').onclick = () => {
    overlay.classList.remove('show');
  };
}

function handlePongClick() {
  if (!S.currentReactions) return;
  const pongReact = S.currentReactions.find(r => r.type === 'pong');
  if (!pongReact) return;
  doPong(pongReact.pid, pongReact.tile);
  clearReactionButtons();
}

function handleKongClick() {
  if (!S.currentReactions) return;
  const kongReact = S.currentReactions.find(r => r.type === 'kong');
  if (!kongReact) return;
  doKong(kongReact.pid, kongReact.tile);
  clearReactionButtons();
}

function handleHuClick() {
  if (!S.currentReactions) return;
  const huReact = S.currentReactions.find(r => r.type === 'hu');
  if (!huReact) return;
  doWin(huReact.pid, S.lastDiscard.from, huReact.tile, false);
  clearReactionButtons();
}

function handlePassClick() {
  clearReactionButtons();
  S.turn = getNextTurn(S.lastDiscard.from);
  S.lastDiscard = null;
  S.waitReact = null;
  S.currentReactions = null;
  stepNext();
}

function showListenPanel() {
  const overlay = document.getElementById('modalOverlay');
  const content = document.getElementById('modalContent');
  
  let html = '<div class="modal-title">ğŸ”” æ˜¯å¦å ±è½ï¼Ÿ</div>';
  html += '<div style="display: flex; gap: 12px; justify-content: center;">';
  html += '<button class="btn btn-primary" id="listenYes" style="flex: 1;">ğŸ”” è½ç‰Œ</button>';
  html += '<button class="btn btn-secondary" id="listenNo" style="flex: 1;">â­ï¸ ä¸è½</button>';
  html += '</div>';
  
  content.innerHTML = html;
  overlay.classList.add('show');
  
  document.getElementById('listenYes').onclick = () => {
    const me = S.players[0];
    if (!me.declaredListen) {
      me.declaredListen = true;
      me.tingLocked = false;
      updateTianDiTing(0);
      const waitKeys = calcWaitingTiles(me.hand, me.melds);
      const waitText = waitKeys.map(k => keyToText(k)).join(' ');
      if (me.tianTing) {
        log('ğŸ”” ä½ å®£å‘Šå¤©è½ï¼èƒ¡ç‰Œæ™‚å¤š ' + RULES.scoring.HeavenReady + ' å°');
      } else if (me.diTing) {
        log('ğŸ”” ä½ å®£å‘Šåœ°è½ï¼èƒ¡ç‰Œæ™‚å¤š ' + RULES.scoring.EarthReady + ' å°');
      } else {
        log('ğŸ”” ä½ å®£å‘Šè½ç‰Œï¼èƒ¡ç‰Œæ™‚å¤š 1 å°');
      }
      log('âš ï¸ è«‹ä¸Ÿä¸€å¼µæ‰‹ç‰Œå¾Œé–å®šè½ç‰Œ');
      if (waitKeys.length > 0) {
        me.waitKeys = waitKeys.slice();
        log('ğŸ‘‚ ç­‰å¾…ç‰Œï¼š' + waitText);
      } else {
        me.waitKeys = [];
      }
    }
    overlay.classList.remove('show');
    renderAll();
  };
  
  document.getElementById('listenNo').onclick = () => {
    overlay.classList.remove('show');
  };
}

function handleAIReaction(reactions) {
  const huReact = reactions.find(r => r.type === 'hu');
  if (huReact) {
    doWin(huReact.pid, S.lastDiscard.from, huReact.tile, false);
    return;
  }
  
  reactions = reactions.filter(r => {
    const p = S.players[r.pid];
    if (p.declaredListen) {
      return r.type === 'hu' || r.type === 'kong';
    }
    return true;
  });
  
  const kongReact = reactions.find(r => r.type === 'kong');
  if (kongReact && Math.random() > 0.2) {
    doKong(kongReact.pid, kongReact.tile);
    setTimeout(stepAI, 1000 + Math.random() * 1000);
    return;
  }
  
  const pongReact = reactions.find(r => r.type === 'pong');
  if (pongReact && Math.random() > 0.3) {
    doPong(pongReact.pid, pongReact.tile);
    setTimeout(stepAI, 1000 + Math.random() * 1000);
    return;
  }
  
  const chowReact = reactions.find(r => r.type === 'chow');
  if (chowReact) {
    const me = S.players[chowReact.pid];
    const pattern = chowReact.patterns[0];
    const tile = chowReact.tile;
    const suit = tile.suit;
    
    const afterChow = me.hand.filter(t => {
      const key = tileKey(t);
      const needed = pattern.map(r => suit + r);
      const idx = needed.indexOf(key);
      if (idx >= 0) {
        needed.splice(idx, 1);
        return false;
      }
      return true;
    });
    
    const shBefore = shantenAfterRemove(me.hand);
    const shAfter = shantenAfterRemove(afterChow);
    
    if (shAfter <= shBefore && Math.random() > 0.4) {
      doChow(chowReact.pid, chowReact.tile, pattern);
      setTimeout(stepAI, 1000 + Math.random() * 1000);
      return;
    }
  }
  
  S.turn = getNextTurn(S.lastDiscard.from);
  S.lastDiscard = null;
  S.waitReact = null;
  stepNext();
}

function canWinOn(pid, tile) {
  const pl = S.players[pid];
  const tmp = pl.hand.concat([tile]);
  return isWinningNow(tmp, pl.melds, tile);
}

function doWin(winner, from, tile, selfDraw) {
  S.winner = winner;
  S.fromPlayer = from;
  S.winTile = tile;
  S.phase = 'end';
  showEffect('ğŸ‰ èƒ¡äº†ï¼', '#f0c14b', '56px');
  playSound(800, 0.5, 'sine');
  setTimeout(() => playSound(1000, 0.5, 'sine'), 200);
  
  const detail = calcFanDetails(winner, tile, selfDraw);
  const fan = detail.fan;
  const delta = RULES.points.base + fan * RULES.points.perFan;
  
  const catStr = detail.categories.join('ã€');
  if (selfDraw) {
    for (let i = 0; i < 4; i++) {
      if (i !== winner) {
        S.players[i].points -= delta;
      }
    }
    S.players[winner].points += delta * 3;
    log(`ğŸ‰ ${playerName(winner)} è‡ªæ‘¸ ${keyToText(tileKey(tile))}ï¼ˆ${catStr}ï¼Œå…±${fan}å°ï¼‰â†’ æ¯å®¶ä»˜ ${delta.toLocaleString()}`);
  } else {
    S.players[from].points -= delta * 3;
    S.players[winner].points += delta * 3;
    log(`ğŸ‰ ${playerName(winner)} é»èƒ¡ ${playerName(from)}ï¼ˆ${keyToText(tileKey(tile))}ï¼Œ${catStr}ï¼Œå…±${fan}å°ï¼‰â†’ æ”¾æ§è€…ä»˜ ${(delta * 3).toLocaleString()}`);
  }
  
  renderAll();
  S.players[winner].rinshan = false;
  S.robKong = false;
  
  for (let i = 0; i < 4; i++) {
    if (S.players[i].points <= 0) {
      log(`âš ï¸ ${playerName(i)} ç ´ç”¢ï¼ŒéŠæˆ²çµæŸ`);
      setTimeout(() => showFinalScore(), 1500);
      return;
    }
  }
  
  setTimeout(() => showHandsAndContinue(), 1000);
}

function calcFanDetails(winner, winTile, selfDraw) {
  const pl = S.players[winner];
  const allTiles = pl.hand.concat(pl.melds.flatMap(m => m.tiles));
  let fan = 0;
  const categories = [];
  
  if (isSevenPairs(pl.hand.concat([winTile]))) {
    fan += RULES.scoring.SevenPairs;
    categories.push('ä¸ƒå°');
  }
  
  const kinds = countByKey(pl.hand.concat([winTile]));
  const allTrip = isAllPungsPossible(kinds);
  if (allTrip) {
    fan += RULES.scoring.AllPungs;
    categories.push('å°å°èƒ¡');
  }
  
  const suitCnt = { W: 0, T: 0, B: 0 };
  let honors = 0;
  for (const t of allTiles) {
    const k = tileKey(t)[0];
    if (suitCnt[k] != null) suitCnt[k]++;
    else if (k === 'F' || k === 'D') honors++;
  }
  
  const nz = Object.values(suitCnt).filter(x => x > 0).length;
  if (nz === 1 && honors === 0) {
    fan += RULES.scoring.PureOneSuit;
    categories.push('æ¸…ä¸€è‰²');
  } else if (nz === 1 && honors > 0) {
    fan += RULES.scoring.HalfFlush;
    categories.push('æ··ä¸€è‰²');
  }
  
  if (pl.tianTing) {
    fan += RULES.scoring.HeavenReady;
    categories.push('å¤©è½');
  } else if (pl.diTing) {
    fan += RULES.scoring.EarthReady;
    categories.push('åœ°è½');
  } else if (pl.declaredListen) {
    fan += 1;
    categories.push('å ±è½');
  }
  
  if (selfDraw) {
    const menqing = pl.melds.length === 0;
    if (menqing) {
      fan += RULES.scoring.MenqingSelfDraw;
      categories.push('é–€æ¸…è‡ªæ‘¸');
    } else {
      fan += RULES.scoring.SelfDraw;
      categories.push('è‡ªæ‘¸');
    }
  }
  
  if (S.robKong) {
    fan += RULES.scoring.RobKong;
    categories.push('æ¶æ§“');
  }
  
  if (selfDraw && pl.rinshan) {
    fan += RULES.scoring.Rinshan;
    categories.push('æ§“ä¸Šé–‹èŠ±');
  }
  
  if (S.rules.gold.enabled) {
    const keys = allTiles.map(tileKey);
    const goldOwned = keys.filter(k => S.goldKeys.includes(k)).length;
    fan += goldOwned * S.rules.gold.perGold;
    if (goldOwned > 0) categories.push(`é‡‘ç‰Œx${goldOwned}`);
    if (S.goldKeys.includes(tileKey(winTile))) {
      fan += S.rules.gold.winOnGold;
      categories.push('é‡‘ç‰Œèƒ¡');
    }
  }
  
  if (categories.length === 0) categories.push('å¹³èƒ¡');
  return { fan: Math.max(1, fan), categories };
}

function isAllPungsPossible(counts) {
  let pairs = 0;
  let triples = 0;
  for (const k in counts) {
    const c = counts[k];
    if (c === 2) pairs++;
    else if (c >= 3) triples++;
    else if (c === 1) return false;
  }
  return pairs === 1 && triples >= 4;
}

/* ========= éŠæˆ²æµç¨‹ ========= */
function stepNext() {
  if (S.phase === 'end') return;
  
  const dead = 16 + S.kongCount;
  if (S.wall.length <= 0) {
    log('ğŸš« æµå±€ - ç‰Œå±±æ¯ç«­');
    S.phase = 'end';
    S.winner = null;
    renderAll();
    setTimeout(() => showHandsAndContinue(), 1000);
    return;
  }
  
  if (S.turn === 0) {
    draw(0);
    renderAll();
    const me = S.players[0];
    const t = me.hand[me.hand.length - 1];
    if (isWinningNow(me.hand, me.melds, t)) {
      document.getElementById('btnHu').disabled = false;
      log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
    }
  } else {
    setTimeout(stepAI, 800 + Math.random() * 800);
  }
}

function stepAI() {
  if (S.phase === 'end') return;
  if (S.turn === 0) return;
  
  const pid = S.turn;
  const pl = S.players[pid];
  
  if (S.lastAction === 'discard' || S.lastAction === null) {
    draw(pid);
  }
  
  const t = pl.hand[pl.hand.length - 1];
  if (isWinningNow(pl.hand, pl.melds, t)) {
    doWin(pid, -1, t, true);
    return;
  }
  
  const cks = canConcealedKong(pid);
  if (cks.length > 0 && Math.random() > 0.3) {
    doConcealedKong(pid, cks[0]);
    return;
  }
  
  const aks = canAddedKong(pid);
  if (aks.length > 0 && Math.random() > 0.4) {
    const candidate = aks[0];
    const tile = pl.hand.find(t => tileKey(t) === candidate.key);
    for (let other = 0; other < 4; other++) {
      if (other !== pid && canWinOn(other, tile)) {
        S.robKong = true;
        doWin(other, pid, tile, false);
        return;
      }
    }
    doAddedKong(pid, candidate.meldIndex);
    return;
  }
  
  if (!pl.declaredListen && isListening(pl.hand, pl.melds) && Math.random() > 0.5) {
    pl.declaredListen = true;
    updateTianDiTing(pid);
    log(`ğŸ”” ${playerName(pid)} å ±è½`);
  }
  
  const discardTile = aiChooseDiscard(pid);
  discard(pid, discardTile);
}

function draw(p) {
  if (S.wall.length === 0) return;
  const t = S.wall.pop();
  S.players[p].hand.push(t);
  S.players[p].drawnTile = t;
  S.remain = S.wall.length;
  S.drawCount++;
  playSound(600, 0.1, 'sine');
  
  if (p === 0) {
    const k = tileKey(t);
    log(`ğŸ¤² ä½ æ‘¸åˆ° ${keyToText(k)}`);
  }
  
  S.lastAction = 'draw';
  S.lastActor = p;
}

/* ========= UI æ¸²æŸ“ ========= */
function renderAll() {
  // æ›´æ–°å›åˆè³‡è¨Š
  const roundStr = ['æ±','å—','è¥¿','åŒ—'][S.round - 1] + 'é¢¨' + (seatNames?.[S.dealer] || ['æ±','å—','è¥¿','åŒ—'][S.dealer]);
  document.getElementById('centerRound').textContent = roundStr;
  document.getElementById('centerRemain').textContent = Math.max(0, S.wall.length);
  
  // é‡‘ç‰Œé¡¯ç¤º
  const goldDisplay = document.getElementById('goldDisplay');
  const goldTiles = document.getElementById('goldTiles');
  if (S.rules.gold.enabled && S.goldKeys && S.goldKeys.length > 0) {
    goldDisplay.style.display = 'flex';
    goldTiles.innerHTML = S.goldKeys.map(k => {
      const text = keyToText(k);
      let colorClass = 'suit-' + k[0];
      return `<div class="gold-tile ${colorClass}">${text}</div>`;
    }).join('');
  } else {
    goldDisplay.style.display = 'none';
  }
  
  // å°æ‰‹å€åŸŸ
  const opponentsArea = document.getElementById('opponentsArea');
  let opponentsHTML = '';
  for (let i = 1; i <= 3; i++) {
    const p = S.players[i];
    const wind = seatNames[i] || ['æ±','å—','è¥¿','åŒ—'][i];
    const name = S.names && S.names[i] ? S.names[i] : wind + 'å®¶';
    const isActive = S.turn === i && S.phase !== 'end';
    const isDealer = S.dealer === i;
    
    opponentsHTML += `
      <div class="opponent-card ${isActive ? 'active-turn' : ''}">
        <div class="opponent-header">
          <div class="opponent-name">
            <div class="wind-icon">${wind}</div>
            <span>${name}</span>
            ${isDealer ? '<span class="dealer-mark">èŠ</span>' : ''}
            ${p.declaredListen ? '<span class="listen-mark">è½</span>' : ''}
          </div>
          <div class="opponent-score">${p.points.toLocaleString()}</div>
        </div>
        <div class="opponent-content">
          <div class="discard-zone">
            <span class="discard-zone-label">æ¨ç‰Œ</span>
            ${p.discards.map(t => {
              const k = tileKey(t);
              const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
              return `<div class="tile tile-xs suit-${t.suit} ${isGold ? 'gold' : ''}">${keyToText(k)}</div>`;
            }).join('')}
          </div>
          ${p.melds.length > 0 ? `
            <div class="meld-zone">
              ${p.melds.map(m => {
                const isConcealed = m.concealed;
                return `<div class="meld-group">
                  ${m.tiles.map(t => {
                    if (isConcealed) {
                      return `<div class="tile tile-xs" style="background: #4a5568; color: transparent;">ç‰Œ</div>`;
                    }
                    const k = tileKey(t);
                    const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
                    return `<div class="tile tile-xs suit-${t.suit} ${isGold ? 'gold' : ''}">${keyToText(k)}</div>`;
                  }).join('')}
                </div>`;
              }).join('')}
            </div>
          ` : ''}
        </div>
      </div>
    `;
  }
  opponentsArea.innerHTML = opponentsHTML;
  
  // æˆ‘çš„è³‡è¨Š
  const me = S.players[0];
  const myWind = seatNames[0] || 'æ±';
  document.getElementById('myWind').textContent = myWind;
  document.getElementById('myName').textContent = S.names && S.names[0] ? S.names[0] + '(ä½ )' : 'ä½ ';
  document.getElementById('myScore').textContent = me.points.toLocaleString();
  
  const myDealerMark = document.getElementById('myDealerMark');
  const myListenMark = document.getElementById('myListenMark');
  if (S.dealer === 0) {
    myDealerMark.classList.remove('hidden');
  } else {
    myDealerMark.classList.add('hidden');
  }
  if (me.declaredListen) {
    myListenMark.classList.remove('hidden');
  } else {
    myListenMark.classList.add('hidden');
  }
  
  // è½ç‰Œæç¤º
  const listenHint = document.getElementById('listenHint');
  if (me.waitKeys && me.waitKeys.length > 0) {
    listenHint.classList.remove('hidden');
    listenHint.innerHTML = 'ğŸ‘‚ ç­‰ç‰Œï¼š' + me.waitKeys.map(k => `<span class="tile log-tile suit-${k[0]}">${keyToText(k)}</span>`).join(' ');
  } else {
    listenHint.classList.add('hidden');
  }
  
  // æˆ‘çš„æ‰‹ç‰Œ
  const kongCount = countKongs(me);
  const expectedFull = 17 + kongCount;
  const hasDrawn = (me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0)) === expectedFull;
  
  const origTiles = me.hand.map((t, idx) => ({ tile: t, index: idx }));
  let displayRest = [];
  let drawnObj = null;
  
  if (hasDrawn && me.hand.length > 0) {
    drawnObj = origTiles[origTiles.length - 1];
    const rest = origTiles.slice(0, -1);
    displayRest = rest.sort((a, b) => tileSortKey(a.tile) - tileSortKey(b.tile));
  } else {
    displayRest = origTiles.slice().sort((a, b) => tileSortKey(a.tile) - tileSortKey(b.tile));
  }
  
  let handHTML = '';
  displayRest.forEach(item => {
    const t = item.tile;
    const idx = item.index;
    const k = tileKey(t);
    const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
    handHTML += `<div class="tile tile-md suit-${t.suit} ${isGold ? 'gold' : ''}" onclick="onClickYourTile(${idx})">${keyToText(k)}</div>`;
  });
  
  if (hasDrawn && drawnObj) {
    const t = drawnObj.tile;
    const idx = drawnObj.index;
    const k = tileKey(t);
    const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
    handHTML += `<div style="width: 12px;"></div>`;
    handHTML += `<div class="tile tile-md drawn suit-${t.suit} ${isGold ? 'gold' : ''}" onclick="onClickYourTile(${idx})">${keyToText(k)}</div>`;
  }
  
  document.getElementById('yourHand').innerHTML = handHTML;
  
  // æˆ‘çš„å‰¯éœ²
  let meldsHTML = '';
  if (me.melds.length > 0) {
    meldsHTML = me.melds.map(m => {
      let label = '';
      if (m.type === 'pong') label = 'ç¢°';
      if (m.type === 'kong') label = m.concealed ? 'æš—æ§“' : 'æ§“';
      if (m.type === 'chow') label = 'åƒ';
      
      let tilesForDisp;
      if (m.type === 'chow' && typeof m.centerIdx === 'number') {
        const arr = m.tiles.slice();
        const center = arr.splice(m.centerIdx, 1)[0];
        const lower = arr[0];
        const higher = arr[1];
        tilesForDisp = [lower, center, higher];
      } else {
        tilesForDisp = m.tiles;
      }
      
      const tilesHTML = tilesForDisp.map(t => {
        const k = tileKey(t);
        const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
        return `<span class="tile tile-sm suit-${t.suit} ${isGold ? 'gold' : ''}">${keyToText(k)}</span>`;
      }).join('');
      
      return `<div class="meld-badge"><span class="meld-label">${label}</span>${tilesHTML}</div>`;
    }).join('');
  }
  document.getElementById('yourMelds').innerHTML = meldsHTML;
  
  // æŒ‰éˆ•ç‹€æ…‹
  const btnHu = document.getElementById('btnHu');
  btnHu.disabled = true;
  if (S.turn === 0 && S.phase !== 'end') {
    const total = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    if (total === expectedFull && me.hand.length > 0) {
      const lastTile = me.hand[me.hand.length - 1];
      if (isWinningNow(me.hand, me.melds, lastTile)) {
        btnHu.disabled = false;
      }
    }
  }
  
  // è½ç‰ŒæŒ‰éˆ•
  let canListenBtn = false;
  if (me.declaredListen) {
    canListenBtn = false;
  } else if (S.turn === 0 && S.phase !== 'end') {
    const totalTilesMe = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    const expectedEmpty = 16 + kongCount;
    if (totalTilesMe === expectedFull) {
      const canListenAfterDiscard = me.hand.some(tile => {
        const testHand = me.hand.filter(t => t !== tile);
        return isListening(testHand, me.melds);
      });
      if (canListenAfterDiscard) canListenBtn = true;
    }
    if (totalTilesMe === expectedEmpty) {
      canListenBtn = isListening(me.hand, me.melds);
    }
  }
  document.getElementById('btnListen').disabled = !canListenBtn;
  
  // æ§“æŒ‰éˆ•
  const btnKong = document.getElementById('btnKong');
  if (S.turn === 0 && S.phase !== 'end' && S.waitReact === null) {
    const cks = canConcealedKong(0);
    const aks = canAddedKong(0);
    btnKong.disabled = (cks.length === 0 && aks.length === 0);
  } else {
    btnKong.disabled = true;
  }
}

function showHandsAndContinue() {
  const overlay = document.getElementById('modalOverlay');
  const content = document.getElementById('modalContent');
  
  let html = '';
  
  if (S.winner !== null) {
    const detail = calcFanDetails(S.winner, S.winTile, S.fromPlayer === -1);
    const catStr = detail.categories.join('ã€');
    const winnerName = playerName(S.winner);
    
    if (S.fromPlayer === -1) {
      html += `<div class="modal-title">ğŸ‰ ${winnerName} è‡ªæ‘¸èƒ¡ç‰Œ</div>`;
    } else {
      const loserName = playerName(S.fromPlayer);
      html += `<div class="modal-title">ğŸ‰ ${winnerName} é»èƒ¡</div>`;
      html += `<div style="text-align: center; color: var(--accent-red); margin-bottom: 12px;">æ”¾æ§ï¼š${loserName}</div>`;
    }
    html += `<div style="text-align: center; color: var(--accent-jade); font-size: 16px; margin-bottom: 16px;">${catStr}ï¼Œå…± <strong>${detail.fan}</strong> å°</div>`;
  } else {
    html += '<div class="modal-title">ğŸš« æµå±€</div>';
    html += '<div style="text-align: center; color: var(--text-secondary); margin-bottom: 16px;">ç‰Œå±±æ¯ç«­</div>';
  }
  
  html += '<div class="modal-section-title">æ‰€æœ‰ç©å®¶æ‰‹ç‰Œ</div>';
  
  for (let i = 0; i < 4; i++) {
    const p = S.players[i];
    const name = playerName(i);
    const isWinner = (S.winner === i);
    
    html += `<div class="modal-player ${isWinner ? 'winner' : ''}">`;
    html += `<div class="modal-player-header">
      <span class="modal-player-name">${isWinner ? 'ğŸ† ' : ''}${name}</span>
      <span class="modal-player-score">${p.points.toLocaleString()}</span>
    </div>`;
    
    html += '<div class="modal-hand">';
    const sortedHand = p.hand.slice().sort((a, b) => tileSortKey(a) - tileSortKey(b));
    sortedHand.forEach(t => {
      const k = tileKey(t);
      const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
      html += `<div class="tile tile-sm suit-${t.suit} ${isGold ? 'gold' : ''}">${keyToText(k)}</div>`;
    });
    html += '</div>';
    
    if (p.melds.length > 0) {
      html += '<div style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px;">';
      p.melds.forEach(m => {
        html += '<div style="display: flex; gap: 2px;">';
        m.tiles.forEach(t => {
          const k = tileKey(t);
          const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
          html += `<div class="tile tile-sm suit-${t.suit} ${isGold ? 'gold' : ''}">${keyToText(k)}</div>`;
        });
        html += '</div>';
      });
      html += '</div>';
    }
    
    html += '</div>';
  }
  
  html += '<button class="modal-btn" id="btnContinueNext">â–¶ï¸ ç¹¼çºŒä¸‹ä¸€å±€</button>';
  
  content.innerHTML = html;
  overlay.classList.add('show');
  
  document.getElementById('btnContinueNext').onclick = () => {
    overlay.classList.remove('show');
    log('â€”â€” é–‹ä¸‹ä¸€å±€ â€”â€”');
    startNewHand();
  };
}

function showFinalScore() {
  S.phase = 'end';
  renderAll();
  
  const overlay = document.getElementById('modalOverlay');
  const content = document.getElementById('modalContent');
  
  const rankings = S.players.map((p, i) => ({ name: playerName(i), points: p.points, index: i }))
    .sort((a, b) => b.points - a.points);
  
  let html = '<div class="modal-title">ğŸ† éŠæˆ²çµæŸ</div>';
  html += '<div class="modal-section">';
  
  const medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', '4ï¸âƒ£'];
  rankings.forEach((r, rank) => {
    html += `<div style="display: flex; justify-content: space-between; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px; margin-bottom: 8px;">
      <span>${medals[rank]} ${r.name}</span>
      <span style="color: var(--accent-jade); font-weight: 700;">${r.points.toLocaleString()}</span>
    </div>`;
  });
  
  html += '</div>';
  html += '<button class="modal-btn" id="btnNewGame">ğŸ® é–‹å§‹æ–°éŠæˆ²</button>';
  
  content.innerHTML = html;
  overlay.classList.add('show');
  
  document.getElementById('btnNewGame').onclick = () => {
    overlay.classList.remove('show');
    document.getElementById('log').innerHTML = '';
    dealerStreak = 0;
    startNewHand(true);
  };
}

/* ========= äº‹ä»¶ç¶å®š ========= */
document.getElementById('btnHu').onclick = () => {
  initAudio();
  if (S.currentReactions) {
    handleHuClick();
  } else {
    const me = S.players[0];
    const kongCount = countKongs(me);
    const expectedFull = 17 + kongCount;
    const total = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    if (total === expectedFull && me.hand.length > 0) {
      const lastTile = me.hand[me.hand.length - 1];
      if (isWinningNow(me.hand, me.melds, lastTile)) {
        doWin(0, -1, lastTile, true);
      }
    }
  }
};

document.getElementById('btnListen').onclick = () => {
  initAudio();
  if (S.turn !== 0 || S.phase === 'end') return;
  const me = S.players[0];
  if (me.declaredListen) return;
  
  const kongCount = countKongs(me);
  const total = me.hand.length + me.melds.reduce((s, m) => s + m.tiles.length, 0);
  const expectedFull = 17 + kongCount;
  const expectedEmpty = 16 + kongCount;
  
  let canListen = false;
  if (total === expectedFull) {
    canListen = me.hand.some(tile => {
      const testHand = me.hand.filter(t => t !== tile);
      return isListening(testHand, me.melds);
    });
  } else if (total === expectedEmpty) {
    canListen = isListening(me.hand, me.melds);
  }
  
  if (!canListen) {
    log('âš ï¸ ä½ é‚„æ²’æœ‰è½ç‰Œï¼Œç„¡æ³•å ±è½');
    return;
  }
  
  me.declaredListen = true;
  me.tingLocked = false;
  updateTianDiTing(0);
  const waits = calcWaitingTiles(me.hand, me.melds);
  me.waitKeys = waits.slice();
  const waitText = waits.map(k => keyToText(k)).join(' ');
  log('ğŸ”” ä½ å ±è½äº†ï¼');
  log('ğŸ‘‚ ç­‰ç‰Œï¼š' + waitText);
  log('âš ï¸ è«‹é¸æ“‡ä¸€å¼µæ‰‹ç‰Œæ‰“å‡ºä»¥å®Œæˆè½ç‰Œ');
  renderAll();
};

document.getElementById('btnKong').onclick = () => {
  initAudio();
  if (S.turn !== 0 || S.phase === 'end' || S.lastDiscard !== null) return;
  const me = S.players[0];
  const added = canAddedKong(0);
  const concealed = canConcealedKong(0);
  
  if (added.length > 0) {
    const cand = added[0];
    const key = cand.key;
    const tile = me.hand.find(t => tileKey(t) === key);
    for (let pid = 1; pid < 4; pid++) {
      if (canWinOn(pid, tile)) {
        S.robKong = true;
        doWin(pid, 0, tile, false);
        return;
      }
    }
    doAddedKong(0, cand.meldIndex);
    return;
  }
  
  if (concealed.length > 0) {
    const key = concealed[0];
    doConcealedKong(0, key);
    return;
  }
};

document.getElementById('newGameBtn').onclick = () => {
  initAudio();
  S = { players: Array.from({ length: 4 }, () => ({ points: RULES.initialPoints })) };
  document.getElementById('log').innerHTML = '';
  dealerStreak = 0;
  startNewHand(true);
};

document.getElementById('btnChow').onclick = () => {
  initAudio();
  handleChowClick();
};

document.getElementById('btnPong').onclick = () => {
  initAudio();
  handlePongClick();
};

document.getElementById('btnPass').onclick = () => {
  initAudio();
  handlePassClick();
};

function onClickYourTile(idx) {
  initAudio();
  if (S.turn !== 0 || S.phase === 'end') return;
  const me = S.players[0];
  
  if (S.waitReact !== null) {
    log('âš ï¸ è«‹å…ˆé¸æ“‡åƒã€ç¢°ã€æ§“æˆ–é');
    return;
  }
  
  if (me.declaredListen && !me.tingLocked) {
    const tile = me.hand[idx];
    const afterDiscard = me.hand.filter(t => t !== tile);
    if (!isListening(afterDiscard, me.melds)) {
      log('âš ï¸ å ±è½å¾Œåªèƒ½ä¸Ÿæœƒå½¢æˆè½ç‰Œçš„æ‰‹ç‰Œ');
      return;
    }
  }
  
  if (me.declaredListen && me.tingLocked) {
    if (me.drawnTile) {
      const selected = me.hand[idx];
      if (selected !== me.drawnTile) {
        log('âš ï¸ å·²é–å®šè½ç‰Œï¼Œåªèƒ½æ‰“å‰›æ‘¸çš„ç‰Œ');
        return;
      }
    } else {
      const kongCount = countKongs(me);
      const expectedFull = 17 + kongCount;
      const totalTiles = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
      const hasDrawn = (totalTiles === expectedFull);
      if (hasDrawn) {
        const lastIdx = me.hand.length - 1;
        if (idx !== lastIdx) {
          log('âš ï¸ å·²é–å®šè½ç‰Œï¼Œåªèƒ½æ‰“å‰›æ‘¸çš„ç‰Œ');
          return;
        }
      }
    }
  }
  
  const tile = me.hand[idx];
  discard(0, tile);
  
  if (me.declaredListen && !me.tingLocked) {
    me.tingLocked = true;
    log('ğŸ”’ è½ç‰Œå·²é–å®šï¼Œä¹‹å¾Œåªèƒ½æ‰“æ‘¸åˆ°çš„ç‰Œ');
  }
}

/* ========= å•Ÿå‹•éŠæˆ² ========= */
startNewHand(true);
</script>
</body>
</html>
