<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>éº»å°‡å–®æ©Ÿï¼ˆæ‰‹æ©Ÿç‰ˆï¼‰</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700;900&display=swap" rel="stylesheet">
<style>
:root {
  --bg-primary: #0a1628;
  --bg-secondary: #162236;
  --bg-card: #1e3a5f;
  --accent-gold: #f0c14b;
  --accent-jade: #2dd4bf;
  --accent-red: #ef4444;
  --accent-blue: #3b82f6;
  --accent-green: #22c55e;
  --text-primary: #f8fafc;
  --text-secondary: #94a3b8;
  --border-subtle: rgba(255,255,255,0.08);
  --glow-gold: rgba(240,193,75,0.4);
  --glow-jade: rgba(45,212,191,0.3);
  
  --tile-wan: #dc2626;
  --tile-tong: #2563eb;
  --tile-tiao: #16a34a;
  --tile-zi: #78350f;
  
  --safe-bottom: env(safe-area-inset-bottom, 0px);
  --safe-top: env(safe-area-inset-top, 0px);
}

* {
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
}

html, body {
  margin: 0;
  padding: 0;
  overflow-x: hidden;
  overscroll-behavior: none;
}

body {
  font-family: 'Noto Sans TC', system-ui, -apple-system, sans-serif;
  background: var(--bg-primary);
  background-image: 
    radial-gradient(ellipse at 20% 0%, rgba(45,212,191,0.08) 0%, transparent 50%),
    radial-gradient(ellipse at 80% 100%, rgba(240,193,75,0.06) 0%, transparent 50%);
  color: var(--text-primary);
  min-height: 100vh;
  min-height: 100dvh;
  display: flex;
  flex-direction: column;
  padding-top: var(--safe-top);
  padding-bottom: var(--safe-bottom);
}

/* ===== é ‚éƒ¨ç‹€æ…‹åˆ— ===== */
.status-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 16px;
  padding-top: calc(10px + var(--safe-top));
  background: linear-gradient(180deg, rgba(30,58,95,0.95) 0%, rgba(22,34,54,0.9) 100%);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border-bottom: 1px solid var(--border-subtle);
  position: sticky;
  top: 0;
  z-index: 100;
  flex-wrap: wrap;
  gap: 8px;
}

.round-badge {
  display: flex;
  align-items: center;
  gap: 6px;
  background: linear-gradient(135deg, var(--accent-gold) 0%, #d4a03a 100%);
  color: var(--bg-primary);
  padding: 6px 14px;
  border-radius: 20px;
  font-weight: 700;
  font-size: 13px;
  box-shadow: 0 2px 12px var(--glow-gold);
}

.remain-badge {
  display: flex;
  align-items: center;
  gap: 4px;
  background: rgba(255,255,255,0.08);
  padding: 6px 12px;
  border-radius: 16px;
  font-size: 12px;
  color: var(--text-secondary);
}

.remain-badge strong {
  color: var(--accent-jade);
  font-size: 16px;
}

/* ===== é‡‘ç‰Œå±•ç¤º ===== */
.gold-display {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 8px 12px;
  background: linear-gradient(90deg, transparent, rgba(240,193,75,0.1), transparent);
}

.gold-label {
  font-size: 11px;
  color: var(--accent-gold);
  font-weight: 600;
}

.gold-tiles {
  display: flex;
  gap: 6px;
}

.gold-tile {
  background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffc107 100%);
  color: var(--bg-primary);
  padding: 4px 10px;
  border-radius: 6px;
  font-weight: 800;
  font-size: 14px;
  box-shadow: 0 2px 8px rgba(255,215,0,0.4), inset 0 1px 0 rgba(255,255,255,0.5);
  text-shadow: 0 1px 0 rgba(255,255,255,0.3);
}

/* ===== å°æ‰‹å€åŸŸ ===== */
.opponents-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 6px 8px;
  overflow-y: auto;
  min-height: 0;
  max-height: calc(100vh - 500px);
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
}

.opponent-card {
  background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-secondary) 100%);
  border: 1px solid var(--border-subtle);
  border-radius: 10px;
  padding: 8px 10px;
  transition: all 0.3s ease;
  flex-shrink: 0;
}

.opponent-card.active-turn {
  border-color: var(--accent-gold);
  box-shadow: 0 0 20px var(--glow-gold), inset 0 0 30px rgba(240,193,75,0.05);
}

.opponent-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
}

.opponent-name {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  font-size: 14px;
}

.wind-icon {
  width: 26px;
  height: 26px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, var(--accent-jade) 0%, #14b8a6 100%);
  color: var(--bg-primary);
  border-radius: 6px;
  font-weight: 800;
  font-size: 13px;
  box-shadow: 0 2px 8px var(--glow-jade);
}

.dealer-mark {
  background: linear-gradient(135deg, var(--accent-gold) 0%, #d4a03a 100%);
  color: var(--bg-primary);
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 10px;
  font-weight: 700;
}

.listen-mark {
  background: linear-gradient(135deg, var(--accent-red) 0%, #dc2626 100%);
  color: white;
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 10px;
  font-weight: 700;
  animation: pulse-listen 2s infinite;
}

@keyframes pulse-listen {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.opponent-score {
  font-weight: 700;
  font-size: 15px;
  color: var(--accent-jade);
}

.opponent-content {
  display: flex;
  gap: 6px;
  align-items: flex-start;
}

.discard-zone {
  flex: 1;
  min-height: 32px;
  max-height: 60px;
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
  padding: 4px;
  display: flex;
  flex-wrap: wrap;
  gap: 2px;
  align-content: flex-start;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.discard-zone-label {
  font-size: 9px;
  color: var(--text-secondary);
  margin-bottom: 4px;
  display: block;
  width: 100%;
}

.meld-zone {
  display: flex;
  flex-direction: column;
  gap: 3px;
  min-width: 70px;
  flex-shrink: 0;
}

.meld-group {
  display: flex;
  gap: 2px;
  padding: 4px;
  background: rgba(45,212,191,0.1);
  border-radius: 6px;
}

/* ===== ç‰Œé¢æ¨£å¼ ===== */
.tile {
  background: linear-gradient(180deg, #ffffff 0%, #f1f5f9 100%);
  border: 1.5px solid #cbd5e1;
  border-radius: 5px;
  font-weight: 700;
  text-align: center;
  box-shadow: 0 2px 4px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.8);
  user-select: none;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.tile-xs {
  min-width: 22px;
  height: 28px;
  font-size: 11px;
  padding: 2px;
}

.tile-sm {
  min-width: 28px;
  height: 36px;
  font-size: 13px;
  padding: 3px;
}

.tile-md {
  min-width: 36px;
  width: 36px;
  height: 48px;
  font-size: 16px;
  padding: 4px;
  cursor: pointer;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  flex-shrink: 0;
}

.tile-md:hover {
  transform: translateY(-4px);
  box-shadow: 0 8px 16px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.8);
}

.tile-md:active {
  transform: translateY(-2px) scale(0.98);
}

/* è§¸æ§è¨­å‚™å„ªåŒ– */
@media (hover: none) {
  .tile-md:hover {
    transform: none;
  }
}

/* èŠ±è‰²é¡è‰² */
.tile.suit-W { color: var(--tile-wan); }
.tile.suit-T { color: var(--tile-tong); }
.tile.suit-B { color: var(--tile-tiao); }
.tile.suit-F, .tile.suit-D { color: var(--tile-zi); }

/* é‡‘ç‰Œ */
.tile.gold {
  background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffc107 100%);
  border-color: #d4a03a;
  box-shadow: 0 2px 12px rgba(255,215,0,0.5), inset 0 1px 0 rgba(255,255,255,0.6);
}

/* æ‘¸åˆ°çš„ç‰Œ */
.tile.drawn {
  border: 3px solid var(--accent-gold);
  background: linear-gradient(180deg, #fff9e6 0%, #ffffff 100%);
  box-shadow: 0 2px 8px rgba(240,193,75,0.5);
}

/* ===== æˆ°æ³é¢æ¿ ===== */
.log-panel {
  background: rgba(0,0,0,0.4);
  border-top: 1px solid var(--border-subtle);
  padding: 0;
  height: 90px;
  flex-shrink: 0;
  display: flex;
  flex-direction: column;
  position: relative;
}

.log-header {
  padding: 4px 12px;
  font-size: 10px;
  color: var(--text-secondary);
  font-weight: 600;
  border-bottom: 1px solid var(--border-subtle);
  flex-shrink: 0;
  background: rgba(0,0,0,0.2);
}

#log {
  font-size: 11px;
  line-height: 1.6;
  color: var(--text-secondary);
  padding: 8px 12px;
  overflow-y: auto;
  overflow-x: hidden;
  flex: 1;
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
  display: flex;
  flex-direction: column;
}

#log::-webkit-scrollbar {
  width: 4px;
}

#log::-webkit-scrollbar-track {
  background: transparent;
}

#log::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.2);
  border-radius: 2px;
}

#log .my-log {
  color: var(--accent-jade);
}

/* ===== æˆ‘çš„æ‰‹ç‰Œå€ ===== */
.my-hand-area {
  background: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg-card) 100%);
  border-top: 2px solid var(--accent-jade);
  padding: 10px 8px calc(14px + var(--safe-bottom));
  box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
  position: relative;
  z-index: 10;
  flex-shrink: 0;
}

.hand-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  padding: 0 4px;
}

.hand-title {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 700;
  font-size: 14px;
}

.hand-title .wind-icon {
  background: linear-gradient(135deg, var(--accent-gold) 0%, #d4a03a 100%);
}

.my-score {
  font-size: 18px;
  font-weight: 800;
  color: var(--accent-jade);
}

.listen-hint {
  text-align: center;
  font-size: 12px;
  color: var(--accent-gold);
  margin-bottom: 8px;
  font-weight: 600;
}

.hand-tiles {
  display: flex;
  justify-content: flex-start;
  gap: 3px;
  flex-wrap: nowrap;
  margin-bottom: 8px;
  padding: 4px 0;
  min-height: 56px;
  align-items: center;
  overflow-x: auto;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,0.2) transparent;
}

.hand-tiles::-webkit-scrollbar {
  height: 4px;
}

.hand-tiles::-webkit-scrollbar-track {
  background: transparent;
}

.hand-tiles::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.2);
  border-radius: 2px;
}

.my-melds {
  display: flex;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
  margin-bottom: 8px;
}

.meld-badge {
  display: flex;
  align-items: center;
  gap: 4px;
  background: rgba(45,212,191,0.15);
  border: 1px solid rgba(45,212,191,0.3);
  border-radius: 8px;
  padding: 6px 8px;
}

.meld-label {
  font-size: 10px;
  color: var(--accent-jade);
  font-weight: 600;
}

/* ===== æ§åˆ¶æŒ‰éˆ• ===== */
.controls-bar {
  display: flex;
  gap: 6px;
  padding: 8px;
  flex-wrap: wrap;
  justify-content: center;
  -webkit-overflow-scrolling: touch;
}

.btn {
  flex: 1;
  min-width: 60px;
  max-width: 100px;
  padding: 12px 8px;
  border: none;
  border-radius: 12px;
  font-size: 13px;
  font-weight: 700;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  touch-action: manipulation;
  -webkit-tap-highlight-color: rgba(255,255,255,0.1);
  user-select: none;
}

.btn:disabled {
  opacity: 0.35;
  cursor: not-allowed;
  transform: none !important;
}

.btn-primary {
  background: linear-gradient(135deg, var(--accent-jade) 0%, #14b8a6 100%);
  color: var(--bg-primary);
  box-shadow: 0 4px 12px var(--glow-jade);
}

.btn-primary:not(:disabled):active {
  transform: scale(0.95);
}

.btn-secondary {
  background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-secondary) 100%);
  color: var(--text-primary);
  border: 1px solid var(--border-subtle);
}

.btn-secondary:not(:disabled):active {
  transform: scale(0.95);
  background: var(--bg-secondary);
}

.btn-gold {
  background: linear-gradient(135deg, var(--accent-gold) 0%, #d4a03a 100%);
  color: var(--bg-primary);
  box-shadow: 0 4px 12px var(--glow-gold);
}

.btn-gold:not(:disabled):active {
  transform: scale(0.95);
}

.btn-danger {
  background: linear-gradient(135deg, var(--accent-red) 0%, #dc2626 100%);
  color: white;
  box-shadow: 0 4px 12px rgba(239,68,68,0.3);
}

.btn.active {
  animation: btn-glow 1s ease-in-out infinite;
  transform: scale(1.05);
}

@keyframes btn-glow {
  0%, 100% { box-shadow: 0 0 20px var(--glow-gold); }
  50% { box-shadow: 0 0 30px var(--glow-gold), 0 0 40px var(--glow-gold); }
}

.btn-icon {
  font-size: 18px;
}

.btn-text {
  font-size: 11px;
}

/* ===== å½ˆçª— ===== */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
  z-index: 200;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 20px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.modal-overlay.show {
  display: flex;
}

.modal-content {
  background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-secondary) 100%);
  border: 1px solid var(--border-subtle);
  border-radius: 20px;
  padding: 24px;
  max-width: 90%;
  max-height: 85vh;
  overflow-y: auto;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
  margin: auto;
}

.modal-title {
  font-size: 20px;
  font-weight: 800;
  color: var(--accent-gold);
  margin-bottom: 16px;
  text-align: center;
}

.modal-section {
  margin-bottom: 16px;
}

.modal-section-title {
  font-size: 14px;
  font-weight: 700;
  color: var(--accent-jade);
  margin-bottom: 8px;
}

.modal-player {
  background: rgba(0,0,0,0.2);
  border-radius: 12px;
  padding: 12px;
  margin-bottom: 12px;
}

.modal-player.winner {
  border: 2px solid var(--accent-gold);
  box-shadow: 0 0 20px var(--glow-gold);
}

.modal-player-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.modal-player-name {
  font-weight: 700;
  font-size: 15px;
}

.modal-player-score {
  color: var(--accent-jade);
  font-weight: 700;
}

.modal-hand {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin-top: 8px;
}

.modal-btn {
  width: 100%;
  padding: 16px;
  margin-top: 16px;
  background: linear-gradient(135deg, var(--accent-jade) 0%, #14b8a6 100%);
  color: var(--bg-primary);
  border: none;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 700;
  font-family: inherit;
  cursor: pointer;
  box-shadow: 0 4px 16px var(--glow-jade);
}

.modal-btn:active {
  transform: scale(0.98);
}

/* ===== é«˜ç´šç‰¹æ•ˆ ===== */
.effect-overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 300;
  perspective: 1000px;
}

.effect-text {
  font-size: 48px;
  font-weight: 900;
  text-shadow: 
    0 0 20px currentColor,
    0 0 40px currentColor,
    0 0 60px currentColor,
    0 0 80px currentColor;
  animation: effect-pop-advanced 1.2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
  filter: drop-shadow(0 0 20px currentColor);
  transform-style: preserve-3d;
}

@keyframes effect-pop-advanced {
  0% { 
    transform: scale(0.2) rotateY(-180deg) rotateX(20deg) translateZ(-150px);
    opacity: 0;
    filter: blur(15px) brightness(2);
  }
  25% {
    transform: scale(1.4) rotateY(10deg) rotateX(-5deg) translateZ(30px);
    opacity: 1;
    filter: blur(2px) brightness(1.5);
  }
  40% {
    transform: scale(1.15) rotateY(-5deg) rotateX(2deg) translateZ(15px);
    opacity: 1;
    filter: blur(0px) brightness(1.2);
  }
  60% {
    transform: scale(1.05) rotateY(2deg) rotateX(0deg) translateZ(0);
    opacity: 1;
    filter: blur(0px) brightness(1);
  }
  80% {
    transform: scale(0.95) rotateY(0deg) rotateX(0deg) translateZ(-20px);
    opacity: 0.8;
    filter: blur(2px) brightness(0.9);
  }
  100% { 
    transform: scale(0.7) rotateY(0deg) rotateX(10deg) translateZ(-80px);
    opacity: 0;
    filter: blur(8px) brightness(0.7);
  }
}

/* ç²’å­æ•ˆæœ */
.effect-particles {
  position: absolute;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.particle {
  position: absolute;
  width: 6px;
  height: 6px;
  background: currentColor;
  border-radius: 50%;
  animation: particle-float 1.5s ease-out forwards;
  box-shadow: 
    0 0 8px currentColor,
    0 0 16px currentColor,
    0 0 24px currentColor;
  transform: translate(-50%, -50%);
}

@keyframes particle-float {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(var(--tx, 0), var(--ty, -100px)) scale(0);
    opacity: 0;
  }
}

/* å…‰æšˆæ•ˆæœ */
.effect-glow {
  position: absolute;
  width: 200px;
  height: 200px;
  border-radius: 50%;
  background: radial-gradient(circle, currentColor 0%, transparent 70%);
  opacity: 0.6;
  animation: glow-pulse 1.2s ease-out forwards;
  filter: blur(20px);
}

@keyframes glow-pulse {
  0% {
    transform: scale(0.3) rotate(0deg);
    opacity: 0;
    filter: blur(15px);
  }
  30% {
    transform: scale(1.2) rotate(180deg);
    opacity: 0.9;
    filter: blur(10px);
  }
  60% {
    transform: scale(1.8) rotate(360deg);
    opacity: 0.6;
    filter: blur(15px);
  }
  100% {
    transform: scale(2.5) rotate(540deg);
    opacity: 0;
    filter: blur(25px);
  }
}

/* ===== éŸ¿æ‡‰å¼èª¿æ•´ ===== */
@media (max-width: 380px) {
  .status-bar {
    padding: 8px 12px;
    flex-wrap: wrap;
    gap: 6px;
  }
  
  .round-badge {
    font-size: 11px;
    padding: 5px 10px;
  }
  
  .remain-badge {
    font-size: 11px;
    padding: 5px 10px;
  }
  
  .remain-badge strong {
    font-size: 14px;
  }
  
  .tile-md {
    min-width: 30px;
    height: 42px;
    font-size: 13px;
    padding: 3px;
  }
  
  .tile-sm {
    min-width: 24px;
    height: 32px;
    font-size: 11px;
    padding: 2px;
  }
  
  .tile-xs {
    min-width: 18px;
    height: 24px;
    font-size: 9px;
    padding: 1px 3px;
  }
  
  .btn {
    min-width: 55px;
    padding: 12px 6px;
    font-size: 12px;
  }
  
  .btn-icon { font-size: 16px; }
  .btn-text { font-size: 9px; }
  
  .opponent-card {
    padding: 8px 10px;
  }
  
  .opponent-name {
    font-size: 12px;
  }
  
  .opponent-score {
    font-size: 13px;
  }
  
  .my-score {
    font-size: 16px;
  }
  
  .hand-title {
    font-size: 12px;
  }
  
  .modal-content {
    padding: 16px;
    max-width: 95%;
  }
  
  .modal-title {
    font-size: 18px;
  }
  
  .gold-display {
    padding: 6px 10px;
  }
  
  .gold-tile {
    padding: 3px 8px;
    font-size: 12px;
  }
}

@media (max-width: 480px) {
  .controls-bar {
    gap: 4px;
    padding: 6px;
  }
  
  .btn {
    min-width: 60px;
    padding: 14px 8px;
    font-size: 12px;
  }
  
  .hand-tiles {
    gap: 3px;
  }
  
  .opponents-area {
    padding: 6px 10px;
    gap: 4px;
  }
  
  .discard-zone {
    min-height: 32px;
    padding: 4px;
    gap: 2px;
  }
  
  .log-panel {
    height: 75px;
  }
  
  .log-header {
    padding: 3px 10px;
    font-size: 9px;
  }
  
  #log {
    font-size: 10px;
    padding: 6px 10px;
  }
  
  .opponents-area {
    max-height: calc(100vh - 480px);
  }
}

@media (min-width: 500px) {
  .opponents-area {
    flex-direction: row;
    flex-wrap: wrap;
  }
  
  .opponent-card {
    flex: 1 1 calc(50% - 4px);
    min-width: 200px;
  }
}

@media (min-width: 768px) {
  .opponent-card {
    flex: 1 1 calc(33.333% - 6px);
    min-width: 220px;
  }
  
  .tile-md {
    min-width: 40px;
    height: 52px;
    font-size: 17px;
  }
  
  .btn {
    min-width: 80px;
    padding: 14px 12px;
  }
}

/* è§¸æ§å„ªåŒ– */
@media (hover: none) and (pointer: coarse) {
  .tile-md {
    min-width: 36px;
    height: 48px;
    cursor: default;
  }
  
  .tile-md:active {
    transform: translateY(-2px) scale(0.97);
  }
  
  .btn {
    min-width: 64px;
    padding: 14px 10px;
    touch-action: manipulation;
  }
  
  .btn:active {
    transform: scale(0.95);
  }
  
  /* ç§»é™¤ hover æ•ˆæœï¼Œæ”¹ç”¨ active */
  .tile-md:hover {
    transform: none;
    box-shadow: 0 2px 4px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.8);
  }
}

/* æ©«å±æ¨¡å¼å„ªåŒ– */
@media (orientation: landscape) and (max-height: 600px) {
  .status-bar {
    padding: 6px 12px;
    padding-top: calc(6px + var(--safe-top));
  }
  
  .opponents-area {
    max-height: 120px;
    padding: 4px 8px;
  }
  
  .opponent-card {
    padding: 6px 8px;
  }
  
  .log-panel {
    height: 65px;
  }
  
  .log-header {
    padding: 2px 8px;
    font-size: 8px;
  }
  
  #log {
    padding: 4px 8px;
    font-size: 9px;
  }
  
  .opponents-area {
    max-height: calc(100vh - 420px);
  }
  
  .my-hand-area {
    padding: 8px 6px calc(12px + var(--safe-bottom));
  }
  
  .hand-tiles {
    margin-bottom: 6px;
    min-height: 50px;
    flex-wrap: nowrap;
    overflow-x: auto;
    justify-content: flex-start;
  }
  
  .controls-bar {
    padding: 4px;
    gap: 4px;
  }
  
  .btn {
    padding: 10px 6px;
    font-size: 11px;
  }
  
  .btn-icon {
    font-size: 16px;
  }
  
  .btn-text {
    font-size: 9px;
  }
  
  .tile-md {
    min-width: 32px;
    height: 44px;
    font-size: 14px;
  }
}

/* å°ç‰Œåœ–ç¤ºï¼ˆç”¨æ–¼æˆ°æ³è¨˜éŒ„ï¼‰ */
.tile.log-tile {
  display: inline-flex;
  min-width: 20px;
  height: 24px;
  font-size: 10px;
  padding: 2px 4px;
  margin: 0 2px;
  vertical-align: middle;
}

/* éš±è—å…ƒç´  */
.hidden { display: none !important; }
</style>
</head>
<body>

<!-- é ‚éƒ¨ç‹€æ…‹åˆ— -->
<div class="status-bar">
  <div class="round-badge">
    <span id="centerRound">æ±é¢¨æ±</span>
  </div>
  <div class="remain-badge">
    ğŸ´ å‰©é¤˜ <strong id="centerRemain">56</strong> å¼µ
  </div>
  <button class="btn btn-gold" id="newGameBtn" style="padding: 8px 12px; min-width: auto; flex: none; font-size: 12px;">
    <span style="font-size: 12px;">ğŸ® æ–°å±€</span>
  </button>
</div>

<!-- é‡‘ç‰Œå±•ç¤º -->
<div class="gold-display" id="goldDisplay">
  <span class="gold-label">âœ¨ é‡‘ç‰Œ</span>
  <div class="gold-tiles" id="goldTiles"></div>
</div>

<!-- å°æ‰‹å€åŸŸ -->
<div class="opponents-area" id="opponentsArea">
  <!-- å‹•æ…‹ç”Ÿæˆ -->
</div>

<!-- æˆ°æ³è¨˜éŒ„ -->
<div class="log-panel">
  <div class="log-header">ğŸ“‹ æˆ°æ³è¨˜éŒ„</div>
  <div id="log"></div>
</div>

<!-- æˆ‘çš„æ‰‹ç‰Œå€ -->
<div class="my-hand-area">
  <div class="hand-header">
    <div class="hand-title">
      <div class="wind-icon" id="myWind">æ±</div>
      <span id="myName">ä½ </span>
      <span id="myDealerMark" class="dealer-mark hidden">èŠ</span>
      <span id="myListenMark" class="listen-mark hidden">è½</span>
    </div>
    <div class="my-score" id="myScore">100,000</div>
  </div>
  <div class="listen-hint hidden" id="listenHint"></div>
  <div class="hand-tiles" id="yourHand"></div>
  <div class="my-melds" id="yourMelds"></div>
  <div class="controls-bar" id="controls">
    <button class="btn btn-danger" id="btnHu" disabled>
      <span class="btn-icon">ğŸ‰</span>
      <span class="btn-text">èƒ¡ç‰Œ</span>
    </button>
    <button class="btn btn-secondary" id="btnChow" disabled>
      <span class="btn-icon">ğŸœ</span>
      <span class="btn-text">åƒ</span>
    </button>
    <button class="btn btn-secondary" id="btnPong" disabled>
      <span class="btn-icon">ğŸ”¥</span>
      <span class="btn-text">ç¢°</span>
    </button>
    <button class="btn btn-secondary" id="btnKong" disabled>
      <span class="btn-icon">ğŸ’¥</span>
      <span class="btn-text">æ§“</span>
    </button>
    <button class="btn btn-primary" id="btnListen" disabled>
      <span class="btn-icon">ğŸ””</span>
      <span class="btn-text">è½ç‰Œ</span>
    </button>
    <button class="btn btn-secondary" id="btnPass" disabled>
      <span class="btn-icon">â­ï¸</span>
      <span class="btn-text">é</span>
    </button>
  </div>
</div>

<!-- å½ˆçª— -->
<div class="modal-overlay" id="modalOverlay">
  <div class="modal-content" id="modalContent"></div>
</div>

<!-- éš±è—å…ƒç´  -->
<div id="scoreboard" style="display: none;"></div>
<div id="goldbar" style="display: none;"></div>
<div id="roundinfo" style="display: none;"></div>
<div id="table" style="display: none;"></div>
<input type="checkbox" id="goldSwitch" checked style="display: none;">
<div id="reactionPanel" style="display: none;"></div>
<div id="overlay" style="display: none;"></div>

<script>
/* ========= åŸºæœ¬å·¥å…· ========= */
const rng = (n) => Math.floor(Math.random() * n);
const clone = (o) => JSON.parse(JSON.stringify(o));

// é«˜ç´šéŸ³æ•ˆç³»çµ±
let audioCtx = null;
let soundEnabled = true;
let audioInitialized = false;

function initAudio() {
  if (!audioInitialized) {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
      audioInitialized = true;
    } catch (e) {
      soundEnabled = false;
    }
  }
}

// é«˜ç´šéŸ³æ•ˆï¼šå’Œå¼¦éŸ³æ•ˆ
function playChord(frequencies, duration, type = 'sine', volume = 0.15) {
  if (!soundEnabled) return;
  if (!audioInitialized) initAudio();
  if (!audioCtx) return;
  try {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const masterGain = audioCtx.createGain();
    masterGain.connect(audioCtx.destination);
    masterGain.gain.setValueAtTime(volume, audioCtx.currentTime);
    masterGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    
    frequencies.forEach((freq, idx) => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(masterGain);
      osc.frequency.value = freq;
      osc.type = type;
      const delay = idx * 0.02;
      gain.gain.setValueAtTime(0, audioCtx.currentTime + delay);
      gain.gain.linearRampToValueAtTime(volume / frequencies.length, audioCtx.currentTime + delay + 0.05);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + delay + duration);
      osc.start(audioCtx.currentTime + delay);
      osc.stop(audioCtx.currentTime + delay + duration);
    });
  } catch (e) {}
}

// é«˜ç´šéŸ³æ•ˆï¼šå¸¶åŒ…çµ¡çš„éŸ³æ•ˆ
function playSound(freq, duration, type = 'sine', volume = 0.2, attack = 0.05, decay = 0.1) {
  if (!soundEnabled) return;
  if (!audioInitialized) initAudio();
  if (!audioCtx) return;
  try {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);
    
    osc.frequency.value = freq;
    osc.type = type;
    
    // é«˜ç´šåŒ…çµ¡ï¼šAttack -> Decay -> Sustain -> Release
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(volume, now + attack);
    gain.gain.linearRampToValueAtTime(volume * 0.7, now + attack + decay);
    gain.gain.linearRampToValueAtTime(volume * 0.7, now + duration - 0.1);
    gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
    
    // æ·»åŠ ä½é€šæ¿¾æ³¢å™¨è®“éŸ³æ•ˆæ›´æŸ”å’Œ
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(2000, now);
    filter.Q.setValueAtTime(1, now);
    
    osc.start(now);
    osc.stop(now + duration);
  } catch (e) {}
}

// éŸ³æ•ˆåº«
const SoundEffects = {
  discard: () => playSound(400, 0.15, 'square', 0.15, 0.02, 0.05),
  draw: () => playSound(600, 0.2, 'sine', 0.18, 0.05, 0.08),
  chow: () => playChord([523, 659, 784], 0.3, 'triangle', 0.2), // C-E-Gå’Œå¼¦
  pong: () => playChord([440, 554, 659], 0.35, 'square', 0.22), // A-C#-Eå’Œå¼¦
  kong: () => playChord([330, 440, 554, 659], 0.4, 'sawtooth', 0.25), // å››éŸ³å’Œå¼¦
  win: () => {
    // å‹åˆ©éŸ³æ•ˆï¼šä¸Šå‡éŸ³éš
    const notes = [523, 659, 784, 1047]; // C-E-G-C
    notes.forEach((freq, i) => {
      setTimeout(() => playSound(freq, 0.4, 'sine', 0.25, 0.05, 0.1), i * 150);
    });
  },
  listen: () => playChord([440, 554], 0.25, 'sine', 0.18),
  error: () => playSound(200, 0.2, 'sawtooth', 0.15, 0.01, 0.05)
};

function showEffect(text, color, size = '48px') {
  const overlay = document.createElement('div');
  overlay.className = 'effect-overlay';
  
  // ä¸»æ–‡å­—æ•ˆæœ
  const effect = document.createElement('div');
  effect.className = 'effect-text';
  effect.textContent = text;
  effect.style.color = color;
  effect.style.fontSize = size;
  overlay.appendChild(effect);
  
  // å…‰æšˆæ•ˆæœ
  const glow = document.createElement('div');
  glow.className = 'effect-glow';
  glow.style.color = color;
  glow.style.left = '50%';
  glow.style.top = '50%';
  glow.style.transform = 'translate(-50%, -50%)';
  overlay.appendChild(glow);
  
  // é«˜ç´šç²’å­æ•ˆæœ
  const particles = document.createElement('div');
  particles.className = 'effect-particles';
  const particleCount = 30;
  for (let i = 0; i < particleCount; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.color = color;
    const angle = (Math.PI * 2 * i) / particleCount;
    const distance = 60 + Math.random() * 80;
    const size = 4 + Math.random() * 4;
    particle.style.width = `${size}px`;
    particle.style.height = `${size}px`;
    particle.style.left = '50%';
    particle.style.top = '50%';
    particle.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
    particle.style.setProperty('--ty', `${Math.sin(angle) * distance - 30}px`);
    particle.style.animationDelay = `${i * 0.02}s`;
    particle.style.animationDuration = `${1.2 + Math.random() * 0.6}s`;
    particles.appendChild(particle);
  }
  overlay.appendChild(particles);
  
  document.body.appendChild(overlay);
  setTimeout(() => overlay.remove(), 1500);
}

function log(msg) {
  const el = document.getElementById('log');
  const line = document.createElement('div');
  const formatted = formatLogString(msg);
  line.innerHTML = formatted;
  line.style.marginBottom = '4px';
  line.style.flexShrink = '0';
  if (/ä½ /.test(msg)) line.classList.add('my-log');
  el.appendChild(line);
  
  // ç¢ºä¿æ»¾å‹•åˆ°åº•éƒ¨ï¼ˆé¡¯ç¤ºæœ€æ–°å…§å®¹ï¼‰
  requestAnimationFrame(() => {
    el.scrollTop = el.scrollHeight;
  });
}

function formatLogString(text) {
  const cnNumMap = { 'ä¸€': 1, 'äºŒ': 2, 'ä¸‰': 3, 'å››': 4, 'äº”': 5, 'å…­': 6, 'ä¸ƒ': 7, 'å…«': 8, 'ä¹': 9 };
  return text.replace(/([1-9]|[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹])([è¬ç­’æ¢ç´¢])|([æ±å—è¥¿åŒ—ä¸­ç™¼ç™½])/g, (m, p1, p2, p3) => {
    if (p1 && p2) {
      const suitChar = p2;
      let suitKey;
      if (suitChar === 'è¬') suitKey = 'W';
      else if (suitChar === 'ç­’') suitKey = 'T';
      else if (suitChar === 'æ¢' || suitChar === 'ç´¢') suitKey = 'B';
      else suitKey = '?';
      return `<span class="tile log-tile suit-${suitKey}">${m}</span>`;
    }
    if (p3) {
      let suitKey;
      if ('æ±å—è¥¿åŒ—'.includes(p3)) suitKey = 'F';
      else if ('ä¸­ç™¼ç™½'.includes(p3)) suitKey = 'D';
      else suitKey = '?';
      return `<span class="tile log-tile suit-${suitKey}">${p3}</span>`;
    }
    return m;
  });
}

/* ========= ç‰Œå‹å®šç¾© ========= */
const SUIT_W = 'W', SUIT_T = 'T', SUIT_B = 'B', SUIT_F = 'F', SUIT_D = 'D';
const WINDS = ['E', 'S', 'W', 'N'];
const DRAGONS = ['C', 'F', 'B'];

function tileKey(t) {
  if (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) return t.suit + String(t.rank);
  if (t.suit === SUIT_F || t.suit === SUIT_D) return t.suit + t.name;
  return '?';
}

function keyToText(k) {
  const s = k[0], v = k.slice(1);
  if (s === SUIT_W) return v + 'è¬';
  if (s === SUIT_T) return v + 'ç­’';
  if (s === SUIT_B) return v + 'æ¢';
  if (s === SUIT_F) {
    const m = { E: 'æ±', S: 'å—', W: 'è¥¿', N: 'åŒ—' };
    return m[v] || k;
  }
  if (s === SUIT_D) {
    const m = { C: 'ä¸­', F: 'ç™¼', B: 'ç™½' };
    return m[v] || k;
  }
  return k;
}

function generateTiles() {
  const tiles = [];
  const push4 = (suit, rank) => {
    for (let i = 0; i < 4; i++) tiles.push({ suit, rank, id: tiles.length });
  };
  for (let r = 1; r <= 9; r++) {
    push4(SUIT_W, r);
    push4(SUIT_T, r);
    push4(SUIT_B, r);
  }
  WINDS.forEach(n => {
    for (let i = 0; i < 4; i++) tiles.push({ suit: SUIT_F, name: n, id: tiles.length });
  });
  DRAGONS.forEach(n => {
    for (let i = 0; i < 4; i++) tiles.push({ suit: SUIT_D, name: n, id: tiles.length });
  });
  return tiles;
}

function shuffle(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = rng(i + 1);
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* ========= éŠæˆ²è¦å‰‡èˆ‡ç‹€æ…‹ ========= */
const RULES = {
  handSize: 16,
  gold: { enabled: true, initial: 3, maxExtra: 2, totalMax: 5, perGold: 1, winOnGold: 3 },
  scoring: {
    // åŸºæœ¬å°å‹
    SelfDraw: 1,              // è‡ªæ‘¸
    MenqingSelfDraw: 3,       // é–€æ¸…è‡ªæ‘¸
    DeclaredListen: 1,        // å ±è½
    EarthReady: 4,            // åœ°è½
    HeavenReady: 8,           // å¤©è½
    
    // ç‰¹æ®Šç‰Œå‹
    AllPungs: 2,              // å°å°èƒ¡
    HalfFlush: 3,             // æ··ä¸€è‰²
    PureOneSuit: 5,           // æ¸…ä¸€è‰²
    AllChows: 1,              // å…¨æ±‚äººï¼ˆå…¨éƒ¨åƒç¢°ï¼‰
    ThreeConcealedPungs: 2,    // ä¸‰æš—åˆ»
    FourConcealedPungs: 5,    // å››æš—åˆ»
    FiveConcealedPungs: 8,    // äº”æš—åˆ»
    
    // ä¸‰å…ƒç‰Œ
    BigThreeDragons: 8,       // å¤§ä¸‰å…ƒ
    LittleThreeDragons: 4,    // å°ä¸‰å…ƒ
    
    // å››å–œç‰Œ
    BigFourWinds: 8,          // å¤§å››å–œ
    LittleFourWinds: 4,       // å°å››å–œ
    
    // å­—ç‰Œçµ„åˆ
    AllHonors: 8,             // å­—ä¸€è‰²
    AllTerminals: 8,          // æ¸…è€é ­
    AllTerminalsAndHonors: 4, // æ··è€é ­
    
    // ç‰¹æ®Šç‰Œå‹
    NineGates: 8,             // ä¹è“®å¯¶ç‡ˆ
    FourKongs: 8,             // å››æ§“å­
    ThreeKongs: 2,            // ä¸‰æ§“å­
    
    // ç‰¹æ®Šæƒ…æ³
    RobKong: 1,               // æ¶æ§“
    Rinshan: 1,               // æ§“ä¸Šé–‹èŠ±
    Haitei: 1,                // æµ·åº•æ’ˆæœˆï¼ˆè‡ªæ‘¸æœ€å¾Œä¸€å¼µï¼‰
    Houtei: 1,                // æ²³åº•æ’ˆé­šï¼ˆèƒ¡æœ€å¾Œä¸€å¼µï¼‰
    
    // é¢¨ç‰Œï¼ˆåº§é¢¨/åœˆé¢¨ï¼‰
    SeatWind: 1,              // åº§é¢¨
    RoundWind: 1,             // åœˆé¢¨
    
    // èŠ±ç‰Œï¼ˆå¦‚æœæœ‰ï¼‰
    Flower: 1,
  },
  points: { base: 2000, perFan: 1000 },
  initialPoints: 100000
};

let S = null;
let seatNames = ['æ±','å—','è¥¿','åŒ—'];

function getNextTurn(currentTurn) {
  // é †æ™‚é‡é †åºï¼š0(æ±) -> 1(å—) -> 2(è¥¿) -> 3(åŒ—) -> 0
  const clockwiseOrder = [0, 1, 2, 3];
  const currentIndex = clockwiseOrder.indexOf(currentTurn);
  return clockwiseOrder[(currentIndex + 1) % 4];
}

const NAME_POOL = [
  'å°æ˜','å°è¯','å°ç¾','é˜¿ç','å¿—å¼·','å¿—ç²','å»ºåœ‹','ç‰æ¢…','é˜¿èŠ¬','åœ‹è¯','ç¾æƒ ','æ”¿å®','æ·‘èŠ¬','å¿—è±ª','ç§‹é¦™','ä½©ç²','æ¬£æ€¡','å®¶è±ª','æ˜æ…§','å»ºè±'
];

let randomNames = null;
let dealerStreak = 0;

function startNewHand(isFirstGame = false) {
  const useGold = document.getElementById('goldSwitch').checked;
  
  let newDealer = S?.dealer ?? 0;
  let newRound = S?.round ?? 1;
  const prevNames = S?.names || null;
  
  if (isFirstGame || !S) {
    const dice1 = Math.floor(Math.random() * 6) + 1;
    const dice2 = Math.floor(Math.random() * 6) + 1;
    const diceSum = dice1 + dice2;
    newDealer = (diceSum - 1) % 4;
    newRound = 1;
    // é †æ™‚é‡é †åºï¼š0(æ±) -> 1(å—) -> 2(è¥¿) -> 3(åŒ—) -> 0
    const clockwiseOrder = [0, 1, 2, 3];
    seatNames = [];
    for (let offset = 0; offset < 4; offset++) {
      const dealerIndex = clockwiseOrder.indexOf(newDealer);
      const playerPos = clockwiseOrder[(dealerIndex + offset) % 4];
      seatNames[playerPos] = ['æ±', 'å—', 'è¥¿', 'åŒ—'][offset];
    }
    const dealerWindInit = seatNames[newDealer];
    const dealerNameInit = dealerWindInit + 'å®¶' + (newDealer === 0 ? '(ä½ )' : '');
    const pool = NAME_POOL.slice();
    const names = [];
    for (let i = 0; i < 4; i++) {
      const rIndex = Math.floor(Math.random() * pool.length);
      names.push(pool.splice(rIndex, 1)[0]);
    }
    randomNames = names;
    log(`ğŸ² æ“²éª°ï¼š${dice1} + ${dice2} = ${diceSum}ï¼ŒèŠå®¶ç‚º${dealerNameInit}`);
  } else if (S.winner === null) {
    log(`ğŸ” æµå±€é€£èŠï¼ŒèŠå®¶ç¹¼çºŒç•¶èŠ`);
  } else if (S.winner === S.dealer) {
    log(`ğŸ† èŠå®¶èƒ¡ç‰Œï¼Œç¹¼çºŒç•¶èŠ`);
  } else {
    // é †æ™‚é‡é †åºï¼š0(æ±) -> 1(å—) -> 2(è¥¿) -> 3(åŒ—) -> 0
    const clockwiseOrder = [0, 1, 2, 3];
    const currentIndex = clockwiseOrder.indexOf(S.dealer);
    newDealer = clockwiseOrder[(currentIndex + 1) % 4];
    if (newDealer === S.initialDealer) {
      newRound++;
      if (newRound > 4) {
        log(`ğŸ å››åœˆå·²æ‰“å®Œï¼ŒéŠæˆ²çµæŸï¼`);
        showFinalScore();
        return;
      }
      log(`ğŸ”„ é€²å…¥ç¬¬${newRound}åœˆ`);
    }
    const rotatedWind = seatNames?.[newDealer] || ['æ±','å—','è¥¿','åŒ—'][newDealer];
    const rotatedName = rotatedWind + 'å®¶' + (newDealer === 0 ? '(ä½ )' : '');
    log(`ğŸ” èŠå®¶è¼ªæ›¿è‡³${rotatedName}`);
  }

  if (isFirstGame || !S) {
    dealerStreak = 0;
  } else {
    if (newDealer === S.dealer) {
      dealerStreak = (dealerStreak || 0) + 1;
    } else {
      dealerStreak = 0;
    }
  }
  
  S = {
    wall: shuffle(generateTiles()),
    deadWall: [],
    players: Array.from({ length: 4 }, (_, i) => ({
      hand: [],
      discards: [],
      flowers: [],
      melds: [],
      points: prevNames ? S.players[i].points : RULES.initialPoints,
      declaredListen: false,
      waitKeys: [],
      tianTing: false,
      diTing: false,
      isAI: i !== 0,
      rinshan: false,
      drawCount: 0
    })),
    goldKeys: [],
    kongCount: 0,
    rules: clone(RULES),
    turn: newDealer,
    dealer: newDealer,
    round: newRound,
    initialDealer: (isFirstGame || !S) ? newDealer : (S.initialDealer ?? newDealer),
    dealerStreak: dealerStreak,
    lastDiscard: null,
    waitReact: null,
    winner: null,
    fromPlayer: null,
    winTile: null,
    phase: 'deal',
    remain: 0,
    drawCount: 0,
    anyOpenMeld: false,
    robKong: false,
    lastAction: null,
    lastActor: null,
    names: prevNames || randomNames
  };
  
  if (!randomNames && prevNames) {
    randomNames = prevNames;
  }
  S.names = randomNames ? randomNames.slice() : (prevNames ? prevNames.slice() : []);
  S.rules.gold.enabled = useGold;

  dealTiles();
  if (S.rules.gold.enabled) initGoldTiles();
  S.phase = 'play';
  S.remain = S.wall.length;
  renderAll();
  
  const dealerWind = seatNames?.[S.dealer] || ['æ±', 'å—', 'è¥¿', 'åŒ—'][S.dealer];
  const dealerName = dealerWind + 'å®¶' + (S.dealer === 0 ? '(ä½ )' : '');
  const roundName = ['æ±', 'å—', 'è¥¿', 'åŒ—'][newRound - 1];
  log(`ğŸ® ç¬¬${newRound}åœˆ ${roundName}é¢¨ï¼ŒèŠå®¶ï¼š${dealerName}${S.rules.gold.enabled ? 'ï¼Œå•Ÿç”¨é‡‘ç‰Œ' : ''}`);
  
  if (S.dealer === 0) {
    log(`ğŸ‘‰ èŠå®¶æŒæœ‰17å¼µç‰Œï¼Œè«‹ç›´æ¥å‡ºç‰Œ`);
  } else {
    log(`â³ AIèŠå®¶é–‹å§‹å‡ºç‰Œ...`);
    setTimeout(stepAI, 1000 + Math.random() * 1000);
  }
}

function dealTiles() {
  const dead = 16;
  while (S.wall.length > dead && S.players[0].hand.length < 16) {
    for (let p = 0; p < 4; p++) {
      if (S.wall.length > dead) {
        S.players[p].hand.push(S.wall.pop());
      }
    }
  }
  if (S.wall.length > dead) {
    S.players[S.dealer].hand.push(S.wall.pop());
  }
  const deadWallSize = Math.min(dead, S.wall.length);
  S.deadWall = S.wall.splice(-deadWallSize, deadWallSize);
}

function initGoldTiles() {
  const candidates = [];
  for (let r = 1; r <= 9; r++) {
    candidates.push('W' + r, 'T' + r, 'B' + r);
  }
  WINDS.forEach(n => candidates.push('F' + n));
  DRAGONS.forEach(n => candidates.push('D' + n));
  while (S.goldKeys.length < 3) {
    const k = candidates[rng(candidates.length)];
    if (!S.goldKeys.includes(k)) S.goldKeys.push(k);
  }
}

function playerName(i) {
  const name = (S && S.names && S.names[i]) ? S.names[i] : (seatNames?.[i] || ['æ±', 'å—', 'è¥¿', 'åŒ—'][i]);
  return name + (i === 0 ? '(ä½ )' : '');
}

function countKongs(pl) {
  return pl.melds.filter(m => m.type === 'kong').length;
}

function updateTianDiTing(pid) {
  const pl = S.players[pid];
  if (S.anyOpenMeld) return;
  // å¤©è½ï¼šèŠå®¶ç¬¬ä¸€æ¬¡æ‘¸ç‰Œå¾Œå°±è½ç‰Œ
  if (pid === S.dealer && pl.drawCount === 1) {
    pl.tianTing = true;
    return;
  }
  // åœ°è½ï¼šéèŠå®¶å‰8æ¬¡æ‘¸ç‰Œå…§ï¼ˆä¸åŒ…æ‹¬èŠå®¶çš„ç¬¬ä¸€æ¬¡ï¼‰
  if (pid !== S.dealer && pl.drawCount <= 8) {
    pl.diTing = true;
  }
}

/* ========= èƒ¡ç‰Œåˆ¤å®š ========= */
function isWinningNow(hand, melds, winTile) {
  const tiles = hand.slice().sort((a, b) => tileSortKey(a) - tileSortKey(b));
  // è¨ˆç®—å¯¦éš›éœ€è¦çš„é †å­/åˆ»å­æ•¸é‡ï¼ˆæ¯å€‹å‰¯éœ²ä½”1å€‹ï¼Œæ¯å€‹æ§“ä½”1å€‹ï¼‰
  // 16å¼µéº»å°‡ï¼š5å€‹é †å­/åˆ»å­ + 1å€‹å°‡ï¼ˆå°å­ï¼‰= 16å¼µæ‰‹ç‰Œ
  const kongCount = melds.filter(m => m.type === 'kong').length;
  const nonKongMelds = melds.filter(m => m.type !== 'kong').length;
  const totalMelds = nonKongMelds + kongCount;
  const neededSets = Math.max(0, 5 - totalMelds);
  
  return canStandardWin(tiles, neededSets);
}

function isListening(hand, melds) {
  const allPossibleTiles = [];
  for (let suit of [SUIT_W, SUIT_T, SUIT_B]) {
    for (let rank = 1; rank <= 9; rank++) {
      allPossibleTiles.push({ suit, rank, id: -1 });
    }
  }
  WINDS.forEach(name => allPossibleTiles.push({ suit: SUIT_F, name, id: -1 }));
  DRAGONS.forEach(name => allPossibleTiles.push({ suit: SUIT_D, name, id: -1 }));
  
  return allPossibleTiles.some(tile => {
    const testHand = hand.concat([tile]);
    return isWinningNow(testHand, melds, tile);
  });
}

function calcWaitingTiles(hand, melds) {
  const waits = [];
  const allPossibleTiles = [];
  for (let suit of [SUIT_W, SUIT_T, SUIT_B]) {
    for (let rank = 1; rank <= 9; rank++) {
      allPossibleTiles.push({ suit, rank, id: -1 });
    }
  }
  WINDS.forEach(name => allPossibleTiles.push({ suit: SUIT_F, name, id: -1 }));
  DRAGONS.forEach(name => allPossibleTiles.push({ suit: SUIT_D, name, id: -1 }));
  const seen = new Set();
  allPossibleTiles.forEach(tile => {
    const testHand = hand.concat([tile]);
    if (isWinningNow(testHand, melds, tile)) {
      const k = tileKey(tile);
      if (!seen.has(k)) {
        waits.push(k);
        seen.add(k);
      }
    }
  });
  waits.sort((a, b) => {
    const parseKey = (k) => {
      const s = k[0];
      const v = k.slice(1);
      if (s === SUIT_W || s === SUIT_T || s === SUIT_B) {
        return { suit: s, rank: parseInt(v), id: -1 };
      }
      if (s === SUIT_F || s === SUIT_D) {
        return { suit: s, name: v, id: -1 };
      }
      return { suit: s, id: -1 };
    };
    const ta = parseKey(a);
    const tb = parseKey(b);
    return tileSortKey(ta) - tileSortKey(tb);
  });
  return waits;
}


function canStandardWin(tiles, need = 5) {
  const counts = countByKey(tiles);
  for (const k in counts) {
    if (counts[k] >= 2) {
      counts[k] -= 2;
      if (canSplitMelds(counts, need)) return true;
      counts[k] += 2;
    }
  }
  return false;
}

function canSplitMelds(counts, need) {
  if (need === 0) return Object.values(counts).every(v => v === 0);
  let first = null;
  for (const k in counts) {
    if (counts[k] > 0) {
      first = k;
      break;
    }
  }
  if (!first) return need === 0;
  
  if (counts[first] >= 3) {
    counts[first] -= 3;
    if (canSplitMelds(counts, need - 1)) return true;
    counts[first] += 3;
  }
  
  const s = first[0];
  const v = parseInt(first.slice(1));
  if ((s === SUIT_W || s === SUIT_T || s === SUIT_B) && v <= 7) {
    const k2 = s + (v + 1), k3 = s + (v + 2);
    if ((counts[k2] || 0) > 0 && (counts[k3] || 0) > 0) {
      counts[first]--;
      counts[k2]--;
      counts[k3]--;
      if (canSplitMelds(counts, need - 1)) return true;
      counts[first]++;
      counts[k2]++;
      counts[k3]++;
    }
  }
  return false;
}

function countByKey(tiles) {
  const m = {};
  for (const t of tiles) {
    const k = tileKey(t);
    m[k] = (m[k] || 0) + 1;
  }
  return m;
}

function tileSortKey(t) {
  const order = { W: 0, T: 1, B: 2, F: 3, D: 4, H: 5 };
  const o = order[t.suit];
  const v = (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) ? t.rank : ({ E: 1, S: 2, W: 3, N: 4, C: 5, F: 6, B: 7 }[t.name] || 0);
  return o * 100 + v;
}

/* ========= AI é‚è¼¯ ========= */
function shantenAfterRemove(hand) {
  function approxShanten14(tiles) {
    if (isWinningNow(tiles, [], null)) return 0;
    const m = countByKey(tiles);
    let pairs = 0, triples = 0, singles = 0;
    for (const k in m) {
      const c = m[k];
      if (c >= 3) triples++;
      else if (c === 2) pairs++;
      else singles++;
    }
    let est = Math.max(0, 5 - (pairs + triples));
    est += Math.ceil(singles / 4) * 0.5;
    return est;
  }
  
  let best = 99;
  const n = hand.length;
  for (let i = 0; i < n; i++) {
    const take = hand.filter((_, k) => k !== i);
    best = Math.min(best, approxShanten14(take));
  }
  
  const m = countByKey(hand);
  let pairs = 0;
  for (const k in m) {
    pairs += Math.floor(m[k] / 2);
  }
  const sevenNeed = Math.max(0, 8 - pairs);
  return Math.min(best, sevenNeed);
}

function aiChooseDiscard(pid) {
  const me = S.players[pid];
  const visible = [];
  S.players.forEach(p => visible.push(...p.discards, ...p.flowers));
  
  // æ”¶é›†æ‰€æœ‰å°æ‰‹çš„è½ç‰Œç‹€æ…‹å’Œå¯èƒ½çš„ç­‰ç‰Œ
  const listeningPlayers = [];
  const playerWaitKeys = {};
  for (let i = 0; i < 4; i++) {
    if (i !== pid) {
      if (S.players[i].declaredListen) {
        listeningPlayers.push(i);
        playerWaitKeys[i] = S.players[i].waitKeys || [];
      } else {
        // å³ä½¿æ²’å ±è½ï¼Œä¹Ÿæª¢æŸ¥æ˜¯å¦å¯èƒ½è½ç‰Œ
        const pl = S.players[i];
        const waits = calcWaitingTiles(pl.hand, pl.melds);
        if (waits.length > 0) {
          playerWaitKeys[i] = waits;
        }
      }
    }
  }
  
  // è¨ˆç®—ç•¶å‰å‘è½æ•¸
  const currentShanten = shantenAfterRemove(me.hand);
  
  let cands = me.hand.map(t => {
    const after = me.hand.filter(x => x !== t);
    const sh = shantenAfterRemove(after);
    let risk = riskOf(t);
    let waitCount = 0;
    let maxWaitTiles = 0;
    
    // å¢å¼·å±éšªç‰Œåˆ¤æ–·ï¼šæª¢æŸ¥æ‰€æœ‰å°æ‰‹å¯èƒ½çš„ç­‰ç‰Œ
    let dangerLevel = 0;
    const tileKey_t = tileKey(t);
    
    // æª¢æŸ¥å·²å ±è½çš„å°æ‰‹
    listeningPlayers.forEach(lp => {
      if (canWinOn(lp, t)) {
        dangerLevel += 2000; // å·²å ±è½ä¸”èƒ½èƒ¡ï¼Œæ¥µåº¦å±éšª
      } else if (playerWaitKeys[lp] && playerWaitKeys[lp].includes(tileKey_t)) {
        dangerLevel += 800; // å·²å ±è½ä¸”ç­‰é€™å¼µç‰Œ
      }
    });
    
    // æª¢æŸ¥æœªå ±è½ä½†å¯èƒ½è½ç‰Œçš„å°æ‰‹
    Object.keys(playerWaitKeys).forEach(lp => {
      if (!listeningPlayers.includes(parseInt(lp))) {
        if (playerWaitKeys[lp].includes(tileKey_t)) {
          dangerLevel += 300; // å¯èƒ½è½ç‰Œä¸”ç­‰é€™å¼µç‰Œ
        }
      }
    });
    
    // æª¢æŸ¥æœ€è¿‘æ‰“å‡ºçš„ç‰Œï¼ˆå°æ‰‹å¯èƒ½ä¸è¦çš„ç‰Œï¼‰
    const recentDiscards = visible.slice(-10); // æœ€è¿‘10å¼µ
    const discardedSimilar = recentDiscards.filter(vt => {
      const vk = tileKey(vt);
      if (vk === tileKey_t) return true;
      if (t.suit === 'W' || t.suit === 'T' || t.suit === 'B') {
        const vt_tile = keyToTile(vk);
        if (vt_tile.suit === t.suit && Math.abs(vt_tile.rank - t.rank) <= 1) {
          return true;
        }
      }
      return false;
    }).length;
    
    // å¦‚æœæœ€è¿‘æœ‰äººæ‰“éé¡ä¼¼ç‰Œï¼Œé™ä½é¢¨éšª
    if (discardedSimilar > 0) {
      risk *= Math.max(0.3, 1 - discardedSimilar * 0.15);
    }
    
    // å¦‚æœä¸Ÿé€™å¼µç‰Œå¾Œèƒ½è½ç‰Œï¼Œè¨ˆç®—è½ç‰Œè³ªé‡
    if (isListening(after, me.melds)) {
      const waits = calcWaitingTiles(after, me.melds);
      waitCount = waits.length;
      waits.forEach(wk => {
        const total = 4;
        const used = visible.filter(vt => tileKey(vt) === wk).length;
        const remain = total - used;
        maxWaitTiles += remain;
        
        // å¦‚æœç­‰ç‰Œæ˜¯å±éšªç‰Œï¼Œé™ä½è½ç‰Œåƒ¹å€¼
        let waitDanger = 0;
        listeningPlayers.forEach(lp => {
          if (playerWaitKeys[lp] && playerWaitKeys[lp].includes(wk)) {
            waitDanger += 200;
          }
        });
        maxWaitTiles -= waitDanger * 0.1;
      });
    }
    
    // å¢å¼·çµæ§‹åˆ†æ
    const m = countByKey(after);
    let pairs = 0, triples = 0, isolated = 0, sequences = 0;
    let usefulPairs = 0; // æœ‰ç”¨çš„å°å­ï¼ˆå¯ä»¥çµ„æˆåˆ»å­æˆ–é †å­ï¼‰
    const keys = Object.keys(m);
    
    keys.forEach(k => {
      const c = m[k];
      if (c >= 3) triples++;
      else if (c === 2) {
        pairs++;
        const tile = keyToTile(k);
        // æª¢æŸ¥å°å­æ˜¯å¦æœ‰ç”¨ï¼ˆå¯ä»¥çµ„æˆåˆ»å­æˆ–é †å­ï¼‰
        if (tile.suit === 'W' || tile.suit === 'T' || tile.suit === 'B') {
          const rank = tile.rank;
          const hasLeft = m[`${tile.suit}${rank-1}`] || m[`${tile.suit}${rank-2}`];
          const hasRight = m[`${tile.suit}${rank+1}`] || m[`${tile.suit}${rank+2}`];
          if (hasLeft || hasRight) usefulPairs++;
        }
      }
      else if (c === 1) {
        const tile = keyToTile(k);
        if (tile.suit === 'W' || tile.suit === 'T' || tile.suit === 'B') {
          const rank = tile.rank;
          const hasLeft = m[`${tile.suit}${rank-1}`] || m[`${tile.suit}${rank-2}`];
          const hasRight = m[`${tile.suit}${rank+1}`] || m[`${tile.suit}${rank+2}`];
          if (!hasLeft && !hasRight) isolated++;
          else sequences++;
        } else {
          isolated++;
        }
      }
    });
    
    // å‘è½æ•¸æ”¹å–„çå‹µ
    const shantenImprovement = currentShanten - sh;
    const shantenBonus = shantenImprovement * 100;
    
    // çµæ§‹è©•åˆ†å¢å¼·
    const structureScore = (triples * 100) + (sequences * 70) + (pairs * 25) + (usefulPairs * 15) - (isolated * 50);
    
    // å¦‚æœæ¥è¿‘è½ç‰Œï¼Œå„ªå…ˆè€ƒæ…®è½ç‰Œè³ªé‡
    let listeningBonus = 0;
    if (sh <= 1) {
      listeningBonus = (waitCount * 600) + (maxWaitTiles * 60);
    } else {
      listeningBonus = (waitCount * 500) + (maxWaitTiles * 50);
    }
    
    // å¦‚æœå·²ç¶“è½ç‰Œï¼Œå„ªå…ˆä¿æŒè½ç‰Œç‹€æ…‹
    if (currentShanten === 0 && sh === 0) {
      listeningBonus *= 1.5;
    }
    
    const score = listeningBonus + shantenBonus - (sh * 35) - (risk * 8) - dangerLevel + structureScore;
    return { tile: t, score, sh, waitCount };
  });
  
  cands.sort((a, b) => {
    // å„ªå…ˆè€ƒæ…®åˆ†æ•¸
    if (Math.abs(a.score - b.score) > 50) {
      return b.score - a.score;
    }
    // åˆ†æ•¸ç›¸è¿‘æ™‚ï¼Œå„ªå…ˆé¸æ“‡å‘è½æ•¸æ›´å°çš„
    if (a.sh !== b.sh) {
      return a.sh - b.sh;
    }
    // å‘è½æ•¸ç›¸åŒæ™‚ï¼Œå„ªå…ˆé¸æ“‡è½ç‰Œæ•¸æ›´å¤šçš„
    return b.waitCount - a.waitCount;
  });
  
  return cands[0].tile;
}

function riskOf(tile) {
  if (tile.suit === SUIT_F || tile.suit === SUIT_D) return 0.4;
  if (tile.rank === 1 || tile.rank === 9) return 0.65;
  return 1.0;
}

function keyToTile(k) {
  const s = k[0], v = k.slice(1);
  if (s === 'W' || s === 'T' || s === 'B') return { suit: s, rank: parseInt(v), id: -1 };
  if (s === 'F') return { suit: SUIT_F, name: v, id: -1 };
  if (s === 'D') return { suit: SUIT_D, name: v, id: -1 };
  return { suit: '?', id: -1 };
}

/* ========= åƒç¢°æ§“é‚è¼¯ ========= */
function canChow(pid, tile) {
  const pl = S.players[pid];
  if (pl.melds.length >= 5) return [];
  
  // é †æ™‚é‡é †åºï¼š0(æ±) -> 1(å—) -> 2(è¥¿) -> 3(åŒ—) -> 0
  // åƒåªèƒ½åƒä¸Šå®¶çš„ç‰Œï¼Œä¸Šå®¶æ˜¯é †æ™‚é‡çš„å‰ä¸€å€‹
  const clockwiseOrder = [0, 1, 2, 3];
  const currentIndex = clockwiseOrder.indexOf(S.turn);
  const nextPlayer = clockwiseOrder[(currentIndex + 1) % 4];
  if (pid !== nextPlayer) return [];
  
  if (tile.suit !== SUIT_W && tile.suit !== SUIT_T && tile.suit !== SUIT_B) return [];
  
  const rank = tile.rank;
  const suit = tile.suit;
  const patterns = [];
  
  if (rank <= 7) {
    const has1 = pl.hand.some(t => t.suit === suit && t.rank === rank + 1);
    const has2 = pl.hand.some(t => t.suit === suit && t.rank === rank + 2);
    if (has1 && has2) patterns.push([rank, rank + 1, rank + 2]);
  }
  
  if (rank >= 2 && rank <= 8) {
    const has1 = pl.hand.some(t => t.suit === suit && t.rank === rank - 1);
    const has2 = pl.hand.some(t => t.suit === suit && t.rank === rank + 1);
    if (has1 && has2) patterns.push([rank - 1, rank, rank + 1]);
  }
  
  if (rank >= 3) {
    const has1 = pl.hand.some(t => t.suit === suit && t.rank === rank - 2);
    const has2 = pl.hand.some(t => t.suit === suit && t.rank === rank - 1);
    if (has1 && has2) patterns.push([rank - 2, rank - 1, rank]);
  }
  
  return patterns;
}

function doChow(pid, tile, pattern) {
  const pl = S.players[pid];
  const suit = tile.suit;
  const tiles = [tile];
  
  pattern.forEach(rank => {
    if (rank !== tile.rank) {
      const idx = pl.hand.findIndex(t => t.suit === suit && t.rank === rank);
      if (idx >= 0) {
        tiles.push(pl.hand.splice(idx, 1)[0]);
      }
    }
  });
  
  tiles.sort((a, b) => a.rank - b.rank);
  const centerIdx = tiles.findIndex(t => t === tile);
  pl.melds.push({ type: 'chow', tiles, centerIdx });
  S.anyOpenMeld = true;
  log(`ğŸœ ${playerName(pid)} åƒäº† ${tiles.map(t => keyToText(tileKey(t))).join(' ')}`);
  showEffect('ğŸœ åƒ', '#22c55e');
  SoundEffects.chow();
  
  S.turn = pid;
  S.lastDiscard = null;
  S.waitReact = null;
  hideReactionPanel();
  renderAll();
  
  S.lastAction = 'chow';
  S.lastActor = pid;
}

function canPong(pid, tile) {
  const pl = S.players[pid];
  if (pl.melds.length >= 5) return false;
  const k = tileKey(tile);
  const cnt = pl.hand.filter(t => tileKey(t) === k).length;
  return cnt >= 2;
}

function canKong(pid, tile) {
  const pl = S.players[pid];
  if (countKongs(pl) >= 3) return false;
  if (pl.melds.length >= 5) return false;
  const k = tileKey(tile);
  const cnt = pl.hand.filter(t => tileKey(t) === k).length;
  return cnt >= 3;
}

function canConcealedKong(pid) {
  const pl = S.players[pid];
  if (countKongs(pl) >= 3) return [];
  if (pl.melds.length >= 5) return [];
  if ((S.wall.length + S.deadWall.length) <= 3) return [];
  const counts = countByKey(pl.hand);
  return Object.keys(counts).filter(k => counts[k] >= 4);
}

function canAddedKong(pid) {
  const pl = S.players[pid];
  const res = [];
  if ((S.wall.length + S.deadWall.length) <= 3) return res;
  if (countKongs(pl) >= 3) return res;
  pl.melds.forEach((m, idx) => {
    if (m.type === 'pong') {
      const k = tileKey(m.tiles[0]);
      const hasFourth = pl.hand.some(t => tileKey(t) === k);
      if (hasFourth) {
        res.push({ meldIndex: idx, key: k });
      }
    }
  });
  return res;
}

function doConcealedKong(pid, key) {
  const pl = S.players[pid];
  const tiles = [];
  for (let i = pl.hand.length - 1; i >= 0; i--) {
    const t = pl.hand[i];
    if (tileKey(t) === key) {
      tiles.push(pl.hand.splice(i, 1)[0]);
      if (tiles.length === 4) break;
    }
  }
  pl.melds.push({ type: 'kong', tiles: tiles, concealed: true });
  S.kongCount++;
  if (pid === 0) {
    log(`ğŸ’¥ ${playerName(pid)} æš—æ§“ ${keyToText(key)}`);
  } else {
    log(`ğŸ’¥ ${playerName(pid)} æš—æ§“`);
  }
  showEffect('ğŸ’¥ æš—æ§“', '#a855f7');
  SoundEffects.kong();
  
  if (S.deadWall.length > 0) {
    const newTile = S.deadWall.pop();
    pl.hand.push(newTile);
  } else if (S.wall.length > 0) {
    const newTile = S.wall.pop();
    pl.hand.push(newTile);
  }
  S.remain = S.wall.length;
  renderAll();
  
  const t = pl.hand[pl.hand.length - 1];
  if (pid === 0) {
    if (isWinningNow(pl.hand, pl.melds, t)) {
      document.getElementById('btnHu').disabled = false;
      log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
    }
  } else {
    if (isWinningNow(pl.hand, pl.melds, t)) {
      doWin(pid, -1, t, true);
      return;
    }
    setTimeout(stepAI, 1000 + Math.random() * 1000);
  }
  
  S.lastAction = 'concealedKong';
  S.lastActor = pid;
}

function doAddedKong(pid, meldIndex) {
  const pl = S.players[pid];
  const meld = pl.melds[meldIndex];
  if (!meld || meld.type !== 'pong') return;
  const key = tileKey(meld.tiles[0]);
  let idx = -1;
  for (let i = 0; i < pl.hand.length; i++) {
    if (tileKey(pl.hand[i]) === key) {
      idx = i;
      break;
    }
  }
  if (idx < 0) return;
  const tile = pl.hand[idx]; // å…ˆä¸ç§»é™¤ï¼Œå…ˆæª¢æŸ¥æ¶æ§“
  
  // æª¢æŸ¥æ˜¯å¦æœ‰å…¶ä»–äººå¯ä»¥æ¶æ§“èƒ¡
  for (let other = 0; other < 4; other++) {
    if (other !== pid && canWinOn(other, tile)) {
      // æœ‰äººå¯ä»¥æ¶æ§“ï¼ŒåŸ·è¡Œæ¶æ§“èƒ¡
      S.robKong = true;
      pl.hand.splice(idx, 1); // ç¾åœ¨æ‰ç§»é™¤ç‰Œ
      doWin(other, pid, tile, false);
      return;
    }
  }
  
  // æ²’æœ‰äººæ¶æ§“ï¼ŒåŸ·è¡ŒåŠ æ§“
  pl.hand.splice(idx, 1);
  meld.tiles.push(tile);
  meld.type = 'kong';
  meld.added = true;
  S.anyOpenMeld = true;
  S.kongCount++;
  log(`ğŸ’¥ ${playerName(pid)} åŠ æ§“ ${keyToText(key)}`);
  showEffect('ğŸ’¥ æ§“', '#f97316');
  SoundEffects.kong();
  
  if (S.deadWall.length > 0) {
    const newTile = S.deadWall.pop();
    pl.hand.push(newTile);
  } else if (S.wall.length > 0) {
    const newTile = S.wall.pop();
    pl.hand.push(newTile);
  }
  S.remain = S.wall.length;
  pl.rinshan = true;
  renderAll();
  
  const t = pl.hand[pl.hand.length - 1];
  if (pid === 0) {
    if (isWinningNow(pl.hand, pl.melds, t)) {
      document.getElementById('btnHu').disabled = false;
      log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
    }
  } else {
    if (isWinningNow(pl.hand, pl.melds, t)) {
      doWin(pid, -1, t, true);
      return;
    }
    setTimeout(stepAI, 1000 + Math.random() * 1000);
  }
  
  S.lastAction = 'addedKong';
  S.lastActor = pid;
}

function doPong(pid, tile) {
  const pl = S.players[pid];
  const k = tileKey(tile);
  const tiles = [tile];
  for (let i = 0; i < 2; i++) {
    const idx = pl.hand.findIndex(t => tileKey(t) === k);
    if (idx >= 0) {
      tiles.push(pl.hand.splice(idx, 1)[0]);
    }
  }
  
  S.lastAction = 'pong';
  S.lastActor = pid;
  pl.melds.push({ type: 'pong', tiles });
  S.anyOpenMeld = true;
  log(`ğŸ”¥ ${playerName(pid)} ç¢°äº† ${keyToText(k)}`);
  showEffect('ğŸ”¥ ç¢°', '#f0c14b');
  SoundEffects.pong();
  S.turn = pid;
  S.lastDiscard = null;
  S.waitReact = null;
  hideReactionPanel();
  renderAll();
}

function doKong(pid, tile) {
  const pl = S.players[pid];
  const k = tileKey(tile);
  const tiles = [tile];
  for (let i = 0; i < 3; i++) {
    const idx = pl.hand.findIndex(t => tileKey(t) === k);
    if (idx >= 0) {
      tiles.push(pl.hand.splice(idx, 1)[0]);
    }
  }
  pl.melds.push({ type: 'kong', tiles });
  S.anyOpenMeld = true;
  S.kongCount++;
  log(`ğŸ’¥ ${playerName(pid)} æ§“äº† ${keyToText(k)}ï¼Œå¾ç‹ç‰Œè£œç‰Œ`);
  showEffect('ğŸ’¥ æ§“', '#f97316');
  SoundEffects.kong();
  
  if (S.deadWall.length > 0) {
    const newTile = S.deadWall.pop();
    pl.hand.push(newTile);
  } else if (S.wall.length > 0) {
    const newTile = S.wall.pop();
    pl.hand.push(newTile);
  }
  S.remain = S.wall.length;
  S.lastAction = 'kong';
  S.lastActor = pid;
  S.turn = pid;
  S.lastDiscard = null;
  S.waitReact = null;
  hideReactionPanel();
  renderAll();
  
  if (pid === 0) {
    const me = S.players[0];
    const t = me.hand[me.hand.length - 1];
    if (isWinningNow(me.hand, me.melds, t)) {
      document.getElementById('btnHu').disabled = false;
      log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
    }
    if (!me.declaredListen) {
      const kongCount = countKongs(me);
      const totalTiles = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
      const expectedFull = (S.dealer === 0 ? 17 : 16) + kongCount;
      if (totalTiles === expectedFull) {
        const canListenNow = me.hand.some(tile2 => {
          const testHand = me.hand.filter(t => t !== tile2);
          return isListening(testHand, me.melds);
        });
        if (canListenNow) showListenPanel();
      }
    }
  }
}

/* ========= å‡ºç‰Œèˆ‡åæ‡‰ ========= */
function discard(p, tile) {
  const hand = S.players[p].hand;
  const i = hand.indexOf(tile);
  if (i < 0) return;
  hand.splice(i, 1);
  S.players[p].drawnTile = null;
  S.players[p].discards.push(tile);
  S.lastDiscard = { tile, from: p };
  SoundEffects.discard();
  
  S.lastAction = 'discard';
  S.lastActor = p;
  log(`ğŸ´ ${playerName(p)} æ‰“å‡º ${keyToText(tileKey(tile))}`);
  
  S.players[p].rinshan = false;
  renderAll();
  
  {
    const pl = S.players[p];
    const kc = countKongs(pl);
    const totalP = pl.hand.length + pl.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    const expFull = (S.dealer === p ? 17 : 16) + kc;
    const expEmpty = (S.dealer === p ? 16 : 15) + kc;
    let ting = false;
    if (totalP === expFull) {
      ting = pl.hand.some(tt => {
        const test = pl.hand.filter(x => x !== tt);
        return isListening(test, pl.melds);
      });
    } else if (totalP === expEmpty) {
      ting = isListening(pl.hand, pl.melds);
    }
    if (ting) {
      const waits = calcWaitingTiles(pl.hand, pl.melds);
      pl.waitKeys = waits.slice();
      if (waits.length > 0 && p === 0) {
        const waitText = waits.map(k => keyToText(k)).join(' ');
        log('ğŸ‘‚ ç­‰ç‰Œï¼š' + waitText);
      }
    } else {
      pl.waitKeys = [];
    }
  }
  
  let reactions = [];
  // æŒ‰ç…§å„ªå…ˆç´šé †åºæª¢æŸ¥ï¼šèƒ¡ > æ§“ > ç¢° > åƒ
  // æ³¨æ„ï¼šæ¯å€‹ç©å®¶åªèƒ½æœ‰ä¸€ç¨®åæ‡‰ï¼Œå„ªå…ˆç´šé«˜çš„æœƒè¦†è“‹ä½çš„
  for (let k = 1; k <= 3; k++) {
    const pid = (p + k) % 4;
    if (pid === p) continue;
    
    // å„ªå…ˆç´š1ï¼šèƒ¡ç‰Œï¼ˆæœ€é«˜å„ªå…ˆç´šï¼‰
    if (canWinOn(pid, tile)) {
      reactions.push({ pid, type: 'hu', tile, priority: 1 });
    }
    // å„ªå…ˆç´š2ï¼šæ§“
    else if (canKong(pid, tile)) {
      reactions.push({ pid, type: 'kong', tile, priority: 2 });
    }
    // å„ªå…ˆç´š3ï¼šç¢°
    else if (canPong(pid, tile)) {
      reactions.push({ pid, type: 'pong', tile, priority: 3 });
    }
    // å„ªå…ˆç´š4ï¼šåƒï¼ˆåªèƒ½åƒä¸Šå®¶çš„ç‰Œï¼‰
    else {
      const chowPatterns = canChow(pid, tile);
      if (chowPatterns.length > 0) {
        reactions.push({ pid, type: 'chow', tile, patterns: chowPatterns, priority: 4 });
      }
    }
  }
  
  if (reactions.length > 0) {
    S.waitReact = reactions;
    if (reactions.some(r => r.pid === 0)) {
      showReactionPanel(reactions.filter(r => r.pid === 0));
    } else {
      setTimeout(() => handleAIReaction(reactions), 1000 + Math.random() * 1000);
    }
  } else {
    // ä½¿ç”¨ä¸Ÿç‰Œç©å®¶pä¾†è¨ˆç®—ä¸‹ä¸€å€‹å›åˆï¼Œè€Œä¸æ˜¯S.turn
    const nextTurn = getNextTurn(p);
    S.turn = nextTurn;
    S.lastDiscard = null; // æ¸…é™¤lastDiscardï¼Œå› ç‚ºæ²’æœ‰åæ‡‰
    S.waitReact = null; // æ¸…é™¤waitReact
    log(`ğŸ”„ å›åˆåˆ‡æ›ï¼š${playerName(p)} -> ${playerName(nextTurn)}`);
    renderAll(); // å…ˆæ›´æ–°UIé¡¯ç¤ºå›åˆè®ŠåŒ–
    stepNext();
  }
}

function showReactionPanel(reactions) {
  const me = S.players[0];
  if (me.declaredListen) {
    reactions = reactions.filter(r => r.type === 'hu');
    if (reactions.length === 0) {
      clearReactionButtons();
      S.turn = getNextTurn(S.lastDiscard.from);
      S.lastDiscard = null;
      S.waitReact = null;
      stepNext();
      return;
    }
  }
  
  clearReactionButtons();
  S.currentReactions = reactions;
  
  reactions.forEach(r => {
    if (r.type === 'hu') {
      document.getElementById('btnHu').classList.add('active');
      document.getElementById('btnHu').disabled = false;
    } else if (r.type === 'pong') {
      document.getElementById('btnPong').classList.add('active');
      document.getElementById('btnPong').disabled = false;
    } else if (r.type === 'kong') {
      document.getElementById('btnKong').classList.add('active');
      document.getElementById('btnKong').disabled = false;
    } else if (r.type === 'chow') {
      document.getElementById('btnChow').classList.add('active');
      document.getElementById('btnChow').disabled = false;
    }
  });
  
  document.getElementById('btnPass').classList.add('active');
  document.getElementById('btnPass').disabled = false;
}

function hideReactionPanel() {
  document.getElementById('modalOverlay').classList.remove('show');
}

function clearReactionButtons() {
  const buttons = ['btnHu', 'btnChow', 'btnPong', 'btnKong', 'btnPass'];
  buttons.forEach(id => {
    const btn = document.getElementById(id);
    if (btn) {
      btn.classList.remove('active');
      btn.disabled = true;
    }
  });
}

function handleChowClick() {
  if (!S.currentReactions) return;
  const chowReact = S.currentReactions.find(r => r.type === 'chow');
  if (!chowReact) return;
  
  if (chowReact.patterns && chowReact.patterns.length > 1) {
    showChowSelectionPanel(chowReact);
  } else {
    doChow(chowReact.pid, chowReact.tile, chowReact.patterns[0]);
    clearReactionButtons();
  }
}

function showChowSelectionPanel(chowReact) {
  const overlay = document.getElementById('modalOverlay');
  const content = document.getElementById('modalContent');
  
  let html = '<div class="modal-title">ğŸœ é¸æ“‡åƒæ³•</div>';
  html += '<div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">';
  chowReact.patterns.forEach((pat, idx) => {
    const patText = [...pat].sort((a, b) => a - b).map(r => r).join('-');
    html += `<button class="btn btn-secondary chowOpt" data-idx="${idx}" style="min-width: 80px;">ğŸœ ${patText}</button>`;
  });
  html += '</div>';
  html += '<button class="modal-btn" id="cancelChow" style="background: var(--bg-card); margin-top: 12px;">å–æ¶ˆ</button>';
  
  content.innerHTML = html;
  overlay.classList.add('show');
  
  const opts = content.querySelectorAll('.chowOpt');
  opts.forEach(btn => {
    const idx = parseInt(btn.getAttribute('data-idx'));
    btn.onclick = () => {
      doChow(chowReact.pid, chowReact.tile, chowReact.patterns[idx]);
      overlay.classList.remove('show');
      clearReactionButtons();
    };
  });
  
  document.getElementById('cancelChow').onclick = () => {
    overlay.classList.remove('show');
  };
}

function handlePongClick() {
  if (!S.currentReactions) return;
  const pongReact = S.currentReactions.find(r => r.type === 'pong');
  if (!pongReact) return;
  doPong(pongReact.pid, pongReact.tile);
  clearReactionButtons();
}

function handleKongClick() {
  if (!S.currentReactions) return;
  const kongReact = S.currentReactions.find(r => r.type === 'kong');
  if (!kongReact) return;
  doKong(kongReact.pid, kongReact.tile);
  clearReactionButtons();
}

function handleHuClick() {
  if (!S.currentReactions) return;
  const huReact = S.currentReactions.find(r => r.type === 'hu');
  if (!huReact) return;
  doWin(huReact.pid, S.lastDiscard.from, huReact.tile, false);
  clearReactionButtons();
}

function handlePassClick() {
  clearReactionButtons();
  S.turn = getNextTurn(S.lastDiscard.from);
  S.lastDiscard = null;
  S.waitReact = null;
  S.currentReactions = null;
  stepNext();
}

function showListenPanel() {
  const overlay = document.getElementById('modalOverlay');
  const content = document.getElementById('modalContent');
  
  let html = '<div class="modal-title">ğŸ”” æ˜¯å¦å ±è½ï¼Ÿ</div>';
  html += '<div style="display: flex; gap: 12px; justify-content: center;">';
  html += '<button class="btn btn-primary" id="listenYes" style="flex: 1;">ğŸ”” è½ç‰Œ</button>';
  html += '<button class="btn btn-secondary" id="listenNo" style="flex: 1;">â­ï¸ ä¸è½</button>';
  html += '</div>';
  
  content.innerHTML = html;
  overlay.classList.add('show');
  
  document.getElementById('listenYes').onclick = () => {
    const me = S.players[0];
    if (!me.declaredListen) {
      me.declaredListen = true;
      me.tingLocked = false;
      updateTianDiTing(0);
      const waitKeys = calcWaitingTiles(me.hand, me.melds);
      const waitText = waitKeys.map(k => keyToText(k)).join(' ');
      if (me.tianTing) {
        log('ğŸ”” ä½ å®£å‘Šå¤©è½ï¼èƒ¡ç‰Œæ™‚å¤š ' + RULES.scoring.HeavenReady + ' å°');
        showEffect('ğŸ”” å¤©è½', '#f0c14b', '52px');
      } else if (me.diTing) {
        log('ğŸ”” ä½ å®£å‘Šåœ°è½ï¼èƒ¡ç‰Œæ™‚å¤š ' + RULES.scoring.EarthReady + ' å°');
        showEffect('ğŸ”” åœ°è½', '#2dd4bf', '48px');
      } else {
        log('ğŸ”” ä½ å®£å‘Šè½ç‰Œï¼èƒ¡ç‰Œæ™‚å¤š 1 å°');
        showEffect('ğŸ”” è½ç‰Œ', '#2dd4bf', '44px');
      }
      SoundEffects.listen();
      log('âš ï¸ è«‹ä¸Ÿä¸€å¼µæ‰‹ç‰Œå¾Œé–å®šè½ç‰Œ');
      if (waitKeys.length > 0) {
        me.waitKeys = waitKeys.slice();
        log('ğŸ‘‚ ç­‰å¾…ç‰Œï¼š' + waitText);
      } else {
        me.waitKeys = [];
      }
    }
    overlay.classList.remove('show');
    renderAll();
  };
  
  document.getElementById('listenNo').onclick = () => {
    overlay.classList.remove('show');
  };
}

function handleAIReaction(reactions) {
  const huReact = reactions.find(r => r.type === 'hu');
  if (huReact) {
    doWin(huReact.pid, S.lastDiscard.from, huReact.tile, false);
    return;
  }
  
  reactions = reactions.filter(r => {
    const p = S.players[r.pid];
    if (p.declaredListen) {
      return r.type === 'hu' || r.type === 'kong';
    }
    return true;
  });
  
  // å¢å¼·æ§“çš„åæ‡‰åˆ¤æ–·
  const kongReact = reactions.find(r => r.type === 'kong');
  if (kongReact) {
    const me = S.players[kongReact.pid];
    const currentShanten = shantenAfterRemove(me.hand);
    // å¦‚æœå‘è½æ•¸è¼ƒå¤§ï¼Œæ›´å‚¾å‘æ–¼æ§“
    let kongChance = currentShanten >= 3 ? 0.5 : (currentShanten >= 2 ? 0.35 : 0.2);
    // å¦‚æœå·²ç¶“è½ç‰Œï¼Œé™ä½æ§“çš„æ©Ÿç‡ï¼ˆé¿å…ç ´å£è½ç‰Œï¼‰
    if (currentShanten === 0) {
      kongChance = 0.15;
    }
    if (Math.random() < kongChance) {
      doKong(kongReact.pid, kongReact.tile);
      setTimeout(stepAI, 1000 + Math.random() * 1000);
      return;
    }
  }
  
  // å¢å¼·ç¢°çš„åæ‡‰åˆ¤æ–·
  const pongReact = reactions.find(r => r.type === 'pong');
  if (pongReact) {
    const me = S.players[pongReact.pid];
    const currentShanten = shantenAfterRemove(me.hand);
    // æ ¹æ“šå‘è½æ•¸æ±ºå®šç¢°çš„æ©Ÿç‡
    let pongChance = currentShanten >= 3 ? 0.5 : (currentShanten >= 2 ? 0.4 : 0.25);
    // å¦‚æœå·²ç¶“è½ç‰Œï¼Œé™ä½ç¢°çš„æ©Ÿç‡
    if (currentShanten === 0) {
      pongChance = 0.2;
    }
    // å¦‚æœå·²ç¶“å ±è½ï¼Œåªèƒ½ç¢°æˆ–èƒ¡
    if (me.declaredListen) {
      pongChance = 0.3;
    }
    if (Math.random() < pongChance) {
      doPong(pongReact.pid, pongReact.tile);
      setTimeout(stepAI, 1000 + Math.random() * 1000);
      return;
    }
  }
  
  // å¢å¼·åƒçš„åæ‡‰åˆ¤æ–·
  const chowReact = reactions.find(r => r.type === 'chow');
  if (chowReact) {
    const me = S.players[chowReact.pid];
    const pattern = chowReact.patterns[0];
    const tile = chowReact.tile;
    const suit = tile.suit;
    
    const afterChow = me.hand.filter(t => {
      const key = tileKey(t);
      const needed = pattern.map(r => suit + r);
      const idx = needed.indexOf(key);
      if (idx >= 0) {
        needed.splice(idx, 1);
        return false;
      }
      return true;
    });
    
    const shBefore = shantenAfterRemove(me.hand);
    const shAfter = shantenAfterRemove(afterChow);
    
    // å¦‚æœåƒèƒ½æ”¹å–„å‘è½æ•¸ï¼Œæ›´å‚¾å‘æ–¼åƒ
    if (shAfter < shBefore) {
      const improvement = shBefore - shAfter;
      let chowChance = 0.3 + (improvement * 0.25); // æ”¹å–„è¶Šå¤šï¼Œæ©Ÿç‡è¶Šé«˜
      if (shAfter === 0) chowChance += 0.2; // å¦‚æœèƒ½è½ç‰Œï¼Œæé«˜æ©Ÿç‡
      if (Math.random() < chowChance) {
        doChow(chowReact.pid, chowReact.tile, pattern);
        setTimeout(stepAI, 1000 + Math.random() * 1000);
        return;
      }
    } else if (shAfter === shBefore && Math.random() < 0.25) {
      // å³ä½¿ä¸æ”¹å–„å‘è½æ•¸ï¼Œä¹Ÿæœ‰å°æ©Ÿç‡åƒï¼ˆç‚ºäº†æ”¹è®Šç‰Œå‹ï¼‰
      doChow(chowReact.pid, chowReact.tile, pattern);
      setTimeout(stepAI, 1000 + Math.random() * 1000);
      return;
    }
  }
  
  S.turn = getNextTurn(S.lastDiscard.from);
  S.lastDiscard = null;
  S.waitReact = null;
  stepNext();
}

function canWinOn(pid, tile) {
  const pl = S.players[pid];
  const tmp = pl.hand.concat([tile]);
  return isWinningNow(tmp, pl.melds, tile);
}

function doWin(winner, from, tile, selfDraw) {
  S.winner = winner;
  S.fromPlayer = from;
  S.winTile = tile;
  S.phase = 'end';
  showEffect('ğŸ‰ èƒ¡äº†ï¼', '#f0c14b', '64px');
  SoundEffects.win();
  
  const detail = calcFanDetails(winner, tile, selfDraw);
  const fan = detail.fan;
  const delta = RULES.points.base + fan * RULES.points.perFan;
  
  const catStr = detail.categories.join('ã€');
  if (selfDraw) {
    for (let i = 0; i < 4; i++) {
      if (i !== winner) {
        S.players[i].points -= delta;
      }
    }
    S.players[winner].points += delta * 3;
    log(`ğŸ‰ ${playerName(winner)} è‡ªæ‘¸ ${keyToText(tileKey(tile))}ï¼ˆ${catStr}ï¼Œå…±${fan}å°ï¼‰â†’ æ¯å®¶ä»˜ ${delta.toLocaleString()}`);
  } else {
    S.players[from].points -= delta * 3;
    S.players[winner].points += delta * 3;
    log(`ğŸ‰ ${playerName(winner)} é»èƒ¡ ${playerName(from)}ï¼ˆ${keyToText(tileKey(tile))}ï¼Œ${catStr}ï¼Œå…±${fan}å°ï¼‰â†’ æ”¾æ§è€…ä»˜ ${(delta * 3).toLocaleString()}`);
  }
  
  renderAll();
  S.players[winner].rinshan = false;
  S.robKong = false;
  
  for (let i = 0; i < 4; i++) {
    if (S.players[i].points <= 0) {
      log(`âš ï¸ ${playerName(i)} ç ´ç”¢ï¼ŒéŠæˆ²çµæŸ`);
      setTimeout(() => showFinalScore(), 1500);
      return;
    }
  }
  
  setTimeout(() => showHandsAndContinue(), 1000);
}

function calcFanDetails(winner, winTile, selfDraw) {
  const pl = S.players[winner];
  const allTiles = pl.hand.concat(pl.melds.flatMap(m => m.tiles));
  let fan = 0;
  const categories = [];
  
  // ç²å–åº§é¢¨å’Œåœˆé¢¨
  const seatWind = seatNames[winner] || 'æ±';
  const roundWind = ['æ±', 'å—', 'è¥¿', 'åŒ—'][S.round - 1] || 'æ±';
  
  // ========= ç‰¹æ®Šå¤§ç‰Œå‹ï¼ˆå„ªå…ˆåˆ¤å®šï¼Œäº’æ–¥ï¼‰ =========
  
  // ä¹è“®å¯¶ç‡ˆ
  if (checkNineGates(pl, winTile)) {
    fan += RULES.scoring.NineGates;
    categories.push('ä¹è“®å¯¶ç‡ˆ');
    // ä¹è“®å¯¶ç‡ˆé€šå¸¸ä¸èˆ‡å…¶ä»–å°å‹ç–ŠåŠ ï¼Œä½†é€™è£¡æˆ‘å€‘ç¹¼çºŒæª¢æŸ¥å…¶ä»–å°å‹
  }
  
  // å››æ§“å­
  const kongType = checkKongs(pl);
  if (kongType === 'four') {
    fan += RULES.scoring.FourKongs;
    categories.push('å››æ§“å­');
  }
  
  // å¤§å››å–œ
  const fourWinds = checkFourWinds(pl, winTile, seatWind, roundWind);
  if (fourWinds === 'big') {
    fan += RULES.scoring.BigFourWinds;
    categories.push('å¤§å››å–œ');
  }
  
  // å¤§ä¸‰å…ƒ
  const threeDragons = checkThreeDragons(pl, winTile);
  if (threeDragons === 'big') {
    fan += RULES.scoring.BigThreeDragons;
    categories.push('å¤§ä¸‰å…ƒ');
  }
  
  // å­—ä¸€è‰²
  if (checkAllHonors(pl, winTile)) {
    fan += RULES.scoring.AllHonors;
    categories.push('å­—ä¸€è‰²');
  }
  
  // æ¸…è€é ­
  if (checkAllTerminals(pl, winTile)) {
    fan += RULES.scoring.AllTerminals;
    categories.push('æ¸…è€é ­');
  }
  
  // ========= å…¶ä»–ç‰¹æ®Šç‰Œå‹ =========
  
  // å°å››å–œ
  if (fourWinds === 'little') {
    fan += RULES.scoring.LittleFourWinds;
    categories.push('å°å››å–œ');
  }
  
  // å°ä¸‰å…ƒ
  if (threeDragons === 'little') {
    fan += RULES.scoring.LittleThreeDragons;
    categories.push('å°ä¸‰å…ƒ');
  }
  
  // æ··è€é ­
  if (checkAllTerminalsAndHonors(pl, winTile)) {
    fan += RULES.scoring.AllTerminalsAndHonors;
    categories.push('æ··è€é ­');
  }
  
  // äº”æš—åˆ»
  const concealedPungs = checkConcealedPungs(pl);
  if (concealedPungs >= 5) {
    fan += RULES.scoring.FiveConcealedPungs;
    categories.push('äº”æš—åˆ»');
  } else if (concealedPungs >= 4) {
    fan += RULES.scoring.FourConcealedPungs;
    categories.push('å››æš—åˆ»');
  } else if (concealedPungs >= 3) {
    fan += RULES.scoring.ThreeConcealedPungs;
    categories.push('ä¸‰æš—åˆ»');
  }
  
  // ä¸‰æ§“å­
  if (kongType === 'three') {
    fan += RULES.scoring.ThreeKongs;
    categories.push('ä¸‰æ§“å­');
  }
  
  // æ¸…ä¸€è‰²
  const suitCnt = { W: 0, T: 0, B: 0 };
  let honors = 0;
  for (const t of allTiles) {
    const k = tileKey(t)[0];
    if (suitCnt[k] != null) suitCnt[k]++;
    else if (k === 'F' || k === 'D') honors++;
  }
  
  const nz = Object.values(suitCnt).filter(x => x > 0).length;
  if (nz === 1 && honors === 0) {
    fan += RULES.scoring.PureOneSuit;
    categories.push('æ¸…ä¸€è‰²');
  } else if (nz === 1 && honors > 0) {
    fan += RULES.scoring.HalfFlush;
    categories.push('æ··ä¸€è‰²');
  }
  
  // å°å°èƒ¡
  const kinds = countByKey(pl.hand.concat([winTile]));
  const allTrip = isAllPungsPossible(kinds);
  if (allTrip) {
    fan += RULES.scoring.AllPungs;
    categories.push('å°å°èƒ¡');
  }
  
  // å…¨æ±‚äºº
  if (checkAllChows(pl)) {
    fan += RULES.scoring.AllChows;
    categories.push('å…¨æ±‚äºº');
  }
  
  // ========= ç‰¹æ®Šæƒ…æ³ =========
  
  // å¤©è½
  if (pl.tianTing) {
    fan += RULES.scoring.HeavenReady;
    categories.push('å¤©è½');
  } else if (pl.diTing) {
    // åœ°è½
    fan += RULES.scoring.EarthReady;
    categories.push('åœ°è½');
  } else if (pl.declaredListen) {
    // å ±è½
    fan += RULES.scoring.DeclaredListen;
    categories.push('å ±è½');
  }
  
  // åº§é¢¨å’Œåœˆé¢¨
  const winds = checkSeatAndRoundWind(pl, winTile, seatWind, roundWind);
  if (winds.seatWind) {
    fan += RULES.scoring.SeatWind;
    categories.push('åº§é¢¨');
  }
  if (winds.roundWind && !winds.seatWind) { // å¦‚æœåº§é¢¨å’Œåœˆé¢¨ç›¸åŒï¼Œåªç®—ä¸€æ¬¡
    fan += RULES.scoring.RoundWind;
    categories.push('åœˆé¢¨');
  }
  
    // è‡ªæ‘¸ç›¸é—œ
  if (selfDraw) {
    const menqing = pl.melds.length === 0;
    if (menqing) {
      fan += RULES.scoring.MenqingSelfDraw;
      categories.push('é–€æ¸…è‡ªæ‘¸');
    } else {
      fan += RULES.scoring.SelfDraw;
      categories.push('è‡ªæ‘¸');
    }
    
    // æµ·åº•æ’ˆæœˆï¼šè‡ªæ‘¸æœ€å¾Œä¸€å¼µç‰Œï¼ˆç‰Œå±±å·²ç©ºï¼Œå¾ç‹ç‰Œæ‘¸æœ€å¾Œä¸€å¼µï¼‰
    const dead = 16 + S.kongCount;
    if (S.wall.length === 0 && S.deadWall.length > 0 && S.deadWall.length <= dead) {
      fan += RULES.scoring.Haitei;
      categories.push('æµ·åº•æ’ˆæœˆ');
    }
  } else {
    // æ²³åº•æ’ˆé­šï¼šèƒ¡åˆ¥äººæ‰“çš„æœ€å¾Œä¸€å¼µç‰Œï¼ˆç‰Œå±±å’Œç‹ç‰Œéƒ½å·²ç©ºï¼‰
    const dead = 16 + S.kongCount;
    if (S.wall.length === 0 && S.deadWall.length === 0) {
      fan += RULES.scoring.Houtei;
      categories.push('æ²³åº•æ’ˆé­š');
    }
  }
  
  // æ¶æ§“
  if (S.robKong) {
    fan += RULES.scoring.RobKong;
    categories.push('æ¶æ§“');
  }
  
  // æ§“ä¸Šé–‹èŠ±
  if (selfDraw && pl.rinshan) {
    fan += RULES.scoring.Rinshan;
    categories.push('æ§“ä¸Šé–‹èŠ±');
  }
  
  // é‡‘ç‰Œç›¸é—œ
  if (S.rules.gold.enabled) {
    const keys = allTiles.map(tileKey);
    const goldOwned = keys.filter(k => S.goldKeys.includes(k)).length;
    fan += goldOwned * S.rules.gold.perGold;
    if (goldOwned > 0) categories.push(`é‡‘ç‰Œx${goldOwned}`);
    if (S.goldKeys.includes(tileKey(winTile))) {
      fan += S.rules.gold.winOnGold;
      categories.push('é‡‘ç‰Œèƒ¡');
    }
  }
  
  // å¦‚æœæ²’æœ‰ä»»ä½•å°å‹ï¼Œç®—å¹³èƒ¡
  if (categories.length === 0) {
    categories.push('å¹³èƒ¡');
    fan = 1; // å¹³èƒ¡è‡³å°‘1å°
  }
  
  return { fan: Math.max(1, fan), categories };
}

function isAllPungsPossible(counts) {
  let pairs = 0;
  let triples = 0;
  for (const k in counts) {
    const c = counts[k];
    if (c === 2) pairs++;
    else if (c >= 3) triples++;
    else if (c === 1) return false;
  }
  return pairs === 1 && triples >= 4;
}

/* ========= å°å‹åˆ¤å®šå‡½æ•¸ ========= */
function checkAllChows(pl) {
  // å…¨æ±‚äººï¼šæ‰€æœ‰å‰¯éœ²éƒ½æ˜¯åƒæˆ–ç¢°ï¼Œä¸”æœ€å¾Œä¸€å¼µæ˜¯åˆ¥äººæ‰“çš„
  if (pl.melds.length === 0) return false;
  if (pl.melds.length < 5) return false;
  const allChowsOrPongs = pl.melds.every(m => m.type === 'chow' || m.type === 'pong');
  return allChowsOrPongs && pl.hand.length === 1;
}

function checkConcealedPungs(pl) {
  // è¨ˆç®—æš—åˆ»æ•¸é‡
  // 1. æ‰‹ç‰Œä¸­çš„åˆ»å­ï¼ˆ3å¼µç›¸åŒï¼Œä¸”æ²’æœ‰å‰¯éœ²ï¼‰
  const handCounts = countByKey(pl.hand);
  let concealedPungs = 0;
  for (const k in handCounts) {
    // æª¢æŸ¥æ˜¯å¦æœ‰å°æ‡‰çš„æ˜åˆ»æˆ–æ˜æ§“
    const hasOpenMeld = pl.melds.some(m => {
      if (m.type === 'pong' || (m.type === 'kong' && !m.concealed)) {
        return tileKey(m.tiles[0]) === k;
      }
      return false;
    });
    // å¦‚æœæ‰‹ç‰Œä¸­æœ‰3å¼µæˆ–4å¼µç›¸åŒï¼Œä¸”æ²’æœ‰æ˜åˆ»ï¼Œç®—ä½œæš—åˆ»
    if (handCounts[k] >= 3 && !hasOpenMeld) {
      concealedPungs++;
    }
  }
  // 2. åŠ ä¸Šæš—æ§“ï¼ˆæš—æ§“ä¹Ÿç®—æš—åˆ»ï¼‰
  const concealedKongs = pl.melds.filter(m => m.type === 'kong' && m.concealed).length;
  return concealedPungs + concealedKongs;
}

function checkThreeDragons(pl, winTile) {
  // æª¢æŸ¥ä¸‰å…ƒç‰Œ
  const allTiles = pl.hand.concat([winTile]).concat(pl.melds.flatMap(m => m.tiles));
  const dragonCounts = { C: 0, F: 0, B: 0 }; // ä¸­ç™¼ç™½
  for (const t of allTiles) {
    if (t.suit === SUIT_D) {
      dragonCounts[t.name] = (dragonCounts[t.name] || 0) + 1;
    }
  }
  const hasAll = dragonCounts.C >= 3 && dragonCounts.F >= 3 && dragonCounts.B >= 3;
  const hasTwo = Object.values(dragonCounts).filter(c => c >= 3).length === 2;
  const hasPair = Object.values(dragonCounts).some(c => c >= 2);
  
  if (hasAll) return 'big'; // å¤§ä¸‰å…ƒ
  if (hasTwo && hasPair) return 'little'; // å°ä¸‰å…ƒ
  return null;
}

function checkFourWinds(pl, winTile, seatWind, roundWind) {
  // æª¢æŸ¥å››å–œç‰Œ
  const allTiles = pl.hand.concat([winTile]).concat(pl.melds.flatMap(m => m.tiles));
  const windCounts = { E: 0, S: 0, W: 0, N: 0 };
  for (const t of allTiles) {
    if (t.suit === SUIT_F) {
      windCounts[t.name] = (windCounts[t.name] || 0) + 1;
    }
  }
  const hasAll = Object.values(windCounts).every(c => c >= 3);
  const hasThree = Object.values(windCounts).filter(c => c >= 3).length === 3;
  const hasPair = Object.values(windCounts).some(c => c >= 2);
  
  if (hasAll) return 'big'; // å¤§å››å–œ
  if (hasThree && hasPair) return 'little'; // å°å››å–œ
  return null;
}

function checkAllHonors(pl, winTile) {
  // å­—ä¸€è‰²ï¼šå…¨éƒ¨æ˜¯å­—ç‰Œï¼ˆé¢¨ç‰Œ+ä¸‰å…ƒç‰Œï¼‰
  const allTiles = pl.hand.concat([winTile]).concat(pl.melds.flatMap(m => m.tiles));
  return allTiles.every(t => t.suit === SUIT_F || t.suit === SUIT_D);
}

function checkAllTerminals(pl, winTile) {
  // æ¸…è€é ­ï¼šå…¨éƒ¨æ˜¯1å’Œ9
  const allTiles = pl.hand.concat([winTile]).concat(pl.melds.flatMap(m => m.tiles));
  return allTiles.every(t => {
    if (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) {
      return t.rank === 1 || t.rank === 9;
    }
    return false;
  });
}

function checkAllTerminalsAndHonors(pl, winTile) {
  // æ··è€é ­ï¼šå…¨éƒ¨æ˜¯1ã€9æˆ–å­—ç‰Œ
  const allTiles = pl.hand.concat([winTile]).concat(pl.melds.flatMap(m => m.tiles));
  return allTiles.every(t => {
    if (t.suit === SUIT_F || t.suit === SUIT_D) return true;
    if (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) {
      return t.rank === 1 || t.rank === 9;
    }
    return false;
  });
}

function checkNineGates(pl, winTile) {
  // ä¹è“®å¯¶ç‡ˆï¼šåŒä¸€èŠ±è‰²1112345678999 + ä»»æ„ä¸€å¼µåŒèŠ±è‰²
  if (pl.melds.length > 0) return false; // å¿…é ˆé–€æ¸…
  
  const allTiles = pl.hand.concat([winTile]);
  const suitCounts = { W: [], T: [], B: [] };
  
  for (const t of allTiles) {
    if (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) {
      suitCounts[t.suit].push(t.rank);
    } else {
      return false; // ä¸èƒ½æœ‰å­—ç‰Œ
    }
  }
  
  // æª¢æŸ¥æ˜¯å¦åªæœ‰ä¸€ç¨®èŠ±è‰²
  const suits = Object.keys(suitCounts).filter(s => suitCounts[s].length > 0);
  if (suits.length !== 1) return false;
  
  const suit = suits[0];
  const ranks = suitCounts[suit].sort((a, b) => a - b);
  
  // å¿…é ˆæ˜¯16å¼µï¼ˆèŠå®¶ï¼‰æˆ–15å¼µï¼ˆéèŠå®¶ï¼‰+ 1å¼µèƒ¡ç‰Œ = 16å¼µ
  if (ranks.length !== 16) return false;
  
  // æª¢æŸ¥æ˜¯å¦ç¬¦åˆä¹è“®å¯¶ç‡ˆæ¨¡å¼ï¼š1112345678999 + ä»»æ„ä¸€å¼µ
  const required = [1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 9];
  const counts = {};
  for (const r of ranks) {
    counts[r] = (counts[r] || 0) + 1;
  }
  
  // å¿…é ˆæœ‰3å€‹1å’Œ3å€‹9
  if (counts[1] < 3 || counts[9] < 3) return false;
  
  // 2-8æ¯å€‹è‡³å°‘è¦æœ‰1å€‹
  for (let r = 2; r <= 8; r++) {
    if (!counts[r] || counts[r] < 1) return false;
  }
  
  // ç¸½å…±16å¼µï¼Œç¬¦åˆä¹è“®å¯¶ç‡ˆ
  return true;
}

function checkKongs(pl) {
  // è¨ˆç®—æ§“çš„æ•¸é‡
  const kongCount = pl.melds.filter(m => m.type === 'kong').length;
  if (kongCount >= 4) return 'four'; // å››æ§“å­
  if (kongCount >= 3) return 'three'; // ä¸‰æ§“å­
  return null;
}

function checkSeatAndRoundWind(pl, winTile, seatWind, roundWind) {
  // æª¢æŸ¥åº§é¢¨å’Œåœˆé¢¨
  const allTiles = pl.hand.concat([winTile]).concat(pl.melds.flatMap(m => m.tiles));
  const windMap = { 'æ±': 'E', 'å—': 'S', 'è¥¿': 'W', 'åŒ—': 'N' };
  const seatWindCode = windMap[seatWind] || seatWind;
  const roundWindCode = windMap[roundWind] || roundWind;
  
  let seatWindCount = 0;
  let roundWindCount = 0;
  
  for (const t of allTiles) {
    if (t.suit === SUIT_F) {
      if (t.name === seatWindCode) seatWindCount++;
      if (t.name === roundWindCode) roundWindCount++;
    }
  }
  
  const hasSeatWind = seatWindCount >= 3 || (seatWindCount >= 2 && seatWindCode === roundWindCode);
  const hasRoundWind = roundWindCount >= 3 || (roundWindCount >= 2 && seatWindCode === roundWindCode);
  
  return { seatWind: hasSeatWind, roundWind: hasRoundWind };
}

/* ========= éŠæˆ²æµç¨‹ ========= */
function stepNext() {
  if (S.phase === 'end') return;
  
  const dead = 16 + S.kongCount;
  // æµå±€ï¼šç‰Œå±±å’Œç‹ç‰Œéƒ½ç‚ºç©º
  if (S.wall.length === 0 && S.deadWall.length === 0) {
    log('ğŸš« æµå±€ - ç‰Œå±±æ¯ç«­');
    S.phase = 'end';
    S.winner = null;
    renderAll();
    setTimeout(() => showHandsAndContinue(), 1000);
    return;
  }
  
  // ç¢ºä¿S.turnæ˜¯æœ‰æ•ˆçš„å€¼ï¼ˆ0-3ï¼‰
  if (S.turn === undefined || S.turn === null || S.turn < 0 || S.turn > 3) {
    log('âš ï¸ å›åˆæ•¸éŒ¯èª¤ï¼Œé‡ç½®ç‚º0');
    S.turn = 0;
  }
  
  if (S.turn === 0) {
    // ç©å®¶0çš„å›åˆï¼Œå…ˆæ‘¸ç‰Œ
    const me = S.players[0];
    const hadDrawnTile = me.drawnTile; // è¨˜éŒ„ä¹‹å‰æ˜¯å¦æœ‰æ‘¸åˆ°çš„ç‰Œ
    
    draw(0);
    
    // æª¢æŸ¥æ˜¯å¦æˆåŠŸæ‘¸ç‰Œ
    if (!me.drawnTile && !hadDrawnTile) {
      // æ‘¸ç‰Œå¤±æ•—ï¼Œå¯èƒ½æ˜¯æµå±€
      if (S.wall.length === 0 && S.deadWall.length === 0) {
        log('ğŸš« æµå±€ - ç‰Œå±±æ¯ç«­');
        S.phase = 'end';
        S.winner = null;
        renderAll();
        setTimeout(() => showHandsAndContinue(), 1000);
        return;
      }
      // å¦‚æœé‚„æœ‰ç‰Œä½†æ‘¸ç‰Œå¤±æ•—ï¼Œè¨˜éŒ„éŒ¯èª¤
      log('âš ï¸ æ‘¸ç‰Œå¤±æ•—ï¼Œä½†é‚„æœ‰ç‰Œ');
      renderAll();
      return;
    }
    
    renderAll();
    
    // ç¢ºä¿æœ‰æ‰‹ç‰Œæ‰èƒ½æª¢æŸ¥èƒ¡ç‰Œ
    if (me.hand.length > 0 && me.drawnTile) {
      const t = me.drawnTile;
      if (isWinningNow(me.hand, me.melds, t)) {
        document.getElementById('btnHu').disabled = false;
        log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
      }
    }
  } else {
    setTimeout(stepAI, 800 + Math.random() * 800);
  }
}

function stepAI() {
  if (S.phase === 'end') return;
  if (S.turn === 0) return;
  
  const pid = S.turn;
  const pl = S.players[pid];
  
  if (S.lastAction === 'discard' || S.lastAction === null) {
    draw(pid);
    // å¦‚æœæ‘¸ç‰Œå¤±æ•—ï¼ˆæ²’æœ‰ç‰Œäº†ï¼‰ï¼Œæª¢æŸ¥æ˜¯å¦æµå±€
    if (pl.hand.length === 0 || !pl.drawnTile) {
      if (S.wall.length === 0 && S.deadWall.length === 0) {
        log('ğŸš« æµå±€ - ç‰Œå±±æ¯ç«­');
        S.phase = 'end';
        S.winner = null;
        renderAll();
        setTimeout(() => showHandsAndContinue(), 1000);
        return;
      }
      // å¦‚æœæ‘¸ç‰Œå¤±æ•—ä½†é‚„æœ‰ç‰Œï¼Œå¯èƒ½æ˜¯é‚è¼¯éŒ¯èª¤ï¼Œç›´æ¥è¿”å›é¿å…å¡ä½
      return;
    }
  }
  
  // ç¢ºä¿æœ‰æ‰‹ç‰Œæ‰èƒ½ç¹¼çºŒ
  if (pl.hand.length === 0) return;
  
  const t = pl.hand[pl.hand.length - 1];
  if (isWinningNow(pl.hand, pl.melds, t)) {
    doWin(pid, -1, t, true);
    return;
  }
  
  // å¢å¼·æš—æ§“åˆ¤æ–·ï¼šè€ƒæ…®æ‰‹ç‰Œç‹€æ³
  const cks = canConcealedKong(pid);
  if (cks.length > 0) {
    const currentShanten = shantenAfterRemove(pl.hand);
    // å¦‚æœå‘è½æ•¸è¼ƒå¤§ï¼Œæ›´å‚¾å‘æ–¼æš—æ§“
    let kongChance = currentShanten >= 3 ? 0.6 : (currentShanten >= 2 ? 0.45 : 0.3);
    // å¦‚æœå·²ç¶“è½ç‰Œï¼Œé™ä½æš—æ§“æ©Ÿç‡ï¼ˆé™¤éèƒ½æ”¹å–„è½ç‰Œï¼‰
    if (currentShanten === 0) {
      kongChance = 0.2;
    }
    if (Math.random() < kongChance) {
      doConcealedKong(pid, cks[0]);
      return;
    }
  }
  
  // å¢å¼·åŠ æ§“åˆ¤æ–·
  const aks = canAddedKong(pid);
  if (aks.length > 0) {
    const currentShanten = shantenAfterRemove(pl.hand);
    // å¦‚æœå‘è½æ•¸è¼ƒå¤§ï¼Œæ›´å‚¾å‘æ–¼åŠ æ§“
    let kongChance = currentShanten >= 3 ? 0.55 : (currentShanten >= 2 ? 0.45 : 0.35);
    // å¦‚æœå·²ç¶“è½ç‰Œï¼Œé™ä½åŠ æ§“æ©Ÿç‡ï¼ˆé¿å…è¢«æ¶æ§“ï¼‰
    if (currentShanten === 0) {
      // æª¢æŸ¥æ˜¯å¦æœ‰å°æ‰‹è½ç‰Œ
      let hasListeningOpponent = false;
      for (let i = 0; i < 4; i++) {
        if (i !== pid && S.players[i].declaredListen) {
          hasListeningOpponent = true;
          break;
        }
      }
      kongChance = hasListeningOpponent ? 0.15 : 0.3;
    }
    if (Math.random() < kongChance) {
      const candidate = aks[0];
      // æ¶æ§“æª¢æŸ¥å·²ç¶“åœ¨doAddedKongå…§éƒ¨é€²è¡Œï¼Œé€™è£¡ç›´æ¥èª¿ç”¨
      doAddedKong(pid, candidate.meldIndex);
      return;
    }
  }
  
  // å¢å¼·å ±è½åˆ¤æ–·
  if (!pl.declaredListen && isListening(pl.hand, pl.melds)) {
    const waits = calcWaitingTiles(pl.hand, pl.melds);
    const visible = [];
    S.players.forEach(p => visible.push(...p.discards, ...p.flowers));
    
    // è¨ˆç®—ç­‰ç‰Œçš„å‰©é¤˜æ•¸é‡
    let totalRemain = 0;
    waits.forEach(wk => {
      const used = visible.filter(vt => tileKey(vt) === wk).length;
      totalRemain += (4 - used);
    });
    
    // æ ¹æ“šç­‰ç‰Œæ•¸é‡å’Œå‰©é¤˜ç‰Œæ•¸æ±ºå®šå ±è½æ©Ÿç‡
    let listenChance = 0.4; // åŸºç¤æ©Ÿç‡
    if (waits.length >= 4) listenChance = 0.7; // ç­‰ç‰Œå¤šï¼Œæ›´å‚¾å‘å ±è½
    else if (waits.length >= 2) listenChance = 0.55;
    
    if (totalRemain >= 8) listenChance += 0.15; // å‰©é¤˜ç‰Œå¤šï¼Œæ›´å‚¾å‘å ±è½
    else if (totalRemain <= 4) listenChance -= 0.2; // å‰©é¤˜ç‰Œå°‘ï¼Œé™ä½å ±è½æ©Ÿç‡
    
    // å¦‚æœå‘è½æ•¸ç‚º0ï¼ˆå·²ç¶“è½ç‰Œï¼‰ï¼Œæé«˜å ±è½æ©Ÿç‡
    const currentShanten = shantenAfterRemove(pl.hand);
    if (currentShanten === 0) {
      listenChance = Math.min(0.9, listenChance + 0.3);
    }
    
    if (Math.random() < listenChance) {
      pl.declaredListen = true;
      updateTianDiTing(pid);
      log(`ğŸ”” ${playerName(pid)} å ±è½`);
    }
  }
  
  const discardTile = aiChooseDiscard(pid);
  discard(pid, discardTile);
}

function draw(p) {
  let t = null;
  
  // å„ªå…ˆå¾ç‰Œå±±æ‘¸ç‰Œ
  if (S.wall.length > 0) {
    t = S.wall.pop();
  } 
  // å¦‚æœç‰Œå±±ç‚ºç©ºï¼Œå¾ç‹ç‰Œæ‘¸ç‰Œ
  else if (S.deadWall.length > 0) {
    t = S.deadWall.pop();
  } 
  // å¦‚æœéƒ½æ²’æœ‰ç‰Œäº†ï¼Œç„¡æ³•æ‘¸ç‰Œ
  else {
    return;
  }
  
  S.players[p].hand.push(t);
  S.players[p].drawnTile = t;
  S.players[p].drawCount = (S.players[p].drawCount || 0) + 1;
  S.remain = S.wall.length + S.deadWall.length;
  S.drawCount++;
  SoundEffects.draw();
  
  if (p === 0) {
    const k = tileKey(t);
    log(`ğŸ¤² ä½ æ‘¸åˆ° ${keyToText(k)}`);
  }
  
  S.lastAction = 'draw';
  S.lastActor = p;
}

/* ========= UI æ¸²æŸ“ ========= */
function renderAll() {
  // æ›´æ–°å›åˆè³‡è¨Š
  const roundStr = ['æ±','å—','è¥¿','åŒ—'][S.round - 1] + 'é¢¨' + (seatNames?.[S.dealer] || ['æ±','å—','è¥¿','åŒ—'][S.dealer]);
  document.getElementById('centerRound').textContent = roundStr;
  document.getElementById('centerRemain').textContent = Math.max(0, S.remain || (S.wall.length + S.deadWall.length));
  
  // é‡‘ç‰Œé¡¯ç¤º
  const goldDisplay = document.getElementById('goldDisplay');
  const goldTiles = document.getElementById('goldTiles');
  if (S.rules.gold.enabled && S.goldKeys && S.goldKeys.length > 0) {
    goldDisplay.style.display = 'flex';
    goldTiles.innerHTML = S.goldKeys.map(k => {
      const text = keyToText(k);
      let colorClass = 'suit-' + k[0];
      return `<div class="gold-tile ${colorClass}">${text}</div>`;
    }).join('');
  } else {
    goldDisplay.style.display = 'none';
  }
  
  // å°æ‰‹å€åŸŸ
  const opponentsArea = document.getElementById('opponentsArea');
  let opponentsHTML = '';
  for (let i = 1; i <= 3; i++) {
    const p = S.players[i];
    const wind = seatNames[i] || ['æ±','å—','è¥¿','åŒ—'][i];
    const name = S.names && S.names[i] ? S.names[i] : wind + 'å®¶';
    const isActive = S.turn === i && S.phase !== 'end';
    const isDealer = S.dealer === i;
    
    opponentsHTML += `
      <div class="opponent-card ${isActive ? 'active-turn' : ''}">
        <div class="opponent-header">
          <div class="opponent-name">
            <div class="wind-icon">${wind}</div>
            <span>${name}</span>
            ${isDealer ? '<span class="dealer-mark">èŠ</span>' : ''}
            ${p.declaredListen ? '<span class="listen-mark">è½</span>' : ''}
          </div>
          <div class="opponent-score">${p.points.toLocaleString()}</div>
        </div>
        <div class="opponent-content">
          <div class="discard-zone">
            <span class="discard-zone-label">æ¨ç‰Œ</span>
            ${p.discards.map(t => {
              const k = tileKey(t);
              const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
              return `<div class="tile tile-xs suit-${t.suit} ${isGold ? 'gold' : ''}">${keyToText(k)}</div>`;
            }).join('')}
          </div>
          ${p.melds.length > 0 ? `
            <div class="meld-zone">
              ${p.melds.map(m => {
                const isConcealed = m.concealed;
                return `<div class="meld-group">
                  ${m.tiles.map(t => {
                    if (isConcealed) {
                      return `<div class="tile tile-xs" style="background: #4a5568; color: transparent;">ç‰Œ</div>`;
                    }
                    const k = tileKey(t);
                    const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
                    return `<div class="tile tile-xs suit-${t.suit} ${isGold ? 'gold' : ''}">${keyToText(k)}</div>`;
                  }).join('')}
                </div>`;
              }).join('')}
            </div>
          ` : ''}
        </div>
      </div>
    `;
  }
  opponentsArea.innerHTML = opponentsHTML;
  
  // æˆ‘çš„è³‡è¨Š
  const me = S.players[0];
  const myWind = seatNames[0] || 'æ±';
  document.getElementById('myWind').textContent = myWind;
  document.getElementById('myName').textContent = S.names && S.names[0] ? S.names[0] + '(ä½ )' : 'ä½ ';
  document.getElementById('myScore').textContent = me.points.toLocaleString();
  
  const myDealerMark = document.getElementById('myDealerMark');
  const myListenMark = document.getElementById('myListenMark');
  if (S.dealer === 0) {
    myDealerMark.classList.remove('hidden');
  } else {
    myDealerMark.classList.add('hidden');
  }
  if (me.declaredListen) {
    myListenMark.classList.remove('hidden');
  } else {
    myListenMark.classList.add('hidden');
  }
  
  // è½ç‰Œæç¤º
  const listenHint = document.getElementById('listenHint');
  if (me.waitKeys && me.waitKeys.length > 0) {
    listenHint.classList.remove('hidden');
    listenHint.innerHTML = 'ğŸ‘‚ ç­‰ç‰Œï¼š' + me.waitKeys.map(k => `<span class="tile log-tile suit-${k[0]}">${keyToText(k)}</span>`).join(' ');
  } else {
    listenHint.classList.add('hidden');
  }
  
  // æˆ‘çš„æ‰‹ç‰Œ
  const kongCount = countKongs(me);
  const origTiles = me.hand.map((t, idx) => ({ tile: t, index: idx }));
  
  // æª¢æŸ¥æ˜¯å¦æœ‰æ‘¸åˆ°çš„ç‰Œ
  // æ‘¸åˆ°çš„ç‰Œæ‡‰è©²æ˜¯æœ€å¾Œä¸€å¼µï¼ˆå› ç‚ºdrawå‡½æ•¸ä½¿ç”¨pushï¼‰ï¼Œæˆ–è€…é€šédrawnTileæ¨™è¨˜æ‰¾åˆ°
  let drawnObj = null;
  let displayRest = [];
  
  if (me.drawnTile) {
    // å…ˆå˜—è©¦é€šédrawnTileæ‰¾åˆ°
    const drawnIndex = me.hand.findIndex(t => {
      // ä½¿ç”¨å°è±¡å¼•ç”¨æ¯”è¼ƒï¼Œå¦‚æœå¤±æ•—å‰‡ä½¿ç”¨å±¬æ€§æ¯”è¼ƒ
      if (t === me.drawnTile) return true;
      // å‚™ç”¨ï¼šæ¯”è¼ƒå±¬æ€§
      if (t && me.drawnTile && t.suit === me.drawnTile.suit && t.rank === me.drawnTile.rank) return true;
      return false;
    });
    
    if (drawnIndex >= 0) {
      drawnObj = origTiles[drawnIndex];
      // å…¶ä»–ç‰Œæ’åºé¡¯ç¤º
      displayRest = origTiles.filter((_, idx) => idx !== drawnIndex)
        .sort((a, b) => tileSortKey(a.tile) - tileSortKey(b.tile));
    } else if (me.hand.length > 0) {
      // å¦‚æœæ‰¾ä¸åˆ°ï¼Œä½¿ç”¨æœ€å¾Œä¸€å¼µç‰Œï¼ˆå› ç‚ºdrawä½¿ç”¨pushï¼‰
      const lastIdx = me.hand.length - 1;
      drawnObj = origTiles[lastIdx];
      displayRest = origTiles.slice(0, -1)
        .sort((a, b) => tileSortKey(a.tile) - tileSortKey(b.tile));
    }
  }
  
  // å¦‚æœæ²’æœ‰æ‘¸åˆ°çš„ç‰Œï¼Œæ‰€æœ‰ç‰Œéƒ½æ’åºé¡¯ç¤º
  if (!drawnObj) {
    displayRest = origTiles.slice().sort((a, b) => tileSortKey(a.tile) - tileSortKey(b.tile));
  }
  
  let handHTML = '';
  // å…ˆé¡¯ç¤ºå…¶ä»–ç‰Œï¼ˆå·²æ’åºï¼‰
  displayRest.forEach(item => {
    const t = item.tile;
    const idx = item.index;
    const k = tileKey(t);
    const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
    handHTML += `<div class="tile tile-md suit-${t.suit} ${isGold ? 'gold' : ''}" onclick="onClickYourTile(${idx})">${keyToText(k)}</div>`;
  });
  
  // æ‘¸åˆ°çš„ç‰Œå§‹çµ‚é¡¯ç¤ºåœ¨æœ€å³å´
  if (drawnObj) {
    const t = drawnObj.tile;
    const idx = drawnObj.index;
    const k = tileKey(t);
    const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
    handHTML += `<div style="width: 12px; flex-shrink: 0;"></div>`;
    handHTML += `<div class="tile tile-md drawn suit-${t.suit} ${isGold ? 'gold' : ''}" onclick="onClickYourTile(${idx})">${keyToText(k)}</div>`;
  }
  
  const handElement = document.getElementById('yourHand');
  handElement.innerHTML = handHTML;
  
  // å¦‚æœæœ‰æ‘¸åˆ°çš„ç‰Œï¼Œè‡ªå‹•æ»¾å‹•åˆ°æœ€å³å´é¡¯ç¤º
  if (drawnObj) {
    requestAnimationFrame(() => {
      handElement.scrollLeft = handElement.scrollWidth;
    });
  }
  
  // æˆ‘çš„å‰¯éœ²
  let meldsHTML = '';
  if (me.melds.length > 0) {
    meldsHTML = me.melds.map(m => {
      let label = '';
      if (m.type === 'pong') label = 'ç¢°';
      if (m.type === 'kong') label = m.concealed ? 'æš—æ§“' : 'æ§“';
      if (m.type === 'chow') label = 'åƒ';
      
      let tilesForDisp;
      if (m.type === 'chow' && typeof m.centerIdx === 'number') {
        const arr = m.tiles.slice();
        const center = arr.splice(m.centerIdx, 1)[0];
        const lower = arr[0];
        const higher = arr[1];
        tilesForDisp = [lower, center, higher];
      } else {
        tilesForDisp = m.tiles;
      }
      
      const tilesHTML = tilesForDisp.map(t => {
        const k = tileKey(t);
        const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
        return `<span class="tile tile-sm suit-${t.suit} ${isGold ? 'gold' : ''}">${keyToText(k)}</span>`;
      }).join('');
      
      return `<div class="meld-badge"><span class="meld-label">${label}</span>${tilesHTML}</div>`;
    }).join('');
  }
  document.getElementById('yourMelds').innerHTML = meldsHTML;
  
  // æŒ‰éˆ•ç‹€æ…‹
  const btnHu = document.getElementById('btnHu');
  btnHu.disabled = true;
  if (S.turn === 0 && S.phase !== 'end') {
    const total = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    const expectedFull = (S.dealer === 0 ? 17 : 16) + kongCount;
    if (total === expectedFull && me.hand.length > 0) {
      const lastTile = me.hand[me.hand.length - 1];
      if (isWinningNow(me.hand, me.melds, lastTile)) {
        btnHu.disabled = false;
      }
    }
  }
  
  // è½ç‰ŒæŒ‰éˆ•
  let canListenBtn = false;
  if (me.declaredListen) {
    canListenBtn = false;
  } else if (S.turn === 0 && S.phase !== 'end' && S.waitReact === null) {
    const totalTilesMe = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    const expectedFull = (S.dealer === 0 ? 17 : 16) + kongCount;
    const expectedEmpty = (S.dealer === 0 ? 16 : 15) + kongCount;
    
    // å¦‚æœæ‰‹ç‰Œæ˜¯æ»¿çš„ï¼ˆå‰›æ‘¸åˆ°ç‰Œï¼‰ï¼Œæª¢æŸ¥ä¸Ÿæ‰ä¸€å¼µå¾Œæ˜¯å¦èƒ½è½ç‰Œ
    if (totalTilesMe === expectedFull) {
      canListenBtn = me.hand.some(tile => {
        const testHand = me.hand.filter(t => t !== tile);
        return isListening(testHand, me.melds);
      });
    }
    // å¦‚æœæ‰‹ç‰Œæ˜¯ç©ºçš„ï¼ˆå·²ç¶“ä¸Ÿéç‰Œï¼‰ï¼Œæª¢æŸ¥ç•¶å‰æ˜¯å¦å·²ç¶“è½ç‰Œ
    else if (totalTilesMe === expectedEmpty) {
      canListenBtn = isListening(me.hand, me.melds);
    }
  }
  document.getElementById('btnListen').disabled = !canListenBtn;
  
  // æ§“æŒ‰éˆ•
  const btnKong = document.getElementById('btnKong');
  if (S.turn === 0 && S.phase !== 'end' && S.waitReact === null) {
    const cks = canConcealedKong(0);
    const aks = canAddedKong(0);
    btnKong.disabled = (cks.length === 0 && aks.length === 0);
  } else {
    btnKong.disabled = true;
  }
}

function showHandsAndContinue() {
  const overlay = document.getElementById('modalOverlay');
  const content = document.getElementById('modalContent');
  
  let html = '';
  
  if (S.winner !== null) {
    const detail = calcFanDetails(S.winner, S.winTile, S.fromPlayer === -1);
    const catStr = detail.categories.join('ã€');
    const winnerName = playerName(S.winner);
    
    if (S.fromPlayer === -1) {
      html += `<div class="modal-title">ğŸ‰ ${winnerName} è‡ªæ‘¸èƒ¡ç‰Œ</div>`;
    } else {
      const loserName = playerName(S.fromPlayer);
      html += `<div class="modal-title">ğŸ‰ ${winnerName} é»èƒ¡</div>`;
      html += `<div style="text-align: center; color: var(--accent-red); margin-bottom: 12px;">æ”¾æ§ï¼š${loserName}</div>`;
    }
    html += `<div style="text-align: center; color: var(--accent-jade); font-size: 16px; margin-bottom: 16px;">${catStr}ï¼Œå…± <strong>${detail.fan}</strong> å°</div>`;
  } else {
    html += '<div class="modal-title">ğŸš« æµå±€</div>';
    html += '<div style="text-align: center; color: var(--text-secondary); margin-bottom: 16px;">ç‰Œå±±æ¯ç«­</div>';
  }
  
  html += '<div class="modal-section-title">æ‰€æœ‰ç©å®¶æ‰‹ç‰Œ</div>';
  
  for (let i = 0; i < 4; i++) {
    const p = S.players[i];
    const name = playerName(i);
    const isWinner = (S.winner === i);
    
    html += `<div class="modal-player ${isWinner ? 'winner' : ''}">`;
    html += `<div class="modal-player-header">
      <span class="modal-player-name">${isWinner ? 'ğŸ† ' : ''}${name}</span>
      <span class="modal-player-score">${p.points.toLocaleString()}</span>
    </div>`;
    
    html += '<div class="modal-hand">';
    const sortedHand = p.hand.slice().sort((a, b) => tileSortKey(a) - tileSortKey(b));
    sortedHand.forEach(t => {
      const k = tileKey(t);
      const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
      html += `<div class="tile tile-sm suit-${t.suit} ${isGold ? 'gold' : ''}">${keyToText(k)}</div>`;
    });
    html += '</div>';
    
    if (p.melds.length > 0) {
      html += '<div style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px;">';
      p.melds.forEach(m => {
        html += '<div style="display: flex; gap: 2px;">';
        m.tiles.forEach(t => {
          const k = tileKey(t);
          const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
          html += `<div class="tile tile-sm suit-${t.suit} ${isGold ? 'gold' : ''}">${keyToText(k)}</div>`;
        });
        html += '</div>';
      });
      html += '</div>';
    }
    
    html += '</div>';
  }
  
  html += '<button class="modal-btn" id="btnContinueNext">â–¶ï¸ ç¹¼çºŒä¸‹ä¸€å±€</button>';
  
  content.innerHTML = html;
  overlay.classList.add('show');
  
  document.getElementById('btnContinueNext').onclick = () => {
    overlay.classList.remove('show');
    log('â€”â€” é–‹ä¸‹ä¸€å±€ â€”â€”');
    startNewHand();
  };
}

function showFinalScore() {
  S.phase = 'end';
  renderAll();
  
  const overlay = document.getElementById('modalOverlay');
  const content = document.getElementById('modalContent');
  
  const rankings = S.players.map((p, i) => ({ name: playerName(i), points: p.points, index: i }))
    .sort((a, b) => b.points - a.points);
  
  let html = '<div class="modal-title">ğŸ† éŠæˆ²çµæŸ</div>';
  html += '<div class="modal-section">';
  
  const medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', '4ï¸âƒ£'];
  rankings.forEach((r, rank) => {
    html += `<div style="display: flex; justify-content: space-between; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px; margin-bottom: 8px;">
      <span>${medals[rank]} ${r.name}</span>
      <span style="color: var(--accent-jade); font-weight: 700;">${r.points.toLocaleString()}</span>
    </div>`;
  });
  
  html += '</div>';
  html += '<button class="modal-btn" id="btnNewGame">ğŸ® é–‹å§‹æ–°éŠæˆ²</button>';
  
  content.innerHTML = html;
  overlay.classList.add('show');
  
  document.getElementById('btnNewGame').onclick = () => {
    overlay.classList.remove('show');
    document.getElementById('log').innerHTML = '';
    dealerStreak = 0;
    startNewHand(true);
  };
}

/* ========= äº‹ä»¶ç¶å®š ========= */
document.getElementById('btnHu').onclick = () => {
  initAudio();
  if (S.currentReactions) {
    handleHuClick();
  } else {
    const me = S.players[0];
    const kongCount = countKongs(me);
    const expectedFull = (S.dealer === 0 ? 17 : 16) + kongCount;
    const total = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    if (total === expectedFull && me.hand.length > 0) {
      const lastTile = me.hand[me.hand.length - 1];
      if (isWinningNow(me.hand, me.melds, lastTile)) {
        doWin(0, -1, lastTile, true);
      }
    }
  }
};

document.getElementById('btnListen').onclick = () => {
  initAudio();
  if (S.turn !== 0 || S.phase === 'end') return;
  const me = S.players[0];
  if (me.declaredListen) return;
  
  const kongCount = countKongs(me);
  const total = me.hand.length + me.melds.reduce((s, m) => s + m.tiles.length, 0);
  const expectedFull = (S.dealer === 0 ? 17 : 16) + kongCount;
  const expectedEmpty = (S.dealer === 0 ? 16 : 15) + kongCount;
  
  let canListen = false;
  if (total === expectedFull) {
    canListen = me.hand.some(tile => {
      const testHand = me.hand.filter(t => t !== tile);
      return isListening(testHand, me.melds);
    });
  } else if (total === expectedEmpty) {
    canListen = isListening(me.hand, me.melds);
  }
  
  if (!canListen) {
    log('âš ï¸ ä½ é‚„æ²’æœ‰è½ç‰Œï¼Œç„¡æ³•å ±è½');
    return;
  }
  
  me.declaredListen = true;
  me.tingLocked = false;
  updateTianDiTing(0);
  const waits = calcWaitingTiles(me.hand, me.melds);
  me.waitKeys = waits.slice();
  const waitText = waits.map(k => keyToText(k)).join(' ');
  log('ğŸ”” ä½ å ±è½äº†ï¼');
  log('ğŸ‘‚ ç­‰ç‰Œï¼š' + waitText);
  log('âš ï¸ è«‹é¸æ“‡ä¸€å¼µæ‰‹ç‰Œæ‰“å‡ºä»¥å®Œæˆè½ç‰Œ');
  SoundEffects.listen();
  showEffect('ğŸ”” è½ç‰Œ', '#2dd4bf', '44px');
  renderAll();
};

document.getElementById('btnKong').onclick = () => {
  initAudio();
  if (S.turn !== 0 || S.phase === 'end' || S.lastDiscard !== null) return;
  const me = S.players[0];
  const added = canAddedKong(0);
  const concealed = canConcealedKong(0);
  
  if (added.length > 0) {
    const cand = added[0];
    // æ¶æ§“æª¢æŸ¥å·²ç¶“åœ¨doAddedKongå…§éƒ¨é€²è¡Œ
    doAddedKong(0, cand.meldIndex);
    return;
  }
  
  if (concealed.length > 0) {
    const key = concealed[0];
    doConcealedKong(0, key);
    return;
  }
};

document.getElementById('newGameBtn').onclick = () => {
  initAudio();
  S = { players: Array.from({ length: 4 }, () => ({ points: RULES.initialPoints })) };
  document.getElementById('log').innerHTML = '';
  dealerStreak = 0;
  startNewHand(true);
};

document.getElementById('btnChow').onclick = () => {
  initAudio();
  handleChowClick();
};

document.getElementById('btnPong').onclick = () => {
  initAudio();
  handlePongClick();
};

document.getElementById('btnPass').onclick = () => {
  initAudio();
  handlePassClick();
};

function onClickYourTile(idx) {
  initAudio();
  if (S.turn !== 0 || S.phase === 'end') return;
  const me = S.players[0];
  
  if (S.waitReact !== null) {
    log('âš ï¸ è«‹å…ˆé¸æ“‡åƒã€ç¢°ã€æ§“æˆ–é');
    return;
  }
  
  if (me.declaredListen && !me.tingLocked) {
    const tile = me.hand[idx];
    const afterDiscard = me.hand.filter(t => t !== tile);
    if (!isListening(afterDiscard, me.melds)) {
      log('âš ï¸ å ±è½å¾Œåªèƒ½ä¸Ÿæœƒå½¢æˆè½ç‰Œçš„æ‰‹ç‰Œ');
      return;
    }
  }
  
  if (me.declaredListen && me.tingLocked) {
    if (me.drawnTile) {
      const selected = me.hand[idx];
      if (selected !== me.drawnTile) {
        log('âš ï¸ å·²é–å®šè½ç‰Œï¼Œåªèƒ½æ‰“å‰›æ‘¸çš„ç‰Œ');
        return;
      }
    } else {
      // å¦‚æœå‰›æ‘¸åˆ°ç‰Œï¼Œåªèƒ½æ‰“æ‘¸åˆ°çš„ç‰Œ
      if (me.drawnTile && me.hand.includes(me.drawnTile)) {
        const drawnIdx = me.hand.findIndex(t => t === me.drawnTile);
        if (idx !== drawnIdx) {
          log('âš ï¸ å·²é–å®šè½ç‰Œï¼Œåªèƒ½æ‰“å‰›æ‘¸çš„ç‰Œ');
          return;
        }
      }
    }
  }
  
  const tile = me.hand[idx];
  discard(0, tile);
  
  if (me.declaredListen && !me.tingLocked) {
    me.tingLocked = true;
    log('ğŸ”’ è½ç‰Œå·²é–å®šï¼Œä¹‹å¾Œåªèƒ½æ‰“æ‘¸åˆ°çš„ç‰Œ');
  }
}

/* ========= å•Ÿå‹•éŠæˆ² ========= */
startNewHand(true);
</script>
</body>
</html>
