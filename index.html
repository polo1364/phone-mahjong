<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>éº»å°‡å–®æ©Ÿï¼ˆæ‰‹æ©Ÿé€£ç·šç‰ˆï¼‰</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700;900&display=swap" rel="stylesheet">
<script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
<style>
:root {
  --bg-primary: #f0f4f8;
  --bg-secondary: #ffffff;
  --bg-card: #f8fafc;
  --accent-gold: #fbbf24;
  --accent-jade: #10b981;
  --accent-red: #ef4444;
  --accent-blue: #3b82f6;
  --accent-green: #22c55e;
  --accent-pink: #ec4899;
  --accent-purple: #a855f7;
  --text-primary: #1e293b;
  --text-secondary: #64748b;
  --border-subtle: rgba(0,0,0,0.08);
  --glow-gold: rgba(251,191,36,0.3);
  --glow-jade: rgba(16,185,129,0.3);
  --shadow-light: rgba(0,0,0,0.05);
  --shadow-medium: rgba(0,0,0,0.1);
  
  --tile-wan: #dc2626;
  --tile-tong: #2563eb;
  --tile-tiao: #16a34a;
  --tile-zi: #78350f;
  
  --safe-bottom: env(safe-area-inset-bottom, 0px);
  --safe-top: env(safe-area-inset-top, 0px);
}

* {
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
}

html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  overscroll-behavior: none;
  height: 100vh;
  height: 100dvh;
  width: 100vw;
  width: 100dvw;
}

body {
  font-family: 'Noto Sans TC', system-ui, -apple-system, sans-serif;
  background: linear-gradient(135deg, #f0f4f8 0%, #e0e7ff 50%, #fef3c7 100%);
  background-attachment: fixed;
  color: var(--text-primary);
  height: 100vh;
  height: 100dvh;
  display: flex;
  flex-direction: column;
  padding-top: var(--safe-top);
  padding-bottom: var(--safe-bottom);
  overflow: hidden;
}

/* ===== é ‚éƒ¨ç‹€æ…‹åˆ— ===== */
.status-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  padding-top: calc(12px + var(--safe-top));
  background: rgba(255,255,255,0.95);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border-bottom: 1px solid var(--border-subtle);
  box-shadow: 0 2px 12px var(--shadow-light);
  position: sticky;
  top: 0;
  z-index: 100;
  flex-wrap: wrap;
  gap: 8px;
  flex-shrink: 0;
}

.round-badge {
  display: flex;
  align-items: center;
  gap: 6px;
  background: linear-gradient(135deg, var(--accent-gold) 0%, #f59e0b 100%);
  color: white;
  padding: 8px 16px;
  border-radius: 24px;
  font-weight: 700;
  font-size: 14px;
  box-shadow: 0 4px 12px var(--glow-gold);
}

.remain-badge {
  display: flex;
  align-items: center;
  gap: 4px;
  background: rgba(255,255,255,0.8);
  padding: 8px 14px;
  border-radius: 20px;
  font-size: 13px;
  color: var(--text-secondary);
  border: 1px solid var(--border-subtle);
  box-shadow: 0 2px 8px var(--shadow-light);
}

.remain-badge strong {
  color: var(--accent-jade);
  font-size: 16px;
}


/* ===== å°æ‰‹å€åŸŸ ===== */
.opponents-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 12px 12px;
  overflow: visible;
  min-height: 0;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
}

.opponent-card {
  background: rgba(255,255,255,0.9);
  border: 2px solid var(--border-subtle);
  border-radius: 16px;
  padding: 12px 14px;
  transition: all 0.3s ease;
  flex: 1 1 auto;
  min-height: 0;
  display: flex;
  flex-direction: column;
  box-shadow: 0 2px 8px var(--shadow-light);
  overflow: visible;
}

.opponent-card.active-turn {
  border-color: var(--accent-gold);
  background: linear-gradient(135deg, #fef3c7 0%, #ffffff 100%);
  box-shadow: 0 4px 20px var(--glow-gold), 0 0 0 3px rgba(251,191,36,0.2);
  transform: scale(1.02);
}

.opponent-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
}

.opponent-name {
  display: flex;
  align-items: center;
  gap: 10px;
  font-weight: 700;
  font-size: 15px;
  color: var(--text-primary);
}

.wind-icon {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, var(--accent-jade) 0%, #059669 100%);
  color: white;
  border-radius: 10px;
  font-weight: 800;
  font-size: 15px;
  box-shadow: 0 3px 10px var(--glow-jade);
}

.dealer-mark {
  background: linear-gradient(135deg, var(--accent-gold) 0%, #d4a03a 100%);
  color: var(--bg-primary);
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 10px;
  font-weight: 700;
  display: inline-flex;
  align-items: center;
  gap: 4px;
}

.streak-mark {
  background: rgba(0, 0, 0, 0.2);
  color: var(--bg-primary);
  padding: 1px 4px;
  border-radius: 6px;
  font-size: 9px;
  font-weight: 800;
  margin-left: 2px;
}

.listen-mark {
  background: linear-gradient(135deg, var(--accent-red) 0%, #dc2626 100%);
  color: white;
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 10px;
  font-weight: 700;
  animation: pulse-listen 2s infinite;
}

@keyframes pulse-listen {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.opponent-score {
  font-weight: 800;
  font-size: 16px;
  color: var(--accent-jade);
  text-shadow: 0 1px 2px var(--shadow-light);
}

.opponent-content {
  display: flex;
  flex-direction: column;
  gap: 6px;
  align-items: flex-start;
  width: 100%;
  flex: 1 1 auto;
  min-height: 0;
  overflow: visible;
}

.discard-zone {
  flex: 0 0 auto;
  min-height: 36px;
  width: 100%;
  background: rgba(241,245,249,0.8);
  border: 1px solid var(--border-subtle);
  border-radius: 10px;
  padding: 6px;
  display: flex;
  flex-wrap: wrap;
  gap: 3px;
  align-content: flex-start;
  overflow: visible;
}

.discard-zone-label {
  font-size: 9px;
  color: var(--text-secondary);
  margin-bottom: 4px;
  display: block;
  width: 100%;
}

.meld-zone {
  width: 100%;
  flex: 0 0 auto;
  min-height: 36px;
  background: rgba(241,245,249,0.8);
  border: 1px solid var(--border-subtle);
  border-radius: 10px;
  padding: 6px;
  display: flex;
  flex-wrap: wrap;
  gap: 3px;
  align-content: flex-start;
  overflow: visible;
}

.meld-group {
  display: flex;
  gap: 3px;
  padding: 4px 6px;
  background: linear-gradient(135deg, rgba(16,185,129,0.1) 0%, rgba(16,185,129,0.05) 100%);
  border: 1px solid rgba(16,185,129,0.2);
  border-radius: 8px;
  flex-shrink: 0;
}

/* ===== ç‰Œé¢æ¨£å¼ ===== */
.tile {
  background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);
  border: 2px solid #e2e8f0;
  border-radius: 8px;
  font-weight: 700;
  text-align: center;
  box-shadow: 0 3px 6px var(--shadow-light), inset 0 1px 0 rgba(255,255,255,0.9);
  user-select: none;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.tile-xs {
  min-width: 22px;
  height: 28px;
  font-size: 11px;
  padding: 2px;
}

.tile-sm {
  min-width: 28px;
  height: 36px;
  font-size: 13px;
  padding: 3px;
}

.tile-md {
  min-width: 36px;
  width: 36px;
  height: 48px;
  font-size: 16px;
  padding: 4px;
  cursor: pointer;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  flex-shrink: 0;
}

.tile-md:hover {
  transform: translateY(-4px);
  box-shadow: 0 8px 16px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.8);
}

.tile-md:active {
  transform: translateY(-2px) scale(0.98);
}

/* è§¸æ§è¨­å‚™å„ªåŒ– */
@media (hover: none) {
  .tile-md:hover {
    transform: none;
  }
}

/* èŠ±è‰²é¡è‰² */
.tile.suit-W { color: var(--tile-wan); }
.tile.suit-T { color: var(--tile-tong); }
.tile.suit-B { color: var(--tile-tiao); }
.tile.suit-F, .tile.suit-D { color: var(--tile-zi); }


/* æ‘¸åˆ°çš„ç‰Œ */
.tile.drawn {
  border: 3px solid var(--accent-gold);
  background: linear-gradient(180deg, #fef3c7 0%, #ffffff 100%);
  box-shadow: 0 4px 12px var(--glow-gold), 0 0 0 2px rgba(251,191,36,0.3);
  transform: scale(1.05);
}

/* ===== æˆ°æ³é¢æ¿ ===== */
.log-panel {
  background: rgba(255,255,255,0.95);
  border-top: 2px solid var(--border-subtle);
  padding: 0;
  flex: 0 0 auto;
  max-height: 120px;
  min-height: 80px;
  display: flex;
  flex-direction: column;
  position: relative;
  box-shadow: 0 -2px 12px var(--shadow-light);
}

.log-header {
  padding: 8px 14px;
  font-size: 12px;
  color: var(--text-secondary);
  font-weight: 700;
  border-bottom: 1px solid var(--border-subtle);
  flex-shrink: 0;
  background: rgba(241,245,249,0.8);
}

#log {
  font-size: 12px;
  line-height: 1.7;
  color: var(--text-primary);
  padding: 10px 14px;
  overflow-y: auto;
  overflow-x: hidden;
  flex: 1;
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
  display: flex;
  flex-direction: column;
}

#log::-webkit-scrollbar {
  width: 4px;
}

#log::-webkit-scrollbar-track {
  background: transparent;
}

#log::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.2);
  border-radius: 2px;
}

#log .my-log {
  color: var(--accent-jade);
}

/* ===== æˆ‘çš„æ‰‹ç‰Œå€ ===== */
.my-hand-area {
  background: linear-gradient(180deg, rgba(255,255,255,0.98) 0%, rgba(248,250,252,0.95) 100%);
  border-top: 3px solid var(--accent-jade);
  padding: 10px 8px calc(12px + var(--safe-bottom));
  box-shadow: 0 -4px 24px var(--shadow-medium);
  position: relative;
  z-index: 10;
  flex-shrink: 0;
}

.hand-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  padding: 0 4px;
  gap: 8px;
  flex-wrap: wrap;
}

.hand-title-wrapper {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  min-width: 0;
}

.my-discard-zone {
  flex: 1 1 auto;
  min-width: 100px;
  min-height: 32px;
  background: rgba(241,245,249,0.8);
  border: 1px solid var(--border-subtle);
  border-radius: 10px;
  padding: 4px 6px;
  display: flex;
  flex-wrap: wrap;
  gap: 2px;
  align-content: flex-start;
  overflow: visible;
}

.hand-title {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 700;
  font-size: 14px;
}

.hand-title .wind-icon {
  background: linear-gradient(135deg, var(--accent-gold) 0%, #f59e0b 100%);
  box-shadow: 0 3px 10px var(--glow-gold);
}

.my-score {
  font-size: 20px;
  font-weight: 900;
  color: var(--accent-jade);
  text-shadow: 0 2px 4px var(--shadow-light);
}

.listen-hint {
  text-align: center;
  font-size: 12px;
  color: var(--accent-gold);
  margin-bottom: 8px;
  font-weight: 600;
}

.hand-tiles {
  display: flex;
  justify-content: flex-start;
  gap: 3px;
  flex-wrap: nowrap;
  margin-bottom: 8px;
  padding: 4px 0;
  min-height: 56px;
  align-items: center;
  overflow-x: auto;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,0.2) transparent;
}

.hand-tiles::-webkit-scrollbar {
  height: 4px;
}

.hand-tiles::-webkit-scrollbar-track {
  background: transparent;
}

.hand-tiles::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.2);
  border-radius: 2px;
}

.my-melds {
  display: flex;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
  margin-bottom: 8px;
}

.meld-badge {
  display: flex;
  align-items: center;
  gap: 4px;
  background: rgba(45,212,191,0.15);
  border: 1px solid rgba(45,212,191,0.3);
  border-radius: 8px;
  padding: 6px 8px;
}

.meld-label {
  font-size: 10px;
  color: var(--accent-jade);
  font-weight: 600;
}

/* ===== æ§åˆ¶æŒ‰éˆ• ===== */
.controls-bar {
  display: flex;
  gap: 4px;
  padding: 6px 4px;
  flex-wrap: wrap;
  justify-content: center;
  -webkit-overflow-scrolling: touch;
}

.btn {
  flex: 1;
  min-width: 50px;
  max-width: 85px;
  padding: 8px 6px;
  border: none;
  border-radius: 10px;
  font-size: 11px;
  font-weight: 700;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1px;
  touch-action: manipulation;
  -webkit-tap-highlight-color: rgba(255,255,255,0.1);
  user-select: none;
}

.btn:disabled {
  opacity: 0.35;
  cursor: not-allowed;
  transform: none !important;
}

.btn-primary {
  background: linear-gradient(135deg, var(--accent-jade) 0%, #059669 100%);
  color: white;
  box-shadow: 0 4px 12px var(--glow-jade);
}

.btn-primary:not(:disabled):active {
  transform: scale(0.95);
}

.btn-secondary {
  background: rgba(255,255,255,0.9);
  color: var(--text-primary);
  border: 2px solid var(--border-subtle);
  box-shadow: 0 2px 8px var(--shadow-light);
}

.btn-secondary:not(:disabled):active {
  transform: scale(0.95);
  background: var(--bg-secondary);
}

.btn-gold {
  background: linear-gradient(135deg, var(--accent-gold) 0%, #f59e0b 100%);
  color: white;
  box-shadow: 0 4px 12px var(--glow-gold);
}

.btn-gold:not(:disabled):active {
  transform: scale(0.95);
}

.btn-danger {
  background: linear-gradient(135deg, var(--accent-red) 0%, #dc2626 100%);
  color: white;
  box-shadow: 0 4px 12px rgba(239,68,68,0.3);
}

.btn.active {
  animation: btn-glow 1s ease-in-out infinite;
  transform: scale(1.08);
  border: 3px solid var(--accent-gold) !important;
  box-shadow: 0 0 25px var(--glow-gold), 0 4px 20px rgba(251,191,36,0.5) !important;
  z-index: 10;
  position: relative;
}

@keyframes btn-glow {
  0%, 100% { 
    box-shadow: 0 0 25px var(--glow-gold), 0 4px 20px rgba(251,191,36,0.5);
    border-color: var(--accent-gold);
  }
  50% { 
    box-shadow: 0 0 40px var(--glow-gold), 0 0 50px rgba(251,191,36,0.7), 0 6px 30px rgba(251,191,36,0.6);
    border-color: #fbbf24;
  }
}

.btn-icon {
  font-size: 16px;
}

.btn-text {
  font-size: 9px;
}

/* ===== å½ˆçª— ===== */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.4);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  z-index: 200;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 20px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.modal-overlay.show {
  display: flex;
}

/* å¼ºåˆ¶éšè—è¿çº¿é¢æ¿ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰ */
#onlinePanel[style*="display: none"] {
  display: none !important;
}

.modal-content {
  background: rgba(255,255,255,0.98);
  border: 2px solid var(--border-subtle);
  border-radius: 24px;
  padding: 28px;
  max-width: 90%;
  max-height: 85vh;
  overflow-y: auto;
  box-shadow: 0 20px 60px var(--shadow-medium);
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
  margin: auto;
}

.modal-title {
  font-size: 20px;
  font-weight: 800;
  color: var(--accent-gold);
  margin-bottom: 16px;
  text-align: center;
}

.modal-section {
  margin-bottom: 16px;
}

.modal-section-title {
  font-size: 14px;
  font-weight: 700;
  color: var(--accent-jade);
  margin-bottom: 8px;
}

.modal-player {
  background: rgba(0,0,0,0.2);
  border-radius: 12px;
  padding: 12px;
  margin-bottom: 12px;
}

.modal-player.winner {
  border: 2px solid var(--accent-gold);
  box-shadow: 0 0 20px var(--glow-gold);
}

.modal-player-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.modal-player-name {
  font-weight: 700;
  font-size: 15px;
}

.modal-player-score {
  color: var(--accent-jade);
  font-weight: 700;
}

.modal-hand {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin-top: 8px;
}

.modal-btn {
  width: 100%;
  padding: 16px;
  margin-top: 16px;
  background: linear-gradient(135deg, var(--accent-jade) 0%, #14b8a6 100%);
  color: var(--bg-primary);
  border: none;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 700;
  font-family: inherit;
  cursor: pointer;
  box-shadow: 0 4px 16px var(--glow-jade);
}

.modal-btn:active {
  transform: scale(0.98);
}

/* ===== é«˜ç´šç‰¹æ•ˆ ===== */
.effect-overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 300;
  perspective: 1000px;
}

.effect-text {
  font-size: 48px;
  font-weight: 900;
  text-shadow: 
    0 0 20px currentColor,
    0 0 40px currentColor,
    0 0 60px currentColor,
    0 0 80px currentColor;
  animation: effect-pop-advanced 1.2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
  filter: drop-shadow(0 0 20px currentColor);
  transform-style: preserve-3d;
}

@keyframes effect-pop-advanced {
  0% { 
    transform: scale(0.2) rotateY(-180deg) rotateX(20deg) translateZ(-150px);
    opacity: 0;
    filter: blur(15px) brightness(2);
  }
  25% {
    transform: scale(1.4) rotateY(10deg) rotateX(-5deg) translateZ(30px);
    opacity: 1;
    filter: blur(2px) brightness(1.5);
  }
  40% {
    transform: scale(1.15) rotateY(-5deg) rotateX(2deg) translateZ(15px);
    opacity: 1;
    filter: blur(0px) brightness(1.2);
  }
  60% {
    transform: scale(1.05) rotateY(2deg) rotateX(0deg) translateZ(0);
    opacity: 1;
    filter: blur(0px) brightness(1);
  }
  80% {
    transform: scale(0.95) rotateY(0deg) rotateX(0deg) translateZ(-20px);
    opacity: 0.8;
    filter: blur(2px) brightness(0.9);
  }
  100% { 
    transform: scale(0.7) rotateY(0deg) rotateX(10deg) translateZ(-80px);
    opacity: 0;
    filter: blur(8px) brightness(0.7);
  }
}

/* ç²’å­æ•ˆæœ */
.effect-particles {
  position: absolute;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.particle {
  position: absolute;
  width: 6px;
  height: 6px;
  background: currentColor;
  border-radius: 50%;
  animation: particle-float 1.5s ease-out forwards;
  box-shadow: 
    0 0 8px currentColor,
    0 0 16px currentColor,
    0 0 24px currentColor;
  transform: translate(-50%, -50%);
}

@keyframes particle-float {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(var(--tx, 0), var(--ty, -100px)) scale(0);
    opacity: 0;
  }
}

/* å…‰æšˆæ•ˆæœ */
.effect-glow {
  position: absolute;
  width: 200px;
  height: 200px;
  border-radius: 50%;
  background: radial-gradient(circle, currentColor 0%, transparent 70%);
  opacity: 0.6;
  animation: glow-pulse 1.2s ease-out forwards;
  filter: blur(20px);
}

@keyframes glow-pulse {
  0% {
    transform: scale(0.3) rotate(0deg);
    opacity: 0;
    filter: blur(15px);
  }
  30% {
    transform: scale(1.2) rotate(180deg);
    opacity: 0.9;
    filter: blur(10px);
  }
  60% {
    transform: scale(1.8) rotate(360deg);
    opacity: 0.6;
    filter: blur(15px);
  }
  100% {
    transform: scale(2.5) rotate(540deg);
    opacity: 0;
    filter: blur(25px);
  }
}

/* ===== éŸ¿æ‡‰å¼èª¿æ•´ ===== */
@media (max-width: 380px) {
  .status-bar {
    padding: 8px 12px;
    flex-wrap: wrap;
    gap: 6px;
  }
  
  .round-badge {
    font-size: 11px;
    padding: 5px 10px;
  }
  
  .remain-badge {
    font-size: 11px;
    padding: 5px 10px;
  }
  
  .remain-badge strong {
    font-size: 14px;
  }
  
  .tile-md {
    min-width: 30px;
    height: 42px;
    font-size: 13px;
    padding: 3px;
  }
  
  .tile-sm {
    min-width: 24px;
    height: 32px;
    font-size: 11px;
    padding: 2px;
  }
  
  .tile-xs {
    min-width: 18px;
    height: 24px;
    font-size: 9px;
    padding: 1px 3px;
  }
  
  .btn {
    min-width: 48px;
    max-width: 75px;
    padding: 8px 4px;
    font-size: 10px;
  }
  
  .btn-icon { font-size: 14px; }
  .btn-text { font-size: 8px; }
  
  .opponent-card {
    padding: 8px 10px;
  }
  
  .opponent-name {
    font-size: 12px;
  }
  
  .opponent-score {
    font-size: 13px;
  }
  
  .my-score {
    font-size: 16px;
  }
  
  .hand-title {
    font-size: 12px;
  }
  
  .modal-content {
    padding: 16px;
    max-width: 95%;
  }
  
  .modal-title {
    font-size: 18px;
  }
  
}

@media (max-width: 480px) {
  .controls-bar {
    gap: 4px;
    padding: 6px;
  }
  
  .btn {
    min-width: 60px;
    padding: 14px 8px;
    font-size: 12px;
  }
  
  .hand-tiles {
    gap: 3px;
  }
  
  .opponents-area {
    padding: 6px 10px;
    gap: 4px;
  }
  
  .discard-zone {
    min-height: 32px;
    padding: 4px;
    gap: 2px;
  }
  
  .log-panel {
    max-height: 90px;
    min-height: 60px;
  }
  
  .log-header {
    padding: 3px 10px;
    font-size: 9px;
  }
  
  #log {
    font-size: 10px;
    padding: 6px 10px;
  }
  
}

@media (min-width: 500px) {
  /* ä¿æŒå‚ç›´æ’åˆ—ï¼Œä¸æ”¹ä¸ºæ¨ªå‘ */
  .opponent-card {
    min-width: 200px;
  }
}

@media (min-width: 768px) {
  .opponent-card {
    min-width: 220px;
  }
  
  .tile-md {
    min-width: 40px;
    height: 52px;
    font-size: 17px;
  }
  
  .btn {
    min-width: 80px;
    padding: 14px 12px;
  }
}

/* è§¸æ§å„ªåŒ– */
@media (hover: none) and (pointer: coarse) {
  .tile-md {
    min-width: 36px;
    height: 48px;
    cursor: default;
  }
  
  .tile-md:active {
    transform: translateY(-2px) scale(0.97);
  }
  
  .btn {
    min-width: 50px;
    max-width: 80px;
    padding: 8px 6px;
    touch-action: manipulation;
  }
  
  .btn:active {
    transform: scale(0.95);
  }
  
  /* ç§»é™¤ hover æ•ˆæœï¼Œæ”¹ç”¨ active */
  .tile-md:hover {
    transform: none;
    box-shadow: 0 2px 4px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.8);
  }
}

/* æ©«å±æ¨¡å¼å„ªåŒ– */
@media (orientation: landscape) and (max-height: 600px) {
  .status-bar {
    padding: 6px 12px;
    padding-top: calc(6px + var(--safe-top));
  }
  
  .opponents-area {
    padding: 4px 8px;
  }
  
  .opponent-card {
    padding: 6px 8px;
  }
  
  .log-panel {
    max-height: 60px;
    min-height: 50px;
  }
  
  .log-header {
    padding: 2px 8px;
    font-size: 8px;
  }
  
  #log {
    padding: 4px 8px;
    font-size: 9px;
  }
  
  
  .my-hand-area {
    padding: 8px 6px calc(12px + var(--safe-bottom));
  }
  
  .hand-tiles {
    margin-bottom: 6px;
    min-height: 50px;
    flex-wrap: nowrap;
    overflow-x: auto;
    justify-content: flex-start;
  }
  
  .controls-bar {
    padding: 4px 2px;
    gap: 3px;
  }
  
  .btn {
    min-width: 45px;
    max-width: 70px;
    padding: 6px 4px;
    font-size: 9px;
    border-radius: 8px;
  }
  
  .btn-icon {
    font-size: 13px;
  }
  
  .btn-text {
    font-size: 7px;
  }
  
  .tile-md {
    min-width: 32px;
    height: 44px;
    font-size: 14px;
  }
}

/* å°ç‰Œåœ–ç¤ºï¼ˆç”¨æ–¼æˆ°æ³è¨˜éŒ„ï¼‰ */
.tile.log-tile {
  display: inline-flex;
  min-width: 32px;
  height: 40px;
  font-size: 16px;
  font-weight: 700;
  padding: 4px 6px;
  margin: 0 3px;
  vertical-align: middle;
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  border: 1px solid rgba(0,0,0,0.1);
}

/* éš±è—å…ƒç´  */
.hidden { display: none !important; }
</style>
</head>
<body>

<!-- æ¨¡å¼é¸æ“‡é¢æ¿ -->
<div id="modeSelectPanel" class="modal-overlay show">
  <div class="modal-content" style="max-width: 400px; text-align: center;">
    <div class="modal-title" style="font-size: 28px; margin-bottom: 24px;">ğŸ® éº»å°‡éŠæˆ²</div>
    <div style="margin: 32px 0;">
      <button class="btn btn-gold" onclick="startSinglePlayerMode()" style="width: 100%; padding: 16px; font-size: 18px; margin-bottom: 16px;">
        ğŸ¯ å–®æ©Ÿæ¨¡å¼
      </button>
      <button class="btn btn-secondary" onclick="startOnlineMode()" style="width: 100%; padding: 16px; font-size: 18px;">
        ğŸŒ é€£ç·šæ¨¡å¼
      </button>
    </div>
    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 24px;">
      <div>å–®æ©Ÿæ¨¡å¼ï¼šèˆ‡AIå°æˆ°</div>
      <div>é€£ç·šæ¨¡å¼ï¼šèˆ‡æœ‹å‹ä¸€èµ·ç©</div>
    </div>
  </div>
</div>

<!-- é€£ç·šæ¨¡å¼é¢æ¿ -->
<div id="onlinePanel" class="modal-overlay" style="display: none;">
  <div class="modal-content" style="max-width: 400px; max-height: 90vh; overflow-y: auto;">
    <div class="modal-title">ğŸ® é€£ç·šæ¨¡å¼</div>
    <div style="margin: 16px 0;">
      <label style="display: block; margin-bottom: 4px; font-size: 12px; color: var(--text-secondary);">æœå‹™å™¨åœ°å€</label>
      <input type="text" id="serverUrl" placeholder="https://web-production-c25c6.up.railway.app" value="https://web-production-c25c6.up.railway.app" style="width: 100%; padding: 8px; margin-bottom: 12px; border: 1px solid var(--border-subtle); border-radius: 6px; font-size: 14px;">
      <div style="font-size: 11px; color: var(--text-secondary); margin-top: 4px; line-height: 1.4;">
        ğŸ’¡ Railway æœå‹™å™¨ï¼šhttps://web-production-c25c6.up.railway.app<br>
        ğŸ’¡ æœ¬åœ°æ¸¬è©¦ï¼šhttp://localhost:3000 æˆ– http://ä½ çš„IP:3000
      </div>
      <label style="display: block; margin-bottom: 4px; font-size: 12px; color: var(--text-secondary);">ä½ çš„åå­—</label>
      <input type="text" id="playerName" placeholder="ä½ çš„åå­—" value="ç©å®¶" style="width: 100%; padding: 8px; margin-bottom: 12px; border: 1px solid var(--border-subtle); border-radius: 6px; font-size: 14px;">
    </div>
    <button class="btn btn-gold" onclick="createOnlineRoom()" style="width: 100%; margin-bottom: 8px;">å‰µå»ºæˆ¿é–“</button>
    <div style="margin: 16px 0;">
      <label style="display: block; margin-bottom: 4px; font-size: 12px; color: var(--text-secondary);">æˆ¿é–“ID</label>
      <input type="text" id="roomIdInput" placeholder="è¼¸å…¥æˆ¿é–“ID" style="width: 100%; padding: 8px; margin-bottom: 8px; border: 1px solid var(--border-subtle); border-radius: 6px; font-size: 14px; text-transform: uppercase;">
      <button class="btn btn-secondary" onclick="joinOnlineRoom()" style="width: 100%;">åŠ å…¥æˆ¿é–“</button>
    </div>
    <div id="roomIdDisplay" style="text-align: center; font-weight: 700; margin: 16px 0; color: var(--accent-jade); font-size: 18px;"></div>
    <div id="roomPlayers" style="margin: 16px 0; padding: 12px; background: rgba(241,245,249,0.5); border-radius: 8px;"></div>
    <button id="startGameBtn" class="btn btn-gold" onclick="startOnlineGame()" style="width: 100%; display: none; margin-bottom: 8px;">é–‹å§‹éŠæˆ²</button>
    <button class="btn btn-secondary" onclick="exitOnlineMode()" style="width: 100%;">é€€å‡ºé€£ç·šæ¨¡å¼</button>
  </div>
</div>

<!-- é ‚éƒ¨ç‹€æ…‹åˆ— -->
<div class="status-bar">
  <div class="round-badge">
    <span id="centerRound">æ±é¢¨æ±</span>
  </div>
  <div class="remain-badge">
    ğŸ´ å‰©é¤˜ <strong id="centerRemain">56</strong> å¼µ
  </div>
  <button class="btn btn-gold" id="newGameBtn" style="padding: 8px 12px; min-width: auto; flex: none; font-size: 12px;">
    <span style="font-size: 12px;">ğŸ® æ–°å±€</span>
  </button>
  <button class="btn btn-secondary" id="settingsBtn" style="padding: 8px 12px; min-width: auto; flex: none; font-size: 12px;">
    <span style="font-size: 12px;">âš™ï¸ è¨­å®š</span>
  </button>
  <button class="btn btn-secondary" id="saveBtn" style="padding: 8px 12px; min-width: auto; flex: none; font-size: 12px;">
    <span style="font-size: 12px;">ğŸ’¾ å­˜æª”</span>
  </button>
  <button class="btn btn-secondary" id="loadBtn" style="padding: 8px 12px; min-width: auto; flex: none; font-size: 12px;">
    <span style="font-size: 12px;">ğŸ“‚ è®€æª”</span>
  </button>
  <button class="btn btn-secondary" id="onlineBtn" style="padding: 8px 12px; min-width: auto; flex: none; font-size: 12px;">
    <span style="font-size: 12px;">ğŸŒ é€£ç·š</span>
  </button>
</div>


<!-- å°æ‰‹å€åŸŸ -->
<div class="opponents-area" id="opponentsArea">
  <!-- å‹•æ…‹ç”Ÿæˆ -->
</div>

<!-- æˆ°æ³è¨˜éŒ„ -->
<div class="log-panel">
  <div class="log-header">ğŸ“‹ æˆ°æ³è¨˜éŒ„</div>
  <div id="log"></div>
</div>

<!-- æˆ‘çš„æ‰‹ç‰Œå€ -->
<div class="my-hand-area">
  <div class="hand-header">
    <div class="hand-title-wrapper">
      <div class="hand-title">
        <div class="wind-icon" id="myWind">æ±</div>
        <span id="myName">ä½ </span>
        <span id="myDealerMark" class="dealer-mark hidden">èŠ</span>
        <span id="myListenMark" class="listen-mark hidden">è½</span>
      </div>
      <div class="my-discard-zone" id="myDiscardZone"></div>
    </div>
    <div class="my-score" id="myScore">100,000</div>
  </div>
  <div class="listen-hint hidden" id="listenHint"></div>
  <div class="hand-tiles" id="yourHand"></div>
  <div class="my-melds" id="yourMelds"></div>
  <div class="controls-bar" id="controls">
    <button class="btn btn-danger" id="btnHu" disabled>
      <span class="btn-icon">ğŸ‰</span>
      <span class="btn-text">èƒ¡ç‰Œ</span>
    </button>
    <button class="btn btn-secondary" id="btnChow" disabled>
      <span class="btn-icon">ğŸœ</span>
      <span class="btn-text">åƒ</span>
    </button>
    <button class="btn btn-secondary" id="btnPong" disabled>
      <span class="btn-icon">ğŸ”¥</span>
      <span class="btn-text">ç¢°</span>
    </button>
    <button class="btn btn-secondary" id="btnKong" disabled>
      <span class="btn-icon">ğŸ’¥</span>
      <span class="btn-text">æ§“</span>
    </button>
    <button class="btn btn-primary" id="btnListen" disabled>
      <span class="btn-icon">ğŸ””</span>
      <span class="btn-text">è½ç‰Œ</span>
    </button>
    <button class="btn btn-secondary" id="btnPass" disabled>
      <span class="btn-icon">â­ï¸</span>
      <span class="btn-text">é</span>
    </button>
  </div>
</div>

<!-- å½ˆçª— -->
<div class="modal-overlay" id="modalOverlay">
  <div class="modal-content" id="modalContent"></div>
</div>

<!-- éš±è—å…ƒç´  -->
<div id="scoreboard" style="display: none;"></div>
<div id="goldbar" style="display: none;"></div>
<div id="roundinfo" style="display: none;"></div>
<div id="table" style="display: none;"></div>
<div id="reactionPanel" style="display: none;"></div>
<div id="overlay" style="display: none;"></div>

<script>
/* ========= åŸºæœ¬å·¥å…· ========= */
const rng = (n) => Math.floor(Math.random() * n);
const clone = (o) => JSON.parse(JSON.stringify(o));

// é«˜ç´šéŸ³æ•ˆç³»çµ±
let audioCtx = null;
let soundEnabled = true;
let audioInitialized = false;

function initAudio() {
  if (!audioInitialized) {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
      audioInitialized = true;
    } catch (e) {
      soundEnabled = false;
    }
  }
}

// èªéŸ³æ’­å ±ç³»çµ±
let speechSynthesis = null;
let voiceEnabled = true;
let currentUtterance = null;

function initSpeech() {
  if ('speechSynthesis' in window) {
    speechSynthesis = window.speechSynthesis;
    voiceEnabled = true;
  } else {
    voiceEnabled = false;
  }
}

// åœæ­¢ç•¶å‰èªéŸ³
function stopSpeech() {
  if (speechSynthesis && currentUtterance) {
    speechSynthesis.cancel();
    currentUtterance = null;
  }
}

// èªéŸ³æ’­å ±å‡½æ•¸
function speakText(text, options = {}) {
  if (!voiceEnabled || !speechSynthesis) return;
  
  // åœæ­¢ä¹‹å‰çš„èªéŸ³
  stopSpeech();
  
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.lang = 'zh-TW';
  utterance.rate = options.rate || 1.0;
  utterance.pitch = options.pitch || 1.0;
  utterance.volume = options.volume || 0.8;
  
  // é¸æ“‡ä¸­æ–‡èªéŸ³
  const voices = speechSynthesis.getVoices();
  const chineseVoice = voices.find(v => v.lang.includes('zh') || v.lang.includes('TW') || v.lang.includes('CN')) || voices[0];
  if (chineseVoice) {
    utterance.voice = chineseVoice;
  }
  
  currentUtterance = utterance;
  speechSynthesis.speak(utterance);
  
  utterance.onend = () => {
    currentUtterance = null;
  };
  
  utterance.onerror = () => {
    currentUtterance = null;
  };
}

// èªéŸ³å…§å®¹åº«
const VoiceMessages = {
  chow: [
    'åƒï¼',
    'åƒç‰Œï¼',
    'æˆ‘åƒï¼',
    'åƒä¸€å¼µï¼',
    'åƒä½ ä¸€å¼µï¼',
    'åƒæ‰äº†ï¼',
    'é †å­ä¾†äº†ï¼'
  ],
  pong: [
    'ç¢°ï¼',
    'ç¢°ç‰Œï¼',
    'æˆ‘ç¢°ï¼',
    'ç¢°äº†ï¼',
    'ç¢°ä½ ä¸€å¼µï¼',
    'ä¸‰å¼µä¸€æ¨£ï¼',
    'ç¢°èµ·ä¾†ï¼'
  ],
  kong: [
    'æ§“ï¼',
    'æ§“ç‰Œï¼',
    'æˆ‘æ§“ï¼',
    'æ§“äº†ï¼',
    'å››å¼µä¸€æ¨£ï¼',
    'æ§“èµ·ä¾†ï¼',
    'å¤§æ§“ï¼'
  ],
  listen: [
    'è½ç‰Œï¼',
    'å ±è½ï¼',
    'æˆ‘è½ç‰Œäº†ï¼',
    'è½ç‰Œå›‰ï¼',
    'æº–å‚™èƒ¡ç‰Œï¼',
    'ç­‰ç‰Œäº†ï¼',
    'è½ç‰ŒæˆåŠŸï¼',
    'æº–å‚™è‡ªæ‘¸ï¼',
    'ç­‰èƒ¡ç‰Œï¼'
  ],
  win: [
    'èƒ¡äº†ï¼',
    'èƒ¡ç‰Œï¼',
    'æˆ‘èƒ¡äº†ï¼',
    'è‡ªæ‘¸ï¼',
    'é»èƒ¡ï¼',
    'å¤ªæ£’äº†ï¼',
    'è´äº†ï¼',
    'å‹åˆ©ï¼',
    'è‡ªæ‘¸èƒ¡ç‰Œï¼',
    'é»èƒ¡æˆåŠŸï¼',
    'å¤ªå²å®³äº†ï¼',
    'å®Œç¾ï¼'
  ],
  drawGame: [
    'æµå±€ï¼',
    'æµå±€äº†ï¼',
    'é€™å±€æµå±€ï¼',
    'æ²’äººèƒ¡ç‰Œï¼',
    'æµå±€çµæŸï¼',
    'å’Œå±€ï¼',
    'å¹³æ‰‹ï¼'
  ],
  newGame: [
    'æ–°å±€é–‹å§‹ï¼',
    'æ–°çš„ä¸€å±€ï¼',
    'é–‹å§‹æ–°å±€ï¼',
    'æº–å‚™é–‹å§‹ï¼',
    'æ–°å±€ä¾†äº†ï¼',
    'é‡æ–°é–‹å§‹ï¼',
    'æ–°çš„ä¸€è¼ªï¼'
  ],
  dealer: [
    'èŠå®¶ï¼',
    'æˆ‘æ˜¯èŠå®¶ï¼',
    'ç•¶èŠï¼',
    'èŠå®¶é€£èŠï¼',
    'æˆ‘ç•¶èŠï¼',
    'èŠå®¶æ˜¯æˆ‘ï¼'
  ],
  dealerStreak: [
    'é€£èŠï¼',
    'ç¹¼çºŒç•¶èŠï¼',
    'é€£èŠæˆåŠŸï¼',
    'èŠå®¶é€£èŠï¼',
    'åˆé€£èŠäº†ï¼',
    'ç¹¼çºŒé€£èŠï¼',
    'é€£èŠä¸­ï¼'
  ]
};

// éš¨æ©Ÿé¸æ“‡èªéŸ³
function getRandomVoice(type) {
  const messages = VoiceMessages[type];
  if (!messages || messages.length === 0) return '';
  return messages[Math.floor(Math.random() * messages.length)];
}

// å°‡ç‰Œåè½‰æ›ç‚ºèªéŸ³æ’­å ±æ ¼å¼
function tileNameForSpeech(tileText) {
  // ç‰¹æ®Šå­—ç‰Œçš„å¿µæ³•
  if (tileText === 'ä¸­') return 'ç´…ä¸­';
  if (tileText === 'ç™¼') return 'ç™¼è²¡';
  if (tileText === 'ç™½') return 'ç™½æ¿';
  // é¢¨å­—çš„å¿µæ³•
  if (tileText === 'æ±') return 'æ±é¢¨';
  if (tileText === 'å—') return 'å—é¢¨';
  if (tileText === 'è¥¿') return 'è¥¿é¢¨';
  if (tileText === 'åŒ—') return 'åŒ—é¢¨';
  // å…¶ä»–ç‰Œåä¿æŒä¸è®Š
  return tileText;
}

// èªéŸ³æ’­å ±å‡½æ•¸ï¼ˆå¸¶éš¨æ©Ÿé¸æ“‡ï¼‰
function speakRandom(type, customText = null) {
  const text = customText || getRandomVoice(type);
  if (text) {
    speakText(text, { rate: 1.0, pitch: 1.0, volume: 0.8 });
  }
}

// é«˜ç´šéŸ³æ•ˆï¼šå’Œå¼¦éŸ³æ•ˆ
function playChord(frequencies, duration, type = 'sine', volume = 0.15) {
  if (!soundEnabled) return;
  if (!audioInitialized) initAudio();
  if (!audioCtx) return;
  try {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const masterGain = audioCtx.createGain();
    masterGain.connect(audioCtx.destination);
    masterGain.gain.setValueAtTime(volume, audioCtx.currentTime);
    masterGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    
    frequencies.forEach((freq, idx) => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
      gain.connect(masterGain);
      osc.frequency.value = freq;
      osc.type = type;
      const delay = idx * 0.02;
      gain.gain.setValueAtTime(0, audioCtx.currentTime + delay);
      gain.gain.linearRampToValueAtTime(volume / frequencies.length, audioCtx.currentTime + delay + 0.05);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + delay + duration);
      osc.start(audioCtx.currentTime + delay);
      osc.stop(audioCtx.currentTime + delay + duration);
    });
  } catch (e) {}
}

// é«˜ç´šéŸ³æ•ˆï¼šå¸¶åŒ…çµ¡çš„éŸ³æ•ˆ
function playSound(freq, duration, type = 'sine', volume = 0.2, attack = 0.05, decay = 0.1) {
  if (!soundEnabled) return;
  if (!audioInitialized) initAudio();
  if (!audioCtx) return;
  try {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);
    
    osc.frequency.value = freq;
    osc.type = type;
    
    // é«˜ç´šåŒ…çµ¡ï¼šAttack -> Decay -> Sustain -> Release
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(volume, now + attack);
    gain.gain.linearRampToValueAtTime(volume * 0.7, now + attack + decay);
    gain.gain.linearRampToValueAtTime(volume * 0.7, now + duration - 0.1);
    gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
    
    // æ·»åŠ ä½é€šæ¿¾æ³¢å™¨è®“éŸ³æ•ˆæ›´æŸ”å’Œ
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(2000, now);
    filter.Q.setValueAtTime(1, now);
    
    osc.start(now);
    osc.stop(now + duration);
  } catch (e) {}
}

// éŸ³æ•ˆåº«
const SoundEffects = {
  discard: () => playSound(400, 0.15, 'square', 0.15, 0.02, 0.05),
  draw: () => playSound(600, 0.2, 'sine', 0.18, 0.05, 0.08),
  chow: () => playChord([523, 659, 784], 0.3, 'triangle', 0.2), // C-E-Gå’Œå¼¦
  pong: () => playChord([440, 554, 659], 0.35, 'square', 0.22), // A-C#-Eå’Œå¼¦
  kong: () => playChord([330, 440, 554, 659], 0.4, 'sawtooth', 0.25), // å››éŸ³å’Œå¼¦
  win: () => {
    // å‹åˆ©éŸ³æ•ˆï¼šä¸Šå‡éŸ³éš
    const notes = [523, 659, 784, 1047]; // C-E-G-C
    notes.forEach((freq, i) => {
      setTimeout(() => playSound(freq, 0.4, 'sine', 0.25, 0.05, 0.1), i * 150);
    });
  },
  listen: () => playChord([440, 554], 0.25, 'sine', 0.18),
  error: () => playSound(200, 0.2, 'sawtooth', 0.15, 0.01, 0.05)
};

function showEffect(text, color, size = '48px') {
  const overlay = document.createElement('div');
  overlay.className = 'effect-overlay';
  
  // ä¸»æ–‡å­—æ•ˆæœ
  const effect = document.createElement('div');
  effect.className = 'effect-text';
  effect.textContent = text;
  effect.style.color = color;
  effect.style.fontSize = size;
  overlay.appendChild(effect);
  
  // å…‰æšˆæ•ˆæœ
  const glow = document.createElement('div');
  glow.className = 'effect-glow';
  glow.style.color = color;
  glow.style.left = '50%';
  glow.style.top = '50%';
  glow.style.transform = 'translate(-50%, -50%)';
  overlay.appendChild(glow);
  
  // é«˜ç´šç²’å­æ•ˆæœ
  const particles = document.createElement('div');
  particles.className = 'effect-particles';
  const particleCount = 30;
  for (let i = 0; i < particleCount; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.color = color;
    const angle = (Math.PI * 2 * i) / particleCount;
    const distance = 60 + Math.random() * 80;
    const size = 4 + Math.random() * 4;
    particle.style.width = `${size}px`;
    particle.style.height = `${size}px`;
    particle.style.left = '50%';
    particle.style.top = '50%';
    particle.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
    particle.style.setProperty('--ty', `${Math.sin(angle) * distance - 30}px`);
    particle.style.animationDelay = `${i * 0.02}s`;
    particle.style.animationDuration = `${1.2 + Math.random() * 0.6}s`;
    particles.appendChild(particle);
  }
  overlay.appendChild(particles);
  
  document.body.appendChild(overlay);
  setTimeout(() => overlay.remove(), 1500);
}

function log(msg) {
  const el = document.getElementById('log');
  const line = document.createElement('div');
  const formatted = formatLogString(msg);
  line.innerHTML = formatted;
  line.style.marginBottom = '4px';
  line.style.flexShrink = '0';
  if (/ä½ /.test(msg)) line.classList.add('my-log');
  el.appendChild(line);
  
  // ç¢ºä¿æ»¾å‹•åˆ°åº•éƒ¨ï¼ˆé¡¯ç¤ºæœ€æ–°å…§å®¹ï¼‰
  requestAnimationFrame(() => {
  el.scrollTop = el.scrollHeight;
  });
}

function formatLogString(text) {
  const cnNumMap = { 'ä¸€': 1, 'äºŒ': 2, 'ä¸‰': 3, 'å››': 4, 'äº”': 5, 'å…­': 6, 'ä¸ƒ': 7, 'å…«': 8, 'ä¹': 9 };
  // æª¢æŸ¥æ˜¯å¦åŒ…å«ç©å®¶åå­—ï¼ˆé¿å…å°‡åå­—ä¸­çš„å­—è½‰æ›æˆç‰Œï¼‰
  // å¦‚æœæ–‡æœ¬ä¸­åŒ…å«å·²çŸ¥çš„ç©å®¶åå­—ï¼Œå‰‡è·³éåå­—éƒ¨åˆ†çš„è½‰æ›
  let protectedText = text;
  if (S && S.names) {
    // ç‚ºæ¯å€‹ç©å®¶åå­—æ·»åŠ ä¿è­·æ¨™è¨˜
    S.names.forEach((name, idx) => {
      if (name && name.length > 0) {
        // ä½¿ç”¨ç‰¹æ®Šæ¨™è¨˜åŒ…è£¹åå­—ï¼Œé¿å…è¢«æ­£å‰‡åŒ¹é…
        const protectedName = `__NAME_${idx}__`;
        protectedText = protectedText.replace(new RegExp(name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), protectedName);
      }
    });
  }
  
  // è½‰æ›ç‰Œé¢æ–‡å­—
  protectedText = protectedText.replace(/([1-9]|[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹])([è¬ç­’æ¢ç´¢])|([æ±å—è¥¿åŒ—ä¸­ç™¼ç™½])/g, (m, p1, p2, p3) => {
    if (p1 && p2) {
      const suitChar = p2;
      let suitKey;
      if (suitChar === 'è¬') suitKey = 'W';
      else if (suitChar === 'ç­’') suitKey = 'T';
      else if (suitChar === 'æ¢' || suitChar === 'ç´¢') suitKey = 'B';
      else suitKey = '?';
      return `<span class="tile log-tile suit-${suitKey}">${m}</span>`;
    }
    if (p3) {
      let suitKey;
      if ('æ±å—è¥¿åŒ—'.includes(p3)) suitKey = 'F';
      else if ('ä¸­ç™¼ç™½'.includes(p3)) suitKey = 'D';
      else suitKey = '?';
      return `<span class="tile log-tile suit-${suitKey}">${p3}</span>`;
    }
    return m;
  });
  
  // æ¢å¾©ç©å®¶åå­—
  if (S && S.names) {
    S.names.forEach((name, idx) => {
      if (name && name.length > 0) {
        const protectedName = `__NAME_${idx}__`;
        protectedText = protectedText.replace(new RegExp(protectedName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), name);
      }
    });
  }
  
  return protectedText;
}

/* ========= ç‰Œå‹å®šç¾© ========= */
const SUIT_W = 'W', SUIT_T = 'T', SUIT_B = 'B', SUIT_F = 'F', SUIT_D = 'D';
const WINDS = ['E', 'S', 'W', 'N'];
const DRAGONS = ['C', 'F', 'B'];

function tileKey(t) {
  if (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) return t.suit + String(t.rank);
  if (t.suit === SUIT_F || t.suit === SUIT_D) return t.suit + t.name;
  return '?';
}

function keyToText(k) {
  const s = k[0], v = k.slice(1);
  if (s === SUIT_W) return v + 'è¬';
  if (s === SUIT_T) return v + 'ç­’';
  if (s === SUIT_B) return v + 'æ¢';
  if (s === SUIT_F) {
    const m = { E: 'æ±', S: 'å—', W: 'è¥¿', N: 'åŒ—' };
    return m[v] || k;
  }
  if (s === SUIT_D) {
    const m = { C: 'ä¸­', F: 'ç™¼', B: 'ç™½' };
    return m[v] || k;
  }
  return k;
}

function generateTiles() {
  const tiles = [];
  const push4 = (suit, rank) => {
    for (let i = 0; i < 4; i++) tiles.push({ suit, rank, id: tiles.length });
  };
  for (let r = 1; r <= 9; r++) {
    push4(SUIT_W, r);
    push4(SUIT_T, r);
    push4(SUIT_B, r);
  }
  WINDS.forEach(n => {
    for (let i = 0; i < 4; i++) tiles.push({ suit: SUIT_F, name: n, id: tiles.length });
  });
  DRAGONS.forEach(n => {
    for (let i = 0; i < 4; i++) tiles.push({ suit: SUIT_D, name: n, id: tiles.length });
  });
  return tiles;
}

function shuffle(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = rng(i + 1);
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* ========= éŠæˆ²è¦å‰‡èˆ‡ç‹€æ…‹ ========= */
const RULES = {
  handSize: 16,
  scoring: {
    // åŸºç¤èˆ‡åŸºæœ¬åˆ†
    Dealer: 1,                // èŠå®¶ï¼ˆå·²åœ¨é€£èŠå°æ•¸ä¸­è™•ç†ï¼‰
    ConcealedHand: 1,         // é–€æ¸…
    SelfDraw: 1,              // è‡ªæ‘¸
    NoNeedOthers: 2,          // ä¸æ±‚äººï¼ˆé–€æ¸…+è‡ªæ‘¸ï¼‰
    
    // çµ„åˆç‰Œå‹ï¼ˆä¸­ç´šï¼‰
    AllChows: 2,              // å…¨æ±‚äºº
    PingHu: 2,                // å¹³èƒ¡
    ThreeConcealedPungs: 2,   // ä¸‰æš—åˆ»
    AllPungs: 4,              // å°å°èƒ¡
    HalfFlush: 4,             // æ¹Šä¸€è‰²ï¼ˆæ··ä¸€è‰²ï¼‰
    FourConcealedPungs: 8,      // å››æš—åˆ»
    
    // å­—ç‰Œç›¸é—œ
    BigThreeDragons: 8,       // å¤§ä¸‰å…ƒ
    LittleThreeDragons: 4,    // å°ä¸‰å…ƒ
    BigFourWinds: 16,         // å¤§å››å–œ
    LittleFourWinds: 8,       // å°å››å–œ
    AllHonors: 16,            // å­—ä¸€è‰²
    
    // ç‰¹æ®Šé«˜éšç‰Œå‹
    PureOneSuit: 8,           // æ¸…ä¸€è‰²
    FiveConcealedPungs: 8,    // äº”æš—åˆ»
    HeavenWin: 20,            // å¤©èƒ¡ï¼ˆå–ä¸­é–“å€¼20å°ï¼‰
    EarthWin: 20,             // åœ°èƒ¡ï¼ˆå–ä¸­é–“å€¼20å°ï¼‰
    HumanWin: 12,             // äººèƒ¡ï¼ˆå–ä¸­é–“å€¼12å°ï¼‰
    
    // ç‰¹æ®Šç‰Œå‹
    NineGates: 8,             // ä¹è“®å¯¶ç‡ˆ
    FourKongs: 8,             // å››æ§“å­
    ThreeKongs: 2,            // ä¸‰æ§“å­
    AllTerminals: 8,          // æ¸…è€é ­
    AllTerminalsAndHonors: 4, // æ··è€é ­
    
    // ç‰¹æ®Šæƒ…æ³
    RobKong: 1,               // æ¶æ§“
    Rinshan: 1,               // æ§“ä¸Šé–‹èŠ±
    Haitei: 1,                // æµ·åº•æ’ˆæœˆï¼ˆè‡ªæ‘¸æœ€å¾Œä¸€å¼µï¼‰
    Houtei: 1,                // æ²³åº•æ’ˆé­šï¼ˆèƒ¡æœ€å¾Œä¸€å¼µï¼‰
    
    // é¢¨ç‰Œï¼ˆåº§é¢¨/åœˆé¢¨ï¼‰
    SeatWind: 1,              // åº§é¢¨
    RoundWind: 1,             // åœˆé¢¨
    
    // å ±è½ç›¸é—œï¼ˆä¿ç•™ç”¨æ–¼é¡¯ç¤ºï¼‰
    DeclaredListen: 1,        // å ±è½
    EarthReady: 4,            // åœ°è½
    HeavenReady: 8,           // å¤©è½
    
    // èŠ±ç‰Œï¼ˆå¦‚æœæœ‰ï¼‰
    Flower: 1,
  },
  points: { base: 2000, perFan: 1000 },
  initialPoints: 100000
};

// éŠæˆ²è¨­å®šï¼ˆå¯ä¿®æ”¹ï¼‰
let GAME_SETTINGS = {
  basePoints: 2000,      // åº•å°
  perFanPoints: 1000,   // æ¯å°
  initialPoints: 100000, // åˆå§‹è³‡é‡‘
  playerNames: null      // ç©å®¶åå­—ï¼ˆnullè¡¨ç¤ºä½¿ç”¨éš¨æ©Ÿåå­—ï¼‰
};

let S = null;
let seatNames = ['æ±','å—','è¥¿','åŒ—'];

// è·å–å½“å‰ç©å®¶åº§ä½ï¼ˆè¿çº¿æ¨¡å¼ç”¨ mySeatï¼Œå•æœºæ¨¡å¼ç”¨ 0ï¼‰
function getMyPlayerSeat() {
  return (gameMode === 'online' && typeof mySeat !== 'undefined' && mySeat >= 0) ? mySeat : 0;
}

// IndexedDB æ•¸æ“šåº«åç¨±å’Œç‰ˆæœ¬
const DB_NAME = 'mahjong_game';
const DB_VERSION = 1;
const STORE_NAME = 'game_saves';

// åˆå§‹åŒ– IndexedDB
function initDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
      }
    };
  });
}

// ä¿å­˜éŠæˆ²ç‹€æ…‹
async function saveGame() {
  try {
    if (!S || S.phase === 'end') {
      log('âŒ æ²’æœ‰é€²è¡Œä¸­çš„éŠæˆ²å¯ä»¥ä¿å­˜');
      return false;
    }
    
    const db = await initDB();
    const transaction = db.transaction([STORE_NAME], 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    
    // æº–å‚™è¦ä¿å­˜çš„æ•¸æ“š
    const gameData = {
      id: 1, // ä½¿ç”¨å›ºå®šIDï¼Œåªä¿å­˜ä¸€å€‹éŠæˆ²
      gameState: JSON.parse(JSON.stringify(S)), // æ·±æ‹·è²éŠæˆ²ç‹€æ…‹
      seatNames: seatNames,
      dealerStreak: dealerStreak,
      timestamp: new Date().toISOString()
    };
    
    // æ¸…é™¤èˆŠçš„ä¿å­˜ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    await new Promise((resolve, reject) => {
      const deleteRequest = store.delete(1);
      deleteRequest.onsuccess = () => resolve();
      deleteRequest.onerror = () => reject(deleteRequest.error);
    });
    
    // ä¿å­˜æ–°æ•¸æ“š
    await new Promise((resolve, reject) => {
      const addRequest = store.add(gameData);
      addRequest.onsuccess = () => resolve();
      addRequest.onerror = () => reject(addRequest.error);
    });
    
    // éœé»˜ä¿å­˜ï¼Œä¸é¡¯ç¤ºæ¶ˆæ¯
    return true;
  } catch (error) {
    console.error('ä¿å­˜å¤±æ•—:', error);
    log('âŒ ä¿å­˜å¤±æ•—ï¼š' + error.message);
    return false;
  }
}

// è®€å–éŠæˆ²ç‹€æ…‹
async function loadGame() {
  try {
    const db = await initDB();
    const transaction = db.transaction([STORE_NAME], 'readonly');
    const store = transaction.objectStore(STORE_NAME);
    
    const gameData = await new Promise((resolve, reject) => {
      const request = store.get(1);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
    
    if (!gameData) {
      log('âŒ æ²’æœ‰æ‰¾åˆ°ä¿å­˜çš„éŠæˆ²');
      return false;
    }
    
    // æ¢å¾©éŠæˆ²ç‹€æ…‹
    S = gameData.gameState;
    seatNames = gameData.seatNames || ['æ±','å—','è¥¿','åŒ—'];
    dealerStreak = gameData.dealerStreak || 0;
    
    log('ğŸ“‚ éŠæˆ²å·²è®€å–');
    showEffect('ğŸ“‚ å·²è®€å–', '#3b82f6');
    
    // é‡æ–°æ¸²æŸ“
    renderAll();
    
    // å¦‚æœéŠæˆ²é‚„åœ¨é€²è¡Œä¸­ï¼Œç¹¼çºŒAIå›åˆ
    if (S.phase === 'play' && S.turn !== 0) {
      // åœ¨è¿çº¿æ¨¡å¼ä¸‹ï¼Œåªæœ‰ AI ç©å®¶æ‰è‡ªåŠ¨å‡ºç‰Œ
      const isCurrentPlayerAI = gameMode === 'online' ? (S.turn !== mySeat && S.players[S.turn].isAI) : (S.turn !== 0);
      if (isCurrentPlayerAI) {
        setTimeout(stepAI, 1000);
      }
    }
    
    return true;
  } catch (error) {
    console.error('è®€å–å¤±æ•—:', error);
    log('âŒ è®€å–å¤±æ•—ï¼š' + error.message);
    return false;
  }
}

// è‡ªå‹•ä¿å­˜ï¼ˆæ¯30ç§’ï¼‰
let autoSaveInterval = null;
function startAutoSave() {
  if (autoSaveInterval) clearInterval(autoSaveInterval);
  autoSaveInterval = setInterval(() => {
    if (S && S.phase === 'play') {
      saveGame().catch(err => console.error('è‡ªå‹•ä¿å­˜å¤±æ•—:', err));
    }
  }, 30000); // 30ç§’
}

function stopAutoSave() {
  if (autoSaveInterval) {
    clearInterval(autoSaveInterval);
    autoSaveInterval = null;
  }
}

function getNextTurn(currentTurn) {
  // ç”±ä¸Šåˆ°ä¸‹é †åºï¼š0(æ±) -> 1(å—) -> 2(è¥¿) -> 3(åŒ—) -> 0
  return (currentTurn + 1) % 4;
}

const NAME_POOL = [
  // å°ç£è—äºº
  'å‘¨æ°å€«','è”¡ä¾æ—','æ—å¿—ç©','ç‹åŠ›å®','è•­æ•¬é¨°','å¼µæƒ å¦¹','äº”æœˆå¤©','é™³å¥•è¿…','æ¢éœèŒ¹','å­«ç‡•å§¿',
  'è”¡å¥é›…','æˆ´ä½©å¦®','æ¥Šä¸ç³','ç‹å¿ƒå‡Œ','å¼µéŸ¶æ¶µ','èŒƒç‘‹çª','å¾è‹¥ç‘„','æ—ä¾æ™¨','é™³å–¬æ©','å®‰ä»¥è»’',
  'éƒ­é‡‡æ½”','æ¡‚ç¶¸é‚','é™³æ„æ¶µ','éƒ­ç¢§å©·','æ—å¿—ç²','èˆ’æ·‡','å¼µéˆç”¯','è¨±ç‘‹ç”¯','è¬é‡‘ç‡•','è”¡è©©èŠ¸',
  'ç”°é¦¥ç”„','ä»»å®¶è±','é™³å˜‰æ¨º','ç¾…å¿—ç¥¥','æ½˜ç‘‹æŸ','å³å…‹ç¾¤','æ—ä¿Šå‚‘','é™¶å–†','å‘¨å‚³é›„','å¼µä¿¡å“²',
  'ä¼ä½°','æå®—ç››','å‘¨è¯å¥','ä»»è³¢é½Š','å¼µéœ‡','å½­äºæ™','é˜®ç¶“å¤©','è¶™åˆå»·','é™³æŸéœ–','æŸ¯éœ‡æ±',
  'ç‹å¤§é™¸','è¨±å…‰æ¼¢','æ—æŸå®','åŠ‰ä»¥è±ª','é‚±æ¾¤','æ¥Šç¥å¯§','å¼µå­å…¨','é³³å°å²³','é™³æŸéœ–','ææä»',
  // æ—¥æœ¬è—äºº
  'æœ¨æ‘æ‹“å“‰','æ–°å£çµè¡£','çŸ³åŸé‡Œç¾','é•·æ¾¤é›…ç¾','å ºé›…äºº','ç¦å±±é›…æ²»','å±±ä¸‹æ™ºä¹…','å°æ —æ—¬','æ¾æœ¬æ½¤','äºŒå®®å’Œä¹Ÿ',
  'å¤§é‡æ™º','ç›¸è‘‰é›…ç´€','æ«»äº•ç¿”','ç”Ÿç”°æ–—çœŸ','ä¸‰æµ¦æ˜¥é¦¬','ä½è—¤å¥','è…ç”°å°‡æš‰','å±±å´è³¢äºº','ç¥æœ¨éš†ä¹‹ä»‹','æ©‹æœ¬ç’°å¥ˆ',
  'æ¿±é‚Šç¾æ³¢','å»£ç€¨éˆ´','æœ‰æ‘æ¶ç´”','ä¸Šç™½çŸ³èŒéŸ³','æ°¸é‡èŠ½éƒ','å‰é«˜ç”±é‡Œå­','æ»¿å³¶å…‰','è’¼äº•å„ª','å®®å´è‘µ','å¤šéƒ¨æœªè¯å­',
  'æˆ¶ç”°æƒ æ¢¨é¦™','æ–°æœ¨å„ªå­','ä¸­æ¢å½©æœª','å°æ¾èœå¥ˆ','èƒ½å¹´ç²å¥ˆ','é»‘æœ¨è¯','å®‰è—¤æ«»','æ¾å²¡èŒ‰å„ª','åœŸå±‹å¤ªé³³','å·å£æ˜¥å¥ˆ',
  'ç¦å£«è’¼æ±°','å‚å£å¥å¤ªéƒ','æ©«æ¿±æµæ˜Ÿ','å‰æ¾¤äº®','é¾æ˜Ÿæ¶¼','ç«¹å…§æ¶¼çœŸ','ä¸­å³¶å¥äºº','å¹³é‡ç´«è€€','é“æé§¿ä½‘','ç›®é»‘è“®',
  // éŸ“åœ‹è—äºº
  'é‡‘ç§€è³¢','å…¨æ™ºè³¢','å®‹æ…§å–¬','ææ•é¬','æœ´ä¿¡æƒ ','æé¾ç¢©','å­”åŠ‰','å®‹ä»²åŸº','æœ´å¯¶åŠ','ææ£Ÿæ—­',
  'ç„å½¬','è˜‡å¿—ç‡®','æ± æ˜Œæ—­','å—æŸ±èµ«','æœ´æ•˜ä¿Š','é‡‘å®‡å½¬','ææ˜‡åŸº','åŠ‰äºä»','æ›¹æ”¿å¥­','æŸ³ä¿Šçƒˆ',
  'é‡‘é«˜éŠ€','æœ´æ•è‹±','é‡‘æ™ºåª›','éŸ“å­å‘¨','ç”³æ•å…’','éŸ“ä½³äºº','å­«è—ç','å…¨æ™ºè³¢','å®‹æ™ºå­','æçŸ¥æ©',
  'è£´ç§€æ™º','é‡‘æ‰€ç‚«','é‡‘è£•è²','é‡‘è³½ç¶¸','é‡‘æ³°æ¢¨','æœ´å¯¶è‹±','éŸ“å¿—æ—¼','æè–ç¶“','å¾ç„æŒ¯','æœ´æ©æ–Œ',
  'é‡‘å¤šç¾','å…¨æ±å½¬','éŸ“ç´ å¸Œ','é‡‘æƒ å…','ç”°ç¾éƒ½','é„­æœ‰ç¾','é‡‘å–œå–„','æè‹±æ„›','æ²³æ™ºè‹‘','å´”æ™ºå‹',
  'æå­åˆ©','å¯¶å…’','å¤ªå¦','æ½¤å¨¥','å¾ç„','ç§€è‹±','è’‚èŠ¬å¦®','å­æ·µ','ä¿åˆ©','å…å…’',
  'æ™ºç§€','çå¦®','ç¾…å©•','éº—è','å¨œç’‰','å®šå»¶','å¿—æ•ˆ','å¤šè³¢','å½©ç‘›','å­ç‘œ',
  'çŸæ˜Ÿ','è¼äºº','è¯è','é Œæ¨‚','ç‘Ÿçª','æº«è’‚','æ¾€çª','è‰¾ç³','è—ç³','ç æ³«'
];

let randomNames = null;
let dealerStreak = 0;

function startNewHand(isFirstGame = false) {
  const useGold = false;
  
  let newDealer = S?.dealer ?? 0;
  let newRound = S?.round ?? 1;
  const prevNames = S?.names || null;
  
  if (isFirstGame || !S) {
    const dice1 = Math.floor(Math.random() * 6) + 1;
    const dice2 = Math.floor(Math.random() * 6) + 1;
    const diceSum = dice1 + dice2;
    newDealer = (diceSum - 1) % 4;
    newRound = 1;
    // ç”±ä¸Šåˆ°ä¸‹é †åºï¼š0(æ±) -> 1(å—) -> 2(è¥¿) -> 3(åŒ—) -> 0
    // é¢¨ä½åˆ†é…ï¼šèŠå®¶æ˜¯æ±ï¼Œç”±ä¸Šåˆ°ä¸‹ä¾æ¬¡æ˜¯æ±ã€å—ã€è¥¿ã€åŒ—
    seatNames = [];
    const windOrder = ['æ±', 'å—', 'è¥¿', 'åŒ—'];
    for (let offset = 0; offset < 4; offset++) {
      const playerPos = (newDealer + offset) % 4;
      seatNames[playerPos] = windOrder[offset];
    }
    const dealerWindInit = seatNames[newDealer];
    const dealerNameInit = dealerWindInit + 'å®¶' + (newDealer === 0 ? '(ä½ )' : '');
    // ä½¿ç”¨è¨­å®šä¸­çš„åå­—æˆ–éš¨æ©Ÿåå­—
    if (GAME_SETTINGS.playerNames && GAME_SETTINGS.playerNames.length >= 4) {
      randomNames = GAME_SETTINGS.playerNames.slice(0, 4);
    } else {
      const pool = NAME_POOL.slice();
      const names = [];
      for (let i = 0; i < 4; i++) {
        const rIndex = Math.floor(Math.random() * pool.length);
        names.push(pool.splice(rIndex, 1)[0]);
      }
      randomNames = names;
    }
    log(`ğŸ² æ“²éª°ï¼š${dice1} + ${dice2} = ${diceSum}ï¼ŒèŠå®¶ç‚º${dealerNameInit}`);
    
    // èªéŸ³æ’­å ±æ–°å±€
    if (isFirstGame) {
      speakRandom('newGame');
    }
    
    // èªéŸ³æ’­å ±èŠå®¶
    if (newDealer === 0) {
      speakRandom('dealer');
    }
  } else if (S.winner === null) {
    log(`ğŸ” æµå±€é€£èŠï¼ŒèŠå®¶ç¹¼çºŒç•¶èŠ`);
    newDealer = S.dealer; // æµå±€é€£èŠï¼ŒèŠå®¶ä¸è®Š
    
    // èªéŸ³æ’­å ±æµå±€
    speakRandom('drawGame');
    
    // èªéŸ³æ’­å ±èŠå®¶
    if (newDealer === 0) {
      speakRandom('dealer');
    }
  } else if (S.winner === S.dealer) {
    log(`ğŸ† èŠå®¶èƒ¡ç‰Œï¼Œç¹¼çºŒç•¶èŠ`);
    newDealer = S.dealer; // èŠå®¶èƒ¡ç‰Œï¼Œç¹¼çºŒç•¶èŠ
    
    // èªéŸ³æ’­å ±èŠå®¶é€£èŠ
    if (newDealer === 0) {
      speakRandom('dealerStreak');
    }
  } else {
    // ç”±ä¸Šåˆ°ä¸‹é †åºï¼š0(æ±) -> 1(å—) -> 2(è¥¿) -> 3(åŒ—) -> 0
    newDealer = (S.dealer + 1) % 4;
    if (newDealer === S.initialDealer) {
      newRound++;
      if (newRound > 4) {
        log(`ğŸ å››åœˆå·²æ‰“å®Œï¼ŒéŠæˆ²çµæŸï¼`);
        showFinalScore();
        return;
      }
      log(`ğŸ”„ é€²å…¥ç¬¬${newRound}åœˆ`);
    }
    const rotatedWind = seatNames?.[newDealer] || ['æ±','å—','è¥¿','åŒ—'][newDealer];
    const rotatedName = rotatedWind + 'å®¶' + (newDealer === 0 ? '(ä½ )' : '');
    log(`ğŸ” èŠå®¶è¼ªæ›¿è‡³${rotatedName}`);
    
    // èªéŸ³æ’­å ±èŠå®¶
    if (newDealer === 0) {
      speakRandom('dealer');
    }
  }

  if (isFirstGame || !S) {
    dealerStreak = 0;
  } else {
    if (newDealer === S.dealer) {
      // èŠå®¶ç¹¼çºŒç•¶èŠï¼Œé€£èŠæ¬¡æ•¸+1
      dealerStreak = (S.dealerStreak || 0) + 1;
      if (dealerStreak > 1) {
        log(`ğŸ”„ é€£èŠ ${dealerStreak} æ¬¡`);
      }
      
      // èªéŸ³æ’­å ±é€£èŠ
      if (newDealer === 0 && dealerStreak > 0) {
        speakRandom('dealerStreak');
      }
    } else {
      // èŠå®¶è¼ªæ›¿ï¼Œé‡ç½®é€£èŠæ¬¡æ•¸
      dealerStreak = 0;
    }
  }
  
  S = {
    wall: shuffle(generateTiles()),
    deadWall: [],
    players: Array.from({ length: 4 }, (_, i) => {
      // åœ¨è¿çº¿æ¨¡å¼ä¸‹ï¼Œæ£€æŸ¥ onlinePlayers åˆ—è¡¨æ¥ç¡®å®šæ˜¯å¦æ˜¯AI
      let isAI = false;
      if (gameMode === 'online') {
        // å¦‚æœ onlinePlayers æœªå®šä¹‰æˆ–ä¸ºç©ºï¼Œå‡è®¾åªæœ‰è‡ªå·±æ˜¯çœŸäººç©å®¶
        if (!onlinePlayers || onlinePlayers.length === 0) {
          isAI = (i !== mySeat);
          if (isHost) {
            console.warn('âš ï¸ startNewHand: onlinePlayers æœªå®šç¾©ï¼Œåº§ä½', i, 'è¨­ç‚ºAI:', isAI);
          }
        } else {
          // æ£€æŸ¥åº§ä½ i æ˜¯å¦åœ¨ onlinePlayers åˆ—è¡¨ä¸­
          isAI = !onlinePlayers.some(p => p.seat === i);
        }
      } else {
        // å•æœºæ¨¡å¼ï¼šåªæœ‰åº§ä½0æ˜¯çœŸäººç©å®¶
        isAI = (i !== 0);
      }
      
      // è°ƒè¯•æ—¥å¿—ï¼ˆä»…è¿çº¿æ¨¡å¼ä¸”æ˜¯æˆ¿ä¸»æ—¶ï¼‰
      if (gameMode === 'online' && isHost && i === 0) {
        console.log('=== AIæ›¿è¡¥æ£€æŸ¥ ===');
        console.log('åº§ä½', i, '- onlinePlayers:', onlinePlayers?.map(p => ({seat: p.seat, name: p.name})) || 'æœªå®šä¹‰');
        console.log('åº§ä½', i, '- isAI:', isAI);
      }
      
      return {
        hand: [],
        discards: [],
        flowers: [],
        melds: [],
        points: prevNames ? S.players[i].points : GAME_SETTINGS.initialPoints,
        declaredListen: false,
        waitKeys: [],
        tianTing: false,
        diTing: false,
        isAI: isAI,
        rinshan: false,
        drawCount: 0,
        tingLocked: false,
        requiredDiscard: null
      };
    }),
    kongCount: 0,
    rules: clone(RULES),
    turn: newDealer,
    dealer: newDealer,
    round: newRound,
    initialDealer: (isFirstGame || !S) ? newDealer : (S.initialDealer ?? newDealer),
    dealerStreak: dealerStreak,
    lastDiscard: null,
    waitReact: null,
    winner: null,
    fromPlayer: null,
    winTile: null,
    phase: 'deal',
    remain: 0,
    drawCount: 0,
    anyOpenMeld: false,
    robKong: false,
    lastAction: null,
    lastActor: null,
    names: prevNames || randomNames
  };
  
  if (!randomNames && prevNames) {
    randomNames = prevNames;
  }
  S.names = randomNames ? randomNames.slice() : (prevNames ? prevNames.slice() : []);
  dealTiles();
  S.phase = 'play';
  // å‰©ä½™ç‰Œæ•° = å®é™…å¯ä¾›æ‘¸æ‰“çš„ç‰Œæ•°ï¼ˆä¸åŒ…æ‹¬ç‹ç‰Œï¼‰
  S.remain = S.wall.length;
  renderAll();
  
  const dealerWind = seatNames?.[S.dealer] || ['æ±', 'å—', 'è¥¿', 'åŒ—'][S.dealer];
  const dealerName = dealerWind + 'å®¶' + (S.dealer === 0 ? '(ä½ )' : '');
  const roundName = ['æ±', 'å—', 'è¥¿', 'åŒ—'][newRound - 1];
  const streakText = dealerStreak > 0 ? `ï¼ˆé€£èŠ ${dealerStreak} æ¬¡ï¼‰` : '';
  log(`ğŸ® ç¬¬${newRound}åœˆ ${roundName}é¢¨ï¼ŒèŠå®¶ï¼š${dealerName}${streakText}`);
  
  // å•Ÿå‹•è‡ªå‹•ä¿å­˜
  if (isFirstGame) {
    startAutoSave();
  }
  
  // åœ¨é€£ç·šæ¨¡å¼ä¸‹ï¼Œåˆ¤æ–·èŠå®¶é¡å‹
  const isDealerMe = gameMode === 'online' ? (S.dealer === mySeat) : (S.dealer === 0);
  
  // ç¢ºä¿ onlinePlayers å·²å®šç¾©
  let isDealerAI = false;
  if (gameMode === 'online') {
    if (!onlinePlayers || onlinePlayers.length === 0) {
      console.error('âŒ startNewHand: onlinePlayers æœªå®šç¾©æˆ–ç‚ºç©ºï¼');
      // å‡è¨­åªæœ‰è‡ªå·±æ˜¯çœŸäººç©å®¶
      isDealerAI = S.dealer !== mySeat;
    } else {
      isDealerAI = !onlinePlayers.some(p => p.seat === S.dealer);
    }
  } else {
    isDealerAI = S.dealer !== 0;
  }
  
  // Debug log
  if (gameMode === 'online') {
    console.log('=== é€£ç·šæ¨¡å¼èŠå®¶åˆ¤æ–· ===');
    console.log('S.dealer:', S.dealer);
    console.log('mySeat:', mySeat);
    console.log('isHost:', isHost);
    console.log('onlinePlayers:', JSON.stringify(onlinePlayers?.map(p => ({seat: p.seat, name: p.name})) || []));
    console.log('isDealerMe:', isDealerMe);
    console.log('isDealerAI:', isDealerAI);
  }
  
  if (isDealerMe) {
    log(`ğŸ‘‰ èŠå®¶æŒæœ‰17å¼µç‰Œï¼Œè«‹ç›´æ¥å‡ºç‰Œ`);
  } else if (isDealerAI) {
    // AIèŠå®¶ï¼Œåªæœ‰æˆ¿ä¸»æ§åˆ¶
    if (!isOnlineMode || isHost) {
      log(`â³ AIèŠå®¶é–‹å§‹å‡ºç‰Œ...`);
      setTimeout(stepAI, 1000 + Math.random() * 1000);
    } else {
      log(`â³ ç­‰å¾…èŠå®¶å‡ºç‰Œ...`);
    }
  } else {
    // é€£ç·šæ¨¡å¼ä¸‹ï¼Œå…¶ä»–çœŸäººèŠå®¶
    log(`â³ ç­‰å¾… ${S.names[S.dealer]} å‡ºç‰Œ...`);
  }
}

function dealTiles() {
  const dead = 16;
  while (S.wall.length > dead && S.players[0].hand.length < 16) {
    for (let p = 0; p < 4; p++) {
      if (S.wall.length > dead) {
        S.players[p].hand.push(S.wall.pop());
      }
    }
  }
  if (S.wall.length > dead) {
    S.players[S.dealer].hand.push(S.wall.pop());
  }
  const deadWallSize = Math.min(dead, S.wall.length);
  S.deadWall = S.wall.splice(-deadWallSize, deadWallSize);
}


function playerName(i) {
  const name = (S && S.names && S.names[i]) ? S.names[i] : (seatNames?.[i] || ['æ±', 'å—', 'è¥¿', 'åŒ—'][i]);
  return name + (i === 0 ? '(ä½ )' : '');
}

function countKongs(pl) {
  return pl.melds.filter(m => m.type === 'kong').length;
}

function updateTianDiTing(pid) {
  const pl = S.players[pid];
  if (S.anyOpenMeld) return;
  // å¤©è½ï¼šèŠå®¶ç¬¬ä¸€æ¬¡æ‘¸ç‰Œå¾Œå°±è½ç‰Œ
  if (pid === S.dealer && pl.drawCount === 1) {
    pl.tianTing = true;
    return;
  }
  // åœ°è½ï¼šéèŠå®¶å‰8æ¬¡æ‘¸ç‰Œå…§ï¼ˆä¸åŒ…æ‹¬èŠå®¶çš„ç¬¬ä¸€æ¬¡ï¼‰
  if (pid !== S.dealer && pl.drawCount <= 8) {
    pl.diTing = true;
  }
}

/* ========= èƒ¡ç‰Œåˆ¤å®š ========= */
function isWinningNow(hand, melds, winTile) {
  const tiles = hand.slice().sort((a, b) => tileSortKey(a) - tileSortKey(b));
  // è¨ˆç®—å¯¦éš›éœ€è¦çš„é †å­/åˆ»å­æ•¸é‡ï¼ˆæ¯å€‹å‰¯éœ²ä½”1å€‹ï¼Œæ¯å€‹æ§“ä½”1å€‹ï¼‰
  // 16å¼µéº»å°‡ï¼š5å€‹é †å­/åˆ»å­ + 1å€‹å°‡ï¼ˆå°å­ï¼‰= 16å¼µæ‰‹ç‰Œ
  const kongCount = melds.filter(m => m.type === 'kong').length;
  const nonKongMelds = melds.filter(m => m.type !== 'kong').length;
  const totalMelds = nonKongMelds + kongCount;
  const neededSets = Math.max(0, 5 - totalMelds);
  
  return canStandardWin(tiles, neededSets);
}

function isListening(hand, melds) {
  // æª¢æŸ¥æ‰‹ç‰Œæ•¸é‡æ˜¯å¦åˆç†ï¼ˆ16å¼µéº»å°‡ï¼šæ‰‹ç‰Œ+å‰¯éœ²æ‡‰è©²åœ¨åˆç†ç¯„åœå…§ï¼‰
  const kongCount = melds.filter(m => m.type === 'kong').length;
  const totalMelds = melds.length;
  const expectedHandSize = 16 - (totalMelds * 3) - kongCount; // æ¯å€‹å‰¯éœ²3å¼µï¼Œæ¯å€‹æ§“é¡å¤–1å¼µ
  
  // å¦‚æœæ‰‹ç‰Œæ•¸é‡ä¸åœ¨åˆç†ç¯„åœï¼Œè¿”å›false
  if (hand.length < expectedHandSize - 1 || hand.length > expectedHandSize + 1) {
    return false;
  }
  
  const allPossibleTiles = [];
  for (let suit of [SUIT_W, SUIT_T, SUIT_B]) {
    for (let rank = 1; rank <= 9; rank++) {
      allPossibleTiles.push({ suit, rank, id: -1 });
    }
  }
  WINDS.forEach(name => allPossibleTiles.push({ suit: SUIT_F, name, id: -1 }));
  DRAGONS.forEach(name => allPossibleTiles.push({ suit: SUIT_D, name, id: -1 }));
  
  return allPossibleTiles.some(tile => {
    const testHand = hand.concat([tile]);
    return isWinningNow(testHand, melds, tile);
  });
}

function calcWaitingTiles(hand, melds) {
  const waits = [];
  
  // æª¢æŸ¥æ‰‹ç‰Œæ•¸é‡æ˜¯å¦åˆç†
  const kongCount = melds.filter(m => m.type === 'kong').length;
  const totalMelds = melds.length;
  const expectedHandSize = 16 - (totalMelds * 3) - kongCount;
  
  // å¦‚æœæ‰‹ç‰Œæ•¸é‡ä¸åœ¨åˆç†ç¯„åœï¼Œè¿”å›ç©ºæ•¸çµ„
  if (hand.length < expectedHandSize - 1 || hand.length > expectedHandSize + 1) {
    return waits;
  }
  
  const allPossibleTiles = [];
  for (let suit of [SUIT_W, SUIT_T, SUIT_B]) {
    for (let rank = 1; rank <= 9; rank++) {
      allPossibleTiles.push({ suit, rank, id: -1 });
    }
  }
  WINDS.forEach(name => allPossibleTiles.push({ suit: SUIT_F, name, id: -1 }));
  DRAGONS.forEach(name => allPossibleTiles.push({ suit: SUIT_D, name, id: -1 }));
  
  const seen = new Set();
  allPossibleTiles.forEach(tile => {
    const testHand = hand.concat([tile]);
    if (isWinningNow(testHand, melds, tile)) {
      const k = tileKey(tile);
      if (!seen.has(k)) {
        waits.push(k);
        seen.add(k);
      }
    }
  });
  
  waits.sort((a, b) => {
    const parseKey = (k) => {
      const s = k[0];
      const v = k.slice(1);
      if (s === SUIT_W || s === SUIT_T || s === SUIT_B) {
        return { suit: s, rank: parseInt(v), id: -1 };
      }
      if (s === SUIT_F || s === SUIT_D) {
        return { suit: s, name: v, id: -1 };
      }
      return { suit: s, id: -1 };
    };
    const ta = parseKey(a);
    const tb = parseKey(b);
    return tileSortKey(ta) - tileSortKey(tb);
  });
  
  return waits;
}


function canStandardWin(tiles, need = 5) {
  const counts = countByKey(tiles);
  for (const k in counts) {
    if (counts[k] >= 2) {
      counts[k] -= 2;
      if (canSplitMelds(counts, need)) return true;
      counts[k] += 2;
    }
  }
  return false;
}

function canSplitMelds(counts, need) {
  if (need === 0) return Object.values(counts).every(v => v === 0);
  
  // è·å–æ‰€æœ‰æœ‰ç‰Œçš„keyï¼Œå¹¶æŒ‰é¡ºåºæ’åº
  const keys = Object.keys(counts).filter(k => counts[k] > 0);
  if (keys.length === 0) return need === 0;
  
  // æŒ‰èŠ±è‰²å’Œæ•°å€¼æ’åºï¼Œç¡®ä¿å¤„ç†é¡ºåºä¸€è‡´
  keys.sort((a, b) => {
    const sa = a[0], sb = b[0];
    const va = parseInt(a.slice(1)) || 0;
    const vb = parseInt(b.slice(1)) || 0;
    const suitOrder = { W: 0, T: 1, B: 2, F: 3, D: 4 };
    const orderA = (suitOrder[sa] || 99) * 100 + va;
    const orderB = (suitOrder[sb] || 99) * 100 + vb;
    return orderA - orderB;
  });
  
  const first = keys[0];
  
  // å…ˆå°è¯•ç»„æˆåˆ»å­ï¼ˆå¦‚æœæœ‰3å¼ æˆ–ä»¥ä¸Šï¼‰
  if (counts[first] >= 3) {
    counts[first] -= 3;
    if (canSplitMelds(counts, need - 1)) return true;
    counts[first] += 3;
  }
  
  // å†å°è¯•ç»„æˆé¡ºå­ï¼ˆå¦‚æœæ˜¯æ•°ç‰Œä¸”v <= 7ï¼‰
  const s = first[0];
  const v = parseInt(first.slice(1));
  if ((s === SUIT_W || s === SUIT_T || s === SUIT_B) && v <= 7 && counts[first] > 0) {
    const k2 = s + (v + 1), k3 = s + (v + 2);
    if ((counts[k2] || 0) > 0 && (counts[k3] || 0) > 0) {
      counts[first]--;
      counts[k2]--;
      counts[k3]--;
      if (canSplitMelds(counts, need - 1)) return true;
      counts[first]++;
      counts[k2]++;
      counts[k3]++;
    }
  }
  
  return false;
}

function countByKey(tiles) {
  const m = {};
  for (const t of tiles) {
    const k = tileKey(t);
    m[k] = (m[k] || 0) + 1;
  }
  return m;
}

function tileSortKey(t) {
  const order = { W: 0, T: 1, B: 2, F: 3, D: 4, H: 5 };
  const o = order[t.suit];
  const v = (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) ? t.rank : ({ E: 1, S: 2, W: 3, N: 4, C: 5, F: 6, B: 7 }[t.name] || 0);
  return o * 100 + v;
}

/* ========= AI é‚è¼¯ ========= */
function shantenAfterRemove(hand) {
  function approxShanten14(tiles) {
    if (isWinningNow(tiles, [], null)) return 0;
    const m = countByKey(tiles);
    let pairs = 0, triples = 0, singles = 0;
    for (const k in m) {
      const c = m[k];
      if (c >= 3) triples++;
      else if (c === 2) pairs++;
      else singles++;
    }
    let est = Math.max(0, 5 - (pairs + triples));
    est += Math.ceil(singles / 4) * 0.5;
    return est;
  }
  
  let best = 99;
  const n = hand.length;
  for (let i = 0; i < n; i++) {
    const take = hand.filter((_, k) => k !== i);
    best = Math.min(best, approxShanten14(take));
  }
  
  const m = countByKey(hand);
  let pairs = 0;
  for (const k in m) {
    pairs += Math.floor(m[k] / 2);
  }
  const sevenNeed = Math.max(0, 8 - pairs);
  return Math.min(best, sevenNeed);
}

function aiChooseDiscard(pid) {
  const me = S.players[pid];
  const visible = [];
  S.players.forEach(p => visible.push(...p.discards, ...p.flowers));
  
  // æ”¶é›†æ‰€æœ‰å°æ‰‹çš„è½ç‰Œç‹€æ…‹å’Œå¯èƒ½çš„ç­‰ç‰Œ
  const listeningPlayers = [];
  const playerWaitKeys = {};
  for (let i = 0; i < 4; i++) {
    if (i !== pid) {
      if (S.players[i].declaredListen) {
      listeningPlayers.push(i);
        playerWaitKeys[i] = S.players[i].waitKeys || [];
      } else {
        // å³ä½¿æ²’å ±è½ï¼Œä¹Ÿæª¢æŸ¥æ˜¯å¦å¯èƒ½è½ç‰Œ
        const pl = S.players[i];
        const waits = calcWaitingTiles(pl.hand, pl.melds);
        if (waits.length > 0) {
          playerWaitKeys[i] = waits;
        }
      }
    }
  }
  
  // è¨ˆç®—ç•¶å‰å‘è½æ•¸
  const currentShanten = shantenAfterRemove(me.hand);
  
  let cands = me.hand.map(t => {
    const after = me.hand.filter(x => x !== t);
    const sh = shantenAfterRemove(after);
    let risk = riskOf(t);
    let waitCount = 0;
    let maxWaitTiles = 0;
    
    // å¢å¼·å±éšªç‰Œåˆ¤æ–·ï¼šæª¢æŸ¥æ‰€æœ‰å°æ‰‹å¯èƒ½çš„ç­‰ç‰Œ
    let dangerLevel = 0;
    const tileKey_t = tileKey(t);
    
    // æª¢æŸ¥å·²å ±è½çš„å°æ‰‹
      listeningPlayers.forEach(lp => {
        if (canWinOn(lp, t)) {
        dangerLevel += 2000; // å·²å ±è½ä¸”èƒ½èƒ¡ï¼Œæ¥µåº¦å±éšª
      } else if (playerWaitKeys[lp] && playerWaitKeys[lp].includes(tileKey_t)) {
        dangerLevel += 800; // å·²å ±è½ä¸”ç­‰é€™å¼µç‰Œ
        }
      });
    
    // æª¢æŸ¥æœªå ±è½ä½†å¯èƒ½è½ç‰Œçš„å°æ‰‹
    Object.keys(playerWaitKeys).forEach(lp => {
      if (!listeningPlayers.includes(parseInt(lp))) {
        if (playerWaitKeys[lp].includes(tileKey_t)) {
          dangerLevel += 300; // å¯èƒ½è½ç‰Œä¸”ç­‰é€™å¼µç‰Œ
        }
      }
    });
    
    // æª¢æŸ¥æœ€è¿‘æ‰“å‡ºçš„ç‰Œï¼ˆå°æ‰‹å¯èƒ½ä¸è¦çš„ç‰Œï¼‰
    const recentDiscards = visible.slice(-10); // æœ€è¿‘10å¼µ
    const discardedSimilar = recentDiscards.filter(vt => {
      const vk = tileKey(vt);
      if (vk === tileKey_t) return true;
      if (t.suit === 'W' || t.suit === 'T' || t.suit === 'B') {
        const vt_tile = keyToTile(vk);
        if (vt_tile.suit === t.suit && Math.abs(vt_tile.rank - t.rank) <= 1) {
          return true;
        }
      }
      return false;
    }).length;
    
    // å¦‚æœæœ€è¿‘æœ‰äººæ‰“éé¡ä¼¼ç‰Œï¼Œé™ä½é¢¨éšª
    if (discardedSimilar > 0) {
      risk *= Math.max(0.3, 1 - discardedSimilar * 0.15);
    }
    
    // å¦‚æœä¸Ÿé€™å¼µç‰Œå¾Œèƒ½è½ç‰Œï¼Œè¨ˆç®—è½ç‰Œè³ªé‡
    if (isListening(after, me.melds)) {
      const waits = calcWaitingTiles(after, me.melds);
      waitCount = waits.length;
      waits.forEach(wk => {
        const total = 4;
        const used = visible.filter(vt => tileKey(vt) === wk).length;
        const remain = total - used;
        maxWaitTiles += remain;
        
        // å¦‚æœç­‰ç‰Œæ˜¯å±éšªç‰Œï¼Œé™ä½è½ç‰Œåƒ¹å€¼
        let waitDanger = 0;
        listeningPlayers.forEach(lp => {
          if (playerWaitKeys[lp] && playerWaitKeys[lp].includes(wk)) {
            waitDanger += 200;
          }
        });
        maxWaitTiles -= waitDanger * 0.1;
      });
    }
    
    // å¢å¼·çµæ§‹åˆ†æ
    const m = countByKey(after);
    let pairs = 0, triples = 0, isolated = 0, sequences = 0;
    let usefulPairs = 0; // æœ‰ç”¨çš„å°å­ï¼ˆå¯ä»¥çµ„æˆåˆ»å­æˆ–é †å­ï¼‰
    const keys = Object.keys(m);
    
    keys.forEach(k => {
      const c = m[k];
      if (c >= 3) triples++;
      else if (c === 2) {
        pairs++;
        const tile = keyToTile(k);
        // æª¢æŸ¥å°å­æ˜¯å¦æœ‰ç”¨ï¼ˆå¯ä»¥çµ„æˆåˆ»å­æˆ–é †å­ï¼‰
        if (tile.suit === 'W' || tile.suit === 'T' || tile.suit === 'B') {
          const rank = tile.rank;
          const hasLeft = m[`${tile.suit}${rank-1}`] || m[`${tile.suit}${rank-2}`];
          const hasRight = m[`${tile.suit}${rank+1}`] || m[`${tile.suit}${rank+2}`];
          if (hasLeft || hasRight) usefulPairs++;
        }
      }
      else if (c === 1) {
        const tile = keyToTile(k);
        if (tile.suit === 'W' || tile.suit === 'T' || tile.suit === 'B') {
          const rank = tile.rank;
          const hasLeft = m[`${tile.suit}${rank-1}`] || m[`${tile.suit}${rank-2}`];
          const hasRight = m[`${tile.suit}${rank+1}`] || m[`${tile.suit}${rank+2}`];
          if (!hasLeft && !hasRight) isolated++;
          else sequences++;
        } else {
          isolated++;
        }
      }
    });
    
    // å‘è½æ•¸æ”¹å–„çå‹µ
    const shantenImprovement = currentShanten - sh;
    const shantenBonus = shantenImprovement * 100;
    
    // çµæ§‹è©•åˆ†å¢å¼·
    const structureScore = (triples * 100) + (sequences * 70) + (pairs * 25) + (usefulPairs * 15) - (isolated * 50);
    
    // å¦‚æœæ¥è¿‘è½ç‰Œï¼Œå„ªå…ˆè€ƒæ…®è½ç‰Œè³ªé‡
    let listeningBonus = 0;
    if (sh <= 1) {
      listeningBonus = (waitCount * 600) + (maxWaitTiles * 60);
    } else {
      listeningBonus = (waitCount * 500) + (maxWaitTiles * 50);
    }
    
    // å¦‚æœå·²ç¶“è½ç‰Œï¼Œå„ªå…ˆä¿æŒè½ç‰Œç‹€æ…‹
    if (currentShanten === 0 && sh === 0) {
      listeningBonus *= 1.5;
    }
    
    const score = listeningBonus + shantenBonus - (sh * 35) - (risk * 8) - dangerLevel + structureScore;
    return { tile: t, score, sh, waitCount };
  });
  
  cands.sort((a, b) => {
    // å„ªå…ˆè€ƒæ…®åˆ†æ•¸
    if (Math.abs(a.score - b.score) > 50) {
      return b.score - a.score;
    }
    // åˆ†æ•¸ç›¸è¿‘æ™‚ï¼Œå„ªå…ˆé¸æ“‡å‘è½æ•¸æ›´å°çš„
    if (a.sh !== b.sh) {
      return a.sh - b.sh;
    }
    // å‘è½æ•¸ç›¸åŒæ™‚ï¼Œå„ªå…ˆé¸æ“‡è½ç‰Œæ•¸æ›´å¤šçš„
    return b.waitCount - a.waitCount;
  });
  
  return cands[0].tile;
}

function riskOf(tile) {
  if (tile.suit === SUIT_F || tile.suit === SUIT_D) return 0.4;
  if (tile.rank === 1 || tile.rank === 9) return 0.65;
  return 1.0;
}

function keyToTile(k) {
  const s = k[0], v = k.slice(1);
  if (s === 'W' || s === 'T' || s === 'B') return { suit: s, rank: parseInt(v), id: -1 };
  if (s === 'F') return { suit: SUIT_F, name: v, id: -1 };
  if (s === 'D') return { suit: SUIT_D, name: v, id: -1 };
  return { suit: '?', id: -1 };
}

/* ========= åƒç¢°æ§“é‚è¼¯ ========= */
function canChow(pid, tile) {
  const pl = S.players[pid];
  if (pl.melds.length >= 5) return [];
  
  // è¦–è¦ºä¸Šï¼šä¸‹é¢åƒä¸Šé¢çš„ç‰Œ
  // å¦‚æœç©å®¶Xå‡ºç‰Œï¼Œé‚£éº¼ç©å®¶(X+1)%4å¯ä»¥åƒï¼ˆè¦–è¦ºä¸Šåœ¨ä¸‹é¢çš„ç©å®¶åƒä¸Šé¢çš„ç©å®¶ï¼‰
  // è¦–è¦ºé †åºï¼š1(å—ï¼Œæœ€ä¸Š) -> 2(è¥¿) -> 3(åŒ—) -> 0(æ±ï¼Œæœ€ä¸‹ï¼Œæˆ‘)
  // æ‰€ä»¥ï¼šç©å®¶3å‡ºç‰Œï¼Œç©å®¶0å¯ä»¥åƒï¼›ç©å®¶0å‡ºç‰Œï¼Œç©å®¶1å¯ä»¥åƒï¼›ç©å®¶1å‡ºç‰Œï¼Œç©å®¶2å¯ä»¥åƒï¼›ç©å®¶2å‡ºç‰Œï¼Œç©å®¶3å¯ä»¥åƒ
  if (S.lastDiscard && S.lastDiscard.from !== undefined) {
    const nextPlayer = (S.lastDiscard.from + 1) % 4;
    if (pid !== nextPlayer) return [];
  } else {
    return [];
  }
  
  if (tile.suit !== SUIT_W && tile.suit !== SUIT_T && tile.suit !== SUIT_B) return [];
  
  const rank = tile.rank;
  const suit = tile.suit;
  const patterns = [];
  
  if (rank <= 7) {
    const has1 = pl.hand.some(t => t.suit === suit && t.rank === rank + 1);
    const has2 = pl.hand.some(t => t.suit === suit && t.rank === rank + 2);
    if (has1 && has2) patterns.push([rank, rank + 1, rank + 2]);
  }
  
  if (rank >= 2 && rank <= 8) {
    const has1 = pl.hand.some(t => t.suit === suit && t.rank === rank - 1);
    const has2 = pl.hand.some(t => t.suit === suit && t.rank === rank + 1);
    if (has1 && has2) patterns.push([rank - 1, rank, rank + 1]);
  }
  
  if (rank >= 3) {
    const has1 = pl.hand.some(t => t.suit === suit && t.rank === rank - 2);
    const has2 = pl.hand.some(t => t.suit === suit && t.rank === rank - 1);
    if (has1 && has2) patterns.push([rank - 2, rank - 1, rank]);
  }
  
  return patterns;
}

function doChow(pid, tile, pattern) {
  const pl = S.players[pid];
  const suit = tile.suit;
  const tiles = [tile];
  
  // å¾åŸç©å®¶çš„æ¨ç‰Œå€ç§»é™¤é€™å¼µç‰Œ
  if (S.lastDiscard && S.lastDiscard.from !== undefined) {
    const fromPlayer = S.players[S.lastDiscard.from];
    const discardIndex = fromPlayer.discards.findIndex(t => 
      t === tile || (t.suit === tile.suit && t.rank === tile.rank && (!t.name || t.name === tile.name))
    );
    if (discardIndex >= 0) {
      fromPlayer.discards.splice(discardIndex, 1);
    }
  }
  
  pattern.forEach(rank => {
    if (rank !== tile.rank) {
      const idx = pl.hand.findIndex(t => t.suit === suit && t.rank === rank);
      if (idx >= 0) {
        tiles.push(pl.hand.splice(idx, 1)[0]);
      }
    }
  });
  
  tiles.sort((a, b) => a.rank - b.rank);
  const centerIdx = tiles.findIndex(t => t === tile);
  pl.melds.push({ type: 'chow', tiles, centerIdx });
  S.anyOpenMeld = true;
  log(`ğŸœ ${playerName(pid)} åƒäº† ${tiles.map(t => keyToText(tileKey(t))).join(' ')}`);
  showEffect('ğŸœ åƒ', '#22c55e');
  SoundEffects.chow();
  
  // èªéŸ³æ’­å ±ï¼ˆæ‰€æœ‰ç©å®¶éƒ½æ’­å ±ï¼‰
  speakRandom('chow');
  
  S.turn = pid;
  S.lastDiscard = null;
  S.waitReact = null;
  hideReactionPanel();
  renderAll();
  
  S.lastAction = 'chow';
  S.lastActor = pid;
  
  // é€£ç·šæ¨¡å¼ï¼šç™¼é€åƒæ“ä½œå’ŒåŒæ­¥ç‹€æ…‹
  if (isOnlineMode && socket) {
    if (pid === mySeat) {
      sendPlayerAction('chow', { tile: tileKey(tile), pattern: pattern });
      syncGameStateToServer();
    } else if (isHost && !onlinePlayers.some(op => op.seat === pid)) {
      // æˆ¿ä¸»æ§åˆ¶ AI åƒç‰Œ
      syncGameStateToServer();
    }
  }
  
  // ç»§ç»­æ¸¸æˆï¼šåˆ¤æ–­ä¸‹ä¸€ä¸ªç©å®¶
  const myPSeat = getMyPlayerSeat();
  if (pid === myPSeat) {
    // è½®åˆ°è‡ªå·±ï¼Œç­‰å¾…å‡ºç‰Œ
    log('ğŸ‘‰ è¼ªåˆ°ä½ äº†ï¼Œè«‹å‡ºç‰Œ');
  } else {
    console.log('doChow: ä¸æ˜¯å½“å‰ç©å®¶ï¼Œç»§ç»­æ¸¸æˆ, pid:', pid, ', S.turn:', S.turn);
    if (!isOnlineMode) {
      // å•æœºæ¨¡å¼ï¼Œç›´æ¥è°ƒç”¨ stepNext
      stepNext();
    } else {
      // è¿çº¿æ¨¡å¼ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯AI
      if (!onlinePlayers || onlinePlayers.length === 0) {
        console.error('âŒ doChow: onlinePlayers æœªå®šç¾©æˆ–ç‚ºç©ºï¼');
        return;
      }
      const isAI = !onlinePlayers.some(op => op.seat === pid);
      console.log('doChow: isAI:', isAI, ', isHost:', isHost, ', pid:', pid);
      if (isAI && isHost) {
        // AIç©å®¶ï¼Œæˆ¿ä¸»æ§åˆ¶
        console.log('doChow: è°ƒç”¨ stepNext ç»§ç»­AIç©å®¶å›åˆ');
        setTimeout(stepNext, 300);
      } else if (!isAI) {
        // çœŸäººç©å®¶ä¼šé€šè¿‡çŠ¶æ€åŒæ­¥è‡ªåŠ¨è§¦å‘ä»–ä»¬çš„å›åˆ
        console.log('doChow: çœŸäººç©å®¶ï¼Œç­‰å¾…çŠ¶æ€åŒæ­¥');
      } else {
        console.log('doChow: éæˆ¿ä¸»ï¼Œç­‰å¾…çŠ¶æ€åŒæ­¥');
      }
    }
  }
}

function canPong(pid, tile) {
  const pl = S.players[pid];
  if (pl.melds.length >= 5) return false;
  const k = tileKey(tile);
  const cnt = pl.hand.filter(t => tileKey(t) === k).length;
  return cnt >= 2;
}

function canKong(pid, tile) {
  const pl = S.players[pid];
  if (countKongs(pl) >= 3) return false;
  if (pl.melds.length >= 5) return false;
  const k = tileKey(tile);
  const cnt = pl.hand.filter(t => tileKey(t) === k).length;
  return cnt >= 3;
}

function canConcealedKong(pid) {
  const pl = S.players[pid];
  if (countKongs(pl) >= 3) return [];
  if (pl.melds.length >= 5) return [];
  if ((S.wall.length + S.deadWall.length) <= 3) return [];
  // æª¢æŸ¥æ‰‹ç‰Œå’Œå‰›æ‘¸åˆ°çš„ç‰Œï¼ˆdrawnTileï¼‰
  const allTiles = pl.hand.slice();
  if (pl.drawnTile) {
    allTiles.push(pl.drawnTile);
  }
  const counts = countByKey(allTiles);
  return Object.keys(counts).filter(k => counts[k] >= 4);
}

function canAddedKong(pid) {
  const pl = S.players[pid];
  const res = [];
  if ((S.wall.length + S.deadWall.length) <= 3) return res;
  if (countKongs(pl) >= 3) return res;
  pl.melds.forEach((m, idx) => {
    if (m.type === 'pong') {
      const k = tileKey(m.tiles[0]);
      // æª¢æŸ¥æ‰‹ç‰Œä¸­æ˜¯å¦æœ‰ç¬¬4å¼µï¼ŒåŒ…æ‹¬å‰›æ‘¸åˆ°çš„ç‰Œï¼ˆdrawnTileï¼‰
      const hasFourth = pl.hand.some(t => tileKey(t) === k) || 
                       (pl.drawnTile && tileKey(pl.drawnTile) === k);
      if (hasFourth) {
        res.push({ meldIndex: idx, key: k });
      }
    }
  });
  return res;
}

function doConcealedKong(pid, key) {
  const pl = S.players[pid];
  const tiles = [];
  
  // å…ˆå¾æ‰‹ç‰Œä¸­æ”¶é›†ç›¸åŒkeyçš„ç‰Œ
  for (let i = pl.hand.length - 1; i >= 0; i--) {
    const t = pl.hand[i];
    if (tileKey(t) === key) {
      tiles.push(pl.hand.splice(i, 1)[0]);
      if (tiles.length === 4) break;
    }
  }
  
  // å¦‚æœé‚„æ²’æ”¶é›†åˆ°4å¼µï¼Œæª¢æŸ¥drawnTile
  if (tiles.length < 4 && pl.drawnTile && tileKey(pl.drawnTile) === key) {
    // æ‰¾åˆ°drawnTileåœ¨æ‰‹ç‰Œä¸­çš„ä½ç½®ä¸¦ç§»é™¤
    const drawnIdx = pl.hand.findIndex(t => t === pl.drawnTile);
    if (drawnIdx >= 0) {
      tiles.push(pl.hand.splice(drawnIdx, 1)[0]);
    } else {
      // å¦‚æœdrawnTileä¸åœ¨æ‰‹ç‰Œä¸­ï¼Œç›´æ¥ä½¿ç”¨
      tiles.push(pl.drawnTile);
      pl.drawnTile = null;
    }
  }
  
  // ç¢ºä¿æ”¶é›†åˆ°4å¼µç‰Œ
  if (tiles.length !== 4) {
    log(`âš ï¸ æš—æ§“éŒ¯èª¤ï¼šåªæ”¶é›†åˆ° ${tiles.length} å¼µç‰Œï¼Œéœ€è¦4å¼µ`);
    // å°‡å·²ç§»é™¤çš„ç‰Œæ”¾å›æ‰‹ç‰Œ
    pl.hand.push(...tiles);
    return;
  }
  
  pl.melds.push({ type: 'kong', tiles: tiles, concealed: true });
  S.kongCount++;
  const myPSeatCK = getMyPlayerSeat();
  if (pid === myPSeatCK) {
    log(`ğŸ’¥ ${playerName(pid)} æš—æ§“ ${keyToText(key)}`);
  } else {
    log(`ğŸ’¥ ${playerName(pid)} æš—æ§“`);
  }
  showEffect('ğŸ’¥ æš—æ§“', '#a855f7');
  SoundEffects.kong();
  
  // èªéŸ³æ’­å ±ï¼ˆæ‰€æœ‰ç©å®¶éƒ½æ’­å ±ï¼‰
  speakRandom('kong');
  
  if (S.deadWall.length > 0) {
    const newTile = S.deadWall.pop();
    pl.hand.push(newTile); // å…ˆåŠ å…¥æ‰‹ç‰Œ
    pl.drawnTile = newTile; // è¨­ç½®ç‚ºdrawnTileï¼Œæœƒé¡¯ç¤ºåœ¨æœ€å³é‚Š
  } else if (S.wall.length > 0) {
    const newTile = S.wall.pop();
    pl.hand.push(newTile); // å…ˆåŠ å…¥æ‰‹ç‰Œ
    pl.drawnTile = newTile; // è¨­ç½®ç‚ºdrawnTileï¼Œæœƒé¡¯ç¤ºåœ¨æœ€å³é‚Š
  }
  // å‰©ä½™ç‰Œæ•° = å®é™…å¯ä¾›æ‘¸æ‰“çš„ç‰Œæ•°ï¼ˆä¸åŒ…æ‹¬ç‹ç‰Œï¼‰
  S.remain = S.wall.length;
  renderAll();
  
  const t = pl.drawnTile || pl.hand[pl.hand.length - 1];
  if (pid === myPSeatCK) {
    // å¦‚æœå·²ç¶“å ±è½ï¼Œè‡ªå‹•è™•ç†
    if (pl.declaredListen) {
      if (isWinningNow(pl.hand, pl.melds, t)) {
        // è‡ªå‹•èƒ¡ç‰Œ
        setTimeout(() => {
          doWin(myPSeatCK, -1, t, true);
        }, 500);
        return;
      }
      // å¦‚æœä¸èƒ½èƒ¡ï¼Œè‡ªå‹•ä¸Ÿæ‰æ‘¸åˆ°çš„ç‰Œï¼ˆå¦‚æœèƒ½ä¿æŒè½ç‰Œï¼‰
      if (pl.drawnTile) {
        const testHand = pl.hand.filter(ht => ht !== pl.drawnTile);
        if (isListening(testHand, pl.melds)) {
          setTimeout(() => {
            discard(myPSeatCK, pl.drawnTile);
          }, 500);
          return;
        }
      }
    } else {
      if (isWinningNow(pl.hand, pl.melds, t)) {
        document.getElementById('btnHu').disabled = false;
        log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
      }
    }
  } else {
    if (isWinningNow(pl.hand, pl.melds, t)) {
      doWin(pid, -1, t, true);
      return;
    }
    setTimeout(stepAI, 1000 + Math.random() * 1000);
  }
  
  S.lastAction = 'concealedKong';
  S.lastActor = pid;
  
  // é€£ç·šæ¨¡å¼ï¼šåŒæ­¥ç‹€æ…‹
  if (isOnlineMode && socket) {
    if (pid === mySeat) {
      syncGameStateToServer();
    } else if (isHost && !onlinePlayers.some(op => op.seat === pid)) {
      // æˆ¿ä¸»æ§åˆ¶ AI æš—æ§“
      syncGameStateToServer();
    }
  }
}

function doAddedKong(pid, meldIndex) {
  const pl = S.players[pid];
  const meld = pl.melds[meldIndex];
  if (!meld || meld.type !== 'pong') return;
  const key = tileKey(meld.tiles[0]);
  let idx = -1;
  let tile = null;
  
  // å…ˆæª¢æŸ¥æ‰‹ç‰Œä¸­æ˜¯å¦æœ‰ç¬¬4å¼µ
  for (let i = 0; i < pl.hand.length; i++) {
    if (tileKey(pl.hand[i]) === key) {
      idx = i;
      tile = pl.hand[i];
      break;
    }
  }
  
  // å¦‚æœæ‰‹ç‰Œä¸­æ²’æœ‰ï¼Œæª¢æŸ¥æ˜¯å¦å‰›æ‘¸åˆ°çš„ç‰Œï¼ˆdrawnTileï¼‰
  if (idx < 0 && pl.drawnTile && tileKey(pl.drawnTile) === key) {
    tile = pl.drawnTile;
    // æ‰¾åˆ°drawnTileåœ¨æ‰‹ç‰Œä¸­çš„ä½ç½®
    idx = pl.hand.findIndex(t => t === pl.drawnTile);
  }
  
  if (idx < 0 || !tile) return;
  
  // å…ˆä¸ç§»é™¤ï¼Œå…ˆæª¢æŸ¥æ¶æ§“
  
  // æª¢æŸ¥æ˜¯å¦æœ‰å…¶ä»–äººå¯ä»¥æ¶æ§“èƒ¡
  for (let other = 0; other < 4; other++) {
    if (other !== pid && canWinOn(other, tile)) {
      // æœ‰äººå¯ä»¥æ¶æ§“ï¼ŒåŸ·è¡Œæ¶æ§“èƒ¡
      S.robKong = true;
      pl.hand.splice(idx, 1); // ç¾åœ¨æ‰ç§»é™¤ç‰Œ
      doWin(other, pid, tile, false);
      return;
    }
  }
  
  // æ²’æœ‰äººæ¶æ§“ï¼ŒåŸ·è¡ŒåŠ æ§“
  pl.hand.splice(idx, 1);
  meld.tiles.push(tile);
  meld.type = 'kong';
  meld.added = true;
  S.anyOpenMeld = true;
  S.kongCount++;
  log(`ğŸ’¥ ${playerName(pid)} åŠ æ§“ ${keyToText(key)}`);
  showEffect('ğŸ’¥ æ§“', '#f97316');
  SoundEffects.kong();
  
  // èªéŸ³æ’­å ±ï¼ˆæ‰€æœ‰ç©å®¶éƒ½æ’­å ±ï¼‰
  speakRandom('kong');
  
  if (S.deadWall.length > 0) {
    const newTile = S.deadWall.pop();
    pl.hand.push(newTile); // å…ˆåŠ å…¥æ‰‹ç‰Œ
    pl.drawnTile = newTile; // è¨­ç½®ç‚ºdrawnTileï¼Œæœƒé¡¯ç¤ºåœ¨æœ€å³é‚Š
  } else if (S.wall.length > 0) {
    const newTile = S.wall.pop();
    pl.hand.push(newTile); // å…ˆåŠ å…¥æ‰‹ç‰Œ
    pl.drawnTile = newTile; // è¨­ç½®ç‚ºdrawnTileï¼Œæœƒé¡¯ç¤ºåœ¨æœ€å³é‚Š
  }
  // å‰©ä½™ç‰Œæ•° = å®é™…å¯ä¾›æ‘¸æ‰“çš„ç‰Œæ•°ï¼ˆä¸åŒ…æ‹¬ç‹ç‰Œï¼‰
  S.remain = S.wall.length;
  pl.rinshan = true;
  renderAll();
  
  const myPSeatAK = getMyPlayerSeat();
  const t = pl.drawnTile || pl.hand[pl.hand.length - 1];
  if (pid === myPSeatAK) {
    // å¦‚æœå·²ç¶“å ±è½ï¼Œè‡ªå‹•è™•ç†
    if (pl.declaredListen) {
      if (isWinningNow(pl.hand, pl.melds, t)) {
        // è‡ªå‹•èƒ¡ç‰Œ
        setTimeout(() => {
          doWin(myPSeatAK, -1, t, true);
        }, 500);
        return;
      }
      // å¦‚æœä¸èƒ½èƒ¡ï¼Œè‡ªå‹•ä¸Ÿæ‰æ‘¸åˆ°çš„ç‰Œï¼ˆå¦‚æœèƒ½ä¿æŒè½ç‰Œï¼‰
      if (pl.drawnTile) {
        const testHand = pl.hand.filter(ht => ht !== pl.drawnTile);
        if (isListening(testHand, pl.melds)) {
          setTimeout(() => {
            discard(myPSeatAK, pl.drawnTile);
          }, 500);
          return;
        }
      }
    } else {
      if (isWinningNow(pl.hand, pl.melds, t)) {
        document.getElementById('btnHu').disabled = false;
        log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
      }
    }
  } else {
    if (isWinningNow(pl.hand, pl.melds, t)) {
      doWin(pid, -1, t, true);
      return;
    }
    setTimeout(stepAI, 1000 + Math.random() * 1000);
  }
  
  S.lastAction = 'addedKong';
  S.lastActor = pid;
  
  // é€£ç·šæ¨¡å¼ï¼šåŒæ­¥ç‹€æ…‹
  if (isOnlineMode && socket) {
    if (pid === mySeat) {
      syncGameStateToServer();
    } else if (isHost && !onlinePlayers.some(op => op.seat === pid)) {
      // æˆ¿ä¸»æ§åˆ¶ AI åŠ æ§“
      syncGameStateToServer();
    }
  }
}

function doPong(pid, tile) {
  const pl = S.players[pid];
  const k = tileKey(tile);
  const tiles = [tile];
  
  // å¾åŸç©å®¶çš„æ¨ç‰Œå€ç§»é™¤é€™å¼µç‰Œ
  if (S.lastDiscard && S.lastDiscard.from !== undefined) {
    const fromPlayer = S.players[S.lastDiscard.from];
    const discardIndex = fromPlayer.discards.findIndex(t => 
      t === tile || (t.suit === tile.suit && t.rank === tile.rank && (!t.name || t.name === tile.name))
    );
    if (discardIndex >= 0) {
      fromPlayer.discards.splice(discardIndex, 1);
    }
  }
  
  for (let i = 0; i < 2; i++) {
    const idx = pl.hand.findIndex(t => tileKey(t) === k);
    if (idx >= 0) {
      tiles.push(pl.hand.splice(idx, 1)[0]);
    }
  }
  
  S.lastAction = 'pong';
  S.lastActor = pid;
  pl.melds.push({ type: 'pong', tiles });
  S.anyOpenMeld = true;
  log(`ğŸ”¥ ${playerName(pid)} ç¢°äº† ${keyToText(k)}`);
  showEffect('ğŸ”¥ ç¢°', '#f0c14b');
  SoundEffects.pong();
  
  // èªéŸ³æ’­å ±ï¼ˆæ‰€æœ‰ç©å®¶éƒ½æ’­å ±ï¼‰
  speakRandom('pong');
  
  S.turn = pid;
  S.lastDiscard = null;
  S.waitReact = null;
  hideReactionPanel();
  renderAll();
  
  // é€£ç·šæ¨¡å¼ï¼šç™¼é€ç¢°æ“ä½œå’ŒåŒæ­¥ç‹€æ…‹
  if (isOnlineMode && socket) {
    if (pid === mySeat) {
      sendPlayerAction('pong', { tile: k });
      syncGameStateToServer();
    } else if (isHost && !onlinePlayers.some(op => op.seat === pid)) {
      // æˆ¿ä¸»æ§åˆ¶ AI ç¢°ç‰Œ
      syncGameStateToServer();
    }
  }
  
  // ç»§ç»­æ¸¸æˆï¼šåˆ¤æ–­ä¸‹ä¸€ä¸ªç©å®¶
  const myPSeat = getMyPlayerSeat();
  if (pid === myPSeat) {
    // è½®åˆ°è‡ªå·±ï¼Œç­‰å¾…å‡ºç‰Œ
    log('ğŸ‘‰ è¼ªåˆ°ä½ äº†ï¼Œè«‹å‡ºç‰Œ');
  } else {
    console.log('doPong: ä¸æ˜¯å½“å‰ç©å®¶ï¼Œç»§ç»­æ¸¸æˆ, pid:', pid, ', S.turn:', S.turn);
    if (!isOnlineMode) {
      // å•æœºæ¨¡å¼ï¼Œç›´æ¥è°ƒç”¨ stepNext
      stepNext();
    } else {
      // è¿çº¿æ¨¡å¼ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯AI
      if (!onlinePlayers || onlinePlayers.length === 0) {
        console.error('âŒ doPong: onlinePlayers æœªå®šç¾©æˆ–ç‚ºç©ºï¼');
        return;
      }
      const isAI = !onlinePlayers.some(op => op.seat === pid);
      console.log('doPong: isAI:', isAI, ', isHost:', isHost, ', pid:', pid);
      if (isAI && isHost) {
        // AIç©å®¶ï¼Œæˆ¿ä¸»æ§åˆ¶
        console.log('doPong: è°ƒç”¨ stepNext ç»§ç»­AIç©å®¶å›åˆ');
        setTimeout(stepNext, 300);
      } else if (!isAI) {
        // çœŸäººç©å®¶ä¼šé€šè¿‡çŠ¶æ€åŒæ­¥è‡ªåŠ¨è§¦å‘ä»–ä»¬çš„å›åˆ
        console.log('doPong: çœŸäººç©å®¶ï¼Œç­‰å¾…çŠ¶æ€åŒæ­¥');
      } else {
        console.log('doPong: éæˆ¿ä¸»ï¼Œç­‰å¾…çŠ¶æ€åŒæ­¥');
      }
    }
  }
}

function doKong(pid, tile) {
  const pl = S.players[pid];
  const k = tileKey(tile);
  const tiles = [tile];
  
  // å¾åŸç©å®¶çš„æ¨ç‰Œå€ç§»é™¤é€™å¼µç‰Œ
  if (S.lastDiscard && S.lastDiscard.from !== undefined) {
    const fromPlayer = S.players[S.lastDiscard.from];
    const discardIndex = fromPlayer.discards.findIndex(t => 
      t === tile || (t.suit === tile.suit && t.rank === tile.rank && (!t.name || t.name === tile.name))
    );
    if (discardIndex >= 0) {
      fromPlayer.discards.splice(discardIndex, 1);
    }
  }
  
  for (let i = 0; i < 3; i++) {
    const idx = pl.hand.findIndex(t => tileKey(t) === k);
    if (idx >= 0) {
      tiles.push(pl.hand.splice(idx, 1)[0]);
    }
  }
  pl.melds.push({ type: 'kong', tiles });
  S.anyOpenMeld = true;
  S.kongCount++;
  log(`ğŸ’¥ ${playerName(pid)} æ§“äº† ${keyToText(k)}ï¼Œå¾ç‹ç‰Œè£œç‰Œ`);
  showEffect('ğŸ’¥ æ§“', '#f97316');
  SoundEffects.kong();
  
  // èªéŸ³æ’­å ±ï¼ˆæ‰€æœ‰ç©å®¶éƒ½æ’­å ±ï¼‰
  speakRandom('kong');
  
  if (S.deadWall.length > 0) {
    const newTile = S.deadWall.pop();
    pl.hand.push(newTile); // å…ˆåŠ å…¥æ‰‹ç‰Œ
    pl.drawnTile = newTile; // è¨­ç½®ç‚ºdrawnTileï¼Œæœƒé¡¯ç¤ºåœ¨æœ€å³é‚Š
  } else if (S.wall.length > 0) {
    const newTile = S.wall.pop();
    pl.hand.push(newTile); // å…ˆåŠ å…¥æ‰‹ç‰Œ
    pl.drawnTile = newTile; // è¨­ç½®ç‚ºdrawnTileï¼Œæœƒé¡¯ç¤ºåœ¨æœ€å³é‚Š
  }
  // å‰©ä½™ç‰Œæ•° = å®é™…å¯ä¾›æ‘¸æ‰“çš„ç‰Œæ•°ï¼ˆä¸åŒ…æ‹¬ç‹ç‰Œï¼‰
  S.remain = S.wall.length;
  S.lastAction = 'kong';
  S.lastActor = pid;
  S.turn = pid;
  S.lastDiscard = null;
  S.waitReact = null;
  hideReactionPanel();
  renderAll();
  
  // é€£ç·šæ¨¡å¼ï¼šç™¼é€æ§“æ“ä½œå’ŒåŒæ­¥ç‹€æ…‹
  if (isOnlineMode && socket) {
    if (pid === mySeat) {
      sendPlayerAction('kong', { tile: k });
      syncGameStateToServer();
    } else if (isHost && !onlinePlayers.some(op => op.seat === pid)) {
      // æˆ¿ä¸»æ§åˆ¶ AI æ§“ç‰Œ
      syncGameStateToServer();
    }
  }
  
  const myPSeatKong = getMyPlayerSeat();
  if (pid === myPSeatKong) {
    const me = S.players[myPSeatKong];
    const t = me.drawnTile || me.hand[me.hand.length - 1];
    if (isWinningNow(me.hand, me.melds, t)) {
      document.getElementById('btnHu').disabled = false;
      log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
    }
    if (!me.declaredListen) {
      const kongCount = countKongs(me);
      const totalTiles = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
      const expectedFull = (S.dealer === myPSeatKong ? 17 : 16) + kongCount;
      if (totalTiles === expectedFull) {
        const canListenNow = me.hand.some(tile2 => {
          const testHand = me.hand.filter(t => t !== tile2);
          return isListening(testHand, me.melds);
        });
        if (canListenNow) showListenPanel();
      }
    }
  } else {
    // ä¸æ˜¯å½“å‰ç©å®¶ï¼Œç»§ç»­æ¸¸æˆ
    console.log('doKong: ä¸æ˜¯å½“å‰ç©å®¶ï¼Œç»§ç»­æ¸¸æˆ, pid:', pid, ', S.turn:', S.turn);
    if (!isOnlineMode) {
      // å•æœºæ¨¡å¼ï¼Œç›´æ¥è°ƒç”¨ stepNext
      stepNext();
    } else {
      // è¿çº¿æ¨¡å¼ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯AI
      if (!onlinePlayers || onlinePlayers.length === 0) {
        console.error('âŒ doKong: onlinePlayers æœªå®šç¾©æˆ–ç‚ºç©ºï¼');
        return;
      }
      const isAI = !onlinePlayers.some(op => op.seat === pid);
      console.log('doKong: isAI:', isAI, ', isHost:', isHost, ', pid:', pid);
      if (isAI && isHost) {
        // AIç©å®¶ï¼Œæˆ¿ä¸»æ§åˆ¶
        console.log('doKong: è°ƒç”¨ stepNext ç»§ç»­AIç©å®¶å›åˆ');
        setTimeout(stepNext, 300);
      } else if (!isAI) {
        // çœŸäººç©å®¶ä¼šé€šè¿‡çŠ¶æ€åŒæ­¥è‡ªåŠ¨è§¦å‘ä»–ä»¬çš„å›åˆ
        console.log('doKong: çœŸäººç©å®¶ï¼Œç­‰å¾…çŠ¶æ€åŒæ­¥');
      } else {
        console.log('doKong: éæˆ¿ä¸»ï¼Œç­‰å¾…çŠ¶æ€åŒæ­¥');
      }
    }
  }
}

/* ========= å‡ºç‰Œèˆ‡åæ‡‰ ========= */
function discard(p, tile) {
  const hand = S.players[p].hand;
  const i = hand.indexOf(tile);
  if (i < 0) return;
  hand.splice(i, 1);
  S.players[p].drawnTile = null;
  S.players[p].discards.push(tile);
  S.lastDiscard = { tile, from: p };
  SoundEffects.discard();
  
  S.lastAction = 'discard';
  S.lastActor = p;
  const tileText = keyToText(tileKey(tile));
  log(`ğŸ´ ${playerName(p)} æ‰“å‡º ${tileText}`);
  
  // èªéŸ³æ’­å ±ä¸Ÿç‰Œï¼ˆæ‰€æœ‰ç©å®¶éƒ½æ’­å ±ï¼‰
  const speechText = tileNameForSpeech(tileText);
  speakText(speechText, { rate: 1.0, pitch: 1.0, volume: 0.8 });
  
  S.players[p].rinshan = false;
  renderAll();
  
  // é€£ç·šæ¨¡å¼ï¼šç™¼é€å‡ºç‰Œæ“ä½œå’ŒåŒæ­¥ç‹€æ…‹
  if (isOnlineMode && socket) {
    if (p === mySeat) {
      // è‡ªå·±å‡ºç‰Œï¼šç™¼é€æ“ä½œä¸¦åŒæ­¥
      sendPlayerAction('discard', { tile: tileKey(tile) });
      syncGameStateToServer();
    } else if (isHost && !onlinePlayers.some(op => op.seat === p)) {
      // æˆ¿ä¸»æ§åˆ¶ AI å‡ºç‰Œï¼šåªåŒæ­¥ç‹€æ…‹
      syncGameStateToServer();
    }
  }
  
  {
    const pl = S.players[p];
    const kc = countKongs(pl);
    const totalP = pl.hand.length + pl.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    const expFull = (S.dealer === p ? 17 : 16) + kc;
    const expEmpty = (S.dealer === p ? 16 : 15) + kc;
    let ting = false;
    if (totalP === expFull) {
      ting = pl.hand.some(tt => {
        const test = pl.hand.filter(x => x !== tt);
        return isListening(test, pl.melds);
      });
    } else if (totalP === expEmpty) {
      ting = isListening(pl.hand, pl.melds);
    }
    if (ting) {
      const waits = calcWaitingTiles(pl.hand, pl.melds);
      pl.waitKeys = waits.slice();
      if (waits.length > 0 && p === getMyPlayerSeat()) {
        const waitText = waits.map(k => keyToText(k)).join(' ');
        log('ğŸ‘‚ ç­‰ç‰Œï¼š' + waitText);
      }
    } else {
      pl.waitKeys = [];
    }
  }
  
  let reactions = [];
  // æŒ‰ç…§å„ªå…ˆç´šé †åºæª¢æŸ¥ï¼šèƒ¡ > æ§“/ç¢° > åƒ
  // æ³¨æ„ï¼šå¦‚æœåŒæ™‚å¯ä»¥æ§“å’Œç¢°ï¼Œå…©å€‹é¸é …éƒ½è¦é¡¯ç¤ºï¼ˆç©å®¶å¯ä»¥é¸æ“‡ï¼‰
  for (let k = 1; k <= 3; k++) {
    const pid = (p + k) % 4;
    if (pid === p) continue;
    
    // å„ªå…ˆç´š1ï¼šèƒ¡ç‰Œï¼ˆæœ€é«˜å„ªå…ˆç´šï¼Œå¦‚æœå¯èƒ¡å‰‡åªé¡¯ç¤ºèƒ¡ï¼‰
    if (canWinOn(pid, tile)) {
      reactions.push({ pid, type: 'hu', tile, priority: 1 });
      continue; // å¦‚æœèƒ½èƒ¡ï¼Œä¸æª¢æŸ¥å…¶ä»–åæ‡‰
    }
    
    // å„ªå…ˆç´š2ï¼šæ§“å’Œç¢°ï¼ˆåŒä¸€å›åˆåªèƒ½æ“‡ä¸€ï¼Œæ§“å„ªå…ˆç´šæ›´é«˜ï¼‰
    // å…ˆæª¢æŸ¥æ§“ï¼ˆå„ªå…ˆç´šæ›´é«˜ï¼‰
    if (canKong(pid, tile)) {
      reactions.push({ pid, type: 'kong', tile, priority: 2 });
      // å¦‚æœèƒ½æ§“ï¼Œå°±ä¸é¡¯ç¤ºç¢°ï¼ˆåŒä¸€å›åˆåªèƒ½æ“‡ä¸€ï¼‰
    } else if (canPong(pid, tile)) {
      // å¦‚æœä¸èƒ½æ§“ï¼Œæ‰æª¢æŸ¥ç¢°
      reactions.push({ pid, type: 'pong', tile, priority: 3 });
    }
    
    // å„ªå…ˆç´š4ï¼šåƒï¼ˆåªèƒ½åƒä¸Šå®¶çš„ç‰Œï¼Œå¦‚æœæ²’æœ‰æ§“å’Œç¢°æ‰æª¢æŸ¥ï¼‰
    if (!canKong(pid, tile) && !canPong(pid, tile)) {
      const chowPatterns = canChow(pid, tile);
      if (chowPatterns.length > 0) {
        reactions.push({ pid, type: 'chow', tile, patterns: chowPatterns, priority: 4 });
      }
    }
  }
  
  if (reactions.length > 0) {
    S.waitReact = reactions;
    const myPSeatDiscard = getMyPlayerSeat();
    
    // é€£ç·šæ¨¡å¼ï¼šåŒæ­¥ç‹€æ…‹çµ¦å…¶ä»–ç©å®¶ï¼Œè®“ä»–å€‘çŸ¥é“æœ‰åæ‡‰å¯ä»¥é¸æ“‡
    if (isOnlineMode && socket) {
      const isAI = !onlinePlayers.some(op => op.seat === p);
      if (p === mySeat || (isHost && isAI)) {
        syncGameStateToServer();
      }
    }
    
    // æª¢æŸ¥ç•¶å‰ç©å®¶æ˜¯å¦èƒ½èƒ¡ï¼ˆæ¦®èƒ¡ï¼‰
    const myHuReact = reactions.find(r => r.pid === myPSeatDiscard && r.type === 'hu');
    if (myHuReact) {
      const me = S.players[myPSeatDiscard];
      // å¦‚æœå·²ç¶“å ±è½ï¼Œè‡ªå‹•åŸ·è¡Œæ¦®èƒ¡
      if (me.declaredListen) {
        setTimeout(() => {
          doWin(myPSeatDiscard, p, myHuReact.tile, false);
        }, 500); // ç¨å¾®å»¶é²ï¼Œè®“ç©å®¶çœ‹åˆ°æ‰“å‡ºçš„ç‰Œ
        return;
      }
    }
    
    // å¦‚æœå·²ç¶“å ±è½ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰å¯ä»¥è‡ªå‹•åŸ·è¡Œçš„æ§“
    const me = S.players[myPSeatDiscard];
    if (me.declaredListen) {
      const kongReact = reactions.find(r => r.pid === myPSeatDiscard && r.type === 'kong');
      if (kongReact) {
        // æª¢æŸ¥æ§“å¾Œæ˜¯å¦æœƒç ´å£è½ç‰Œ
        const testHand = me.hand.filter(ht => ht !== tile);
        const testMelds = [...me.melds];
        // æ¨¡æ“¬æ§“ï¼šå°‡tileåŠ å…¥æ–°çš„meld
        testMelds.push({ type: 'kong', tiles: [tile] });
        
        // æª¢æŸ¥æ§“å¾Œæ˜¯å¦é‚„èƒ½è½ç‰Œ
        if (isListening(testHand, testMelds)) {
          // è‡ªå‹•æ§“ï¼ˆä¸æœƒç ´å£è½ç‰Œï¼‰
          setTimeout(() => {
            doKong(myPSeatDiscard, tile);
          }, 500);
          return;
        }
        // å¦‚æœæœƒç ´å£è½ç‰Œï¼Œä¸åŸ·è¡Œæ§“ï¼Œç¹¼çºŒæµç¨‹
      }
    }
    
    if (reactions.some(r => r.pid === myPSeatDiscard)) {
      // å¦‚æœå·²ç¶“å ±è½ï¼Œä¸é¡¯ç¤ºåæ‡‰é¢æ¿ï¼Œç›´æ¥è‡ªå‹•è™•ç†æˆ–è·³é
      if (me.declaredListen) {
        // å ±è½å¾Œåªèƒ½èƒ¡æˆ–æ§“ï¼Œå¦‚æœæ²’æœ‰å¯åŸ·è¡Œçš„ï¼Œç›´æ¥è·³é
        const validReactions = reactions.filter(r => r.pid === myPSeatDiscard && (r.type === 'hu' || r.type === 'kong'));
        if (validReactions.length === 0) {
          clearReactionButtons();
          S.turn = getNextTurn(S.lastDiscard.from);
          S.lastDiscard = null;
          S.waitReact = null;
          stepNext();
          return;
        }
      }
      showReactionPanel(reactions.filter(r => r.pid === myPSeatDiscard));
    } else {
      // æª¢æŸ¥æ˜¯å¦æœ‰çœŸäººç©å®¶å¯ä»¥åæ‡‰
      const humanReactions = reactions.filter(r => {
        return isOnlineMode && onlinePlayers.some(p => p.seat === r.pid);
      });
      
      if (humanReactions.length > 0 && isOnlineMode) {
        // æœ‰çœŸäººç©å®¶å¯ä»¥åæ‡‰ï¼Œç­‰å¾…ä»–å€‘çš„æ“ä½œ
        console.log('ç­‰å¾…çœŸäººç©å®¶åæ‡‰:', humanReactions.map(r => r.pid));
      } else {
        // åªæœ‰AIå¯ä»¥åæ‡‰ï¼Œåªæœ‰æˆ¿ä¸»è™•ç†AIåæ‡‰
        if (!isOnlineMode || isHost) {
          setTimeout(() => handleAIReaction(reactions), 1000 + Math.random() * 1000);
        }
      }
    }
  } else {
    // ä½¿ç”¨ä¸Ÿç‰Œç©å®¶pä¾†è¨ˆç®—ä¸‹ä¸€å€‹å›åˆï¼Œè€Œä¸æ˜¯S.turn
    const nextTurn = getNextTurn(p);
    S.turn = nextTurn;
    S.lastDiscard = null; // æ¸…é™¤lastDiscardï¼Œå› ç‚ºæ²’æœ‰åæ‡‰
    S.waitReact = null; // æ¸…é™¤waitReact
    // ç§»é™¤å›åˆåˆ‡æ›logé¡¯ç¤º
    renderAll(); // å…ˆæ›´æ–°UIé¡¯ç¤ºå›åˆè®ŠåŒ–
    // ç¡®ä¿æ ‡å¿—å·²é‡ç½®
    isProcessingStep = false;
    
    // é€£ç·šæ¨¡å¼ï¼šåŒæ­¥ç‹€æ…‹
    if (isOnlineMode && socket) {
      const isAI = !onlinePlayers.some(op => op.seat === p);
      if (p === mySeat || (isHost && isAI)) {
        // è‡ªå·±å‡ºç‰Œæˆ–æˆ¿ä¸»æ§åˆ¶ AI å‡ºç‰Œï¼ŒåŒæ­¥ç‹€æ…‹
        syncGameStateToServer();
      }
    }
    
    // åˆ¤æ–·ä¸‹ä¸€å€‹ç©å®¶
    const myPSeat = getMyPlayerSeat();
    if (nextTurn === myPSeat) {
      // è¼ªåˆ°æˆ‘äº†
      setTimeout(stepNext, 300);
    } else if (!isOnlineMode) {
      // å–®æ©Ÿæ¨¡å¼ï¼Œç›´æ¥èª¿ç”¨ stepNext
      stepNext();
    } else {
      // é€£ç·šæ¨¡å¼ï¼Œåˆ¤æ–·æ˜¯å¦æ˜¯AI
      // ç¢ºä¿ onlinePlayers å·²å®šç¾©
      if (!onlinePlayers || onlinePlayers.length === 0) {
        console.error('âŒ discard: onlinePlayers æœªå®šç¾©æˆ–ç‚ºç©ºï¼');
        return;
      }
      const isNextPlayerAI = !onlinePlayers.some(op => op.seat === nextTurn);
      console.log('discard: nextTurn=', nextTurn, ', isNextPlayerAI=', isNextPlayerAI, ', isHost=', isHost);
      if (isNextPlayerAI && isHost) {
        // AIç©å®¶ï¼Œæˆ¿ä¸»æ§åˆ¶
        setTimeout(stepNext, 300);
      }
      // çœŸäººç©å®¶æœƒé€šéç‹€æ…‹åŒæ­¥è‡ªå‹•è§¸ç™¼ä»–å€‘çš„å›åˆ
    }
  }
}

function showReactionPanel(reactions) {
  const myPSeatPanel = getMyPlayerSeat();
  const me = S.players[myPSeatPanel];
  if (me.declaredListen) {
    // å ±è½å¾Œåªèƒ½èƒ¡æˆ–æ§“ï¼Œä¸èƒ½ç¢°æˆ–åƒ
    reactions = reactions.filter(r => r.type === 'hu' || r.type === 'kong');
    if (reactions.length === 0) {
      clearReactionButtons();
      S.turn = getNextTurn(S.lastDiscard.from);
      S.lastDiscard = null;
      S.waitReact = null;
      stepNext();
      return;
    }
    
    // å¦‚æœå·²ç¶“å ±è½ï¼Œè‡ªå‹•è™•ç†æ‰€æœ‰åæ‡‰ï¼ˆä¸é¡¯ç¤ºé¢æ¿ï¼‰
    const huReact = reactions.find(r => r.type === 'hu');
    if (huReact) {
      // è‡ªå‹•èƒ¡ç‰Œ
      setTimeout(() => {
        doWin(myPSeatPanel, S.lastDiscard.from, huReact.tile, false);
      }, 500);
      return;
    }
    
    const kongReact = reactions.find(r => r.type === 'kong');
    if (kongReact) {
      // æª¢æŸ¥æ§“å¾Œæ˜¯å¦æœƒç ´å£è½ç‰Œ
      const testHand = me.hand.filter(ht => ht !== kongReact.tile);
      const testMelds = [...me.melds, { type: 'kong', tiles: [kongReact.tile] }];
      
      if (isListening(testHand, testMelds)) {
        // è‡ªå‹•æ§“ï¼ˆä¸æœƒç ´å£è½ç‰Œï¼‰
        setTimeout(() => {
          doKong(myPSeatPanel, kongReact.tile);
        }, 500);
        return;
      }
      // å¦‚æœæœƒç ´å£è½ç‰Œï¼Œä¸åŸ·è¡Œæ§“ï¼Œç›´æ¥è·³é
      clearReactionButtons();
      S.turn = getNextTurn(S.lastDiscard.from);
      S.lastDiscard = null;
      S.waitReact = null;
      stepNext();
      return;
    }
  }
  
  clearReactionButtons();
  S.currentReactions = reactions;
  
  reactions.forEach(r => {
    if (r.type === 'hu') {
      document.getElementById('btnHu').classList.add('active');
      document.getElementById('btnHu').disabled = false;
    } else if (r.type === 'pong') {
      document.getElementById('btnPong').classList.add('active');
      document.getElementById('btnPong').disabled = false;
    } else if (r.type === 'kong') {
      document.getElementById('btnKong').classList.add('active');
      document.getElementById('btnKong').disabled = false;
    } else if (r.type === 'chow') {
      document.getElementById('btnChow').classList.add('active');
      document.getElementById('btnChow').disabled = false;
    }
  });
  
  document.getElementById('btnPass').classList.add('active');
  document.getElementById('btnPass').disabled = false;
}

function hideReactionPanel() {
  document.getElementById('modalOverlay').classList.remove('show');
}

function clearReactionButtons() {
  const buttons = ['btnHu', 'btnChow', 'btnPong', 'btnKong', 'btnPass'];
  buttons.forEach(id => {
    const btn = document.getElementById(id);
    if (btn) {
      btn.classList.remove('active');
      btn.disabled = true;
    }
  });
}

function handleChowClick() {
  if (!S.currentReactions) return;
  const chowReact = S.currentReactions.find(r => r.type === 'chow');
  if (!chowReact) return;
  
  if (chowReact.patterns && chowReact.patterns.length > 1) {
    showChowSelectionPanel(chowReact);
  } else {
    doChow(chowReact.pid, chowReact.tile, chowReact.patterns[0]);
    clearReactionButtons();
  }
}

function showChowSelectionPanel(chowReact) {
  const overlay = document.getElementById('modalOverlay');
  const content = document.getElementById('modalContent');
  
  let html = '<div class="modal-title">ğŸœ é¸æ“‡åƒæ³•</div>';
  html += '<div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">';
  chowReact.patterns.forEach((pat, idx) => {
    const patText = [...pat].sort((a, b) => a - b).map(r => r).join('-');
    html += `<button class="btn btn-secondary chowOpt" data-idx="${idx}" style="min-width: 80px;">ğŸœ ${patText}</button>`;
  });
  html += '</div>';
  html += '<button class="modal-btn" id="cancelChow" style="background: var(--bg-card); margin-top: 12px;">å–æ¶ˆ</button>';
  
  content.innerHTML = html;
  overlay.classList.add('show');
  
  const opts = content.querySelectorAll('.chowOpt');
  opts.forEach(btn => {
    const idx = parseInt(btn.getAttribute('data-idx'));
    btn.onclick = () => {
      doChow(chowReact.pid, chowReact.tile, chowReact.patterns[idx]);
      overlay.classList.remove('show');
      clearReactionButtons();
    };
  });
  
  document.getElementById('cancelChow').onclick = () => {
    overlay.classList.remove('show');
  };
}

function handlePongClick() {
  if (!S.currentReactions) return;
  const pongReact = S.currentReactions.find(r => r.type === 'pong');
  if (!pongReact) return;
  doPong(pongReact.pid, pongReact.tile);
  clearReactionButtons();
}

function handleKongClick() {
  if (!S.currentReactions) return;
  const kongReact = S.currentReactions.find(r => r.type === 'kong');
  if (!kongReact) return;
  doKong(kongReact.pid, kongReact.tile);
  clearReactionButtons();
}

function handleHuClick() {
  if (!S.currentReactions) return;
  const huReact = S.currentReactions.find(r => r.type === 'hu');
  if (!huReact) return;
  doWin(huReact.pid, S.lastDiscard.from, huReact.tile, false);
  clearReactionButtons();
}

function handlePassClick() {
  clearReactionButtons();
  S.turn = getNextTurn(S.lastDiscard.from);
  S.lastDiscard = null;
  S.waitReact = null;
  S.currentReactions = null;
  stepNext();
}

function showListenPanel() {
  const overlay = document.getElementById('modalOverlay');
  const content = document.getElementById('modalContent');
  
  let html = '<div class="modal-title">ğŸ”” æ˜¯å¦å ±è½ï¼Ÿ</div>';
  html += '<div style="display: flex; gap: 12px; justify-content: center;">';
  html += '<button class="btn btn-primary" id="listenYes" style="flex: 1;">ğŸ”” è½ç‰Œ</button>';
  html += '<button class="btn btn-secondary" id="listenNo" style="flex: 1;">â­ï¸ ä¸è½</button>';
  html += '</div>';
  
  content.innerHTML = html;
  overlay.classList.add('show');
  
  document.getElementById('listenYes').onclick = () => {
    const myPSeatLP = getMyPlayerSeat();
    const me = S.players[myPSeatLP];
    if (!me.declaredListen) {
      me.declaredListen = true;
      me.tingLocked = false;
      updateTianDiTing(myPSeatLP);
      const waitKeys = calcWaitingTiles(me.hand, me.melds);
      const waitText = waitKeys.map(k => keyToText(k)).join(' ');
      if (me.tianTing) {
        log('ğŸ”” ä½ å®£å‘Šå¤©è½ï¼èƒ¡ç‰Œæ™‚å¤š ' + RULES.scoring.HeavenReady + ' å°');
        showEffect('ğŸ”” å¤©è½', '#f0c14b', '52px');
      } else if (me.diTing) {
        log('ğŸ”” ä½ å®£å‘Šåœ°è½ï¼èƒ¡ç‰Œæ™‚å¤š ' + RULES.scoring.EarthReady + ' å°');
        showEffect('ğŸ”” åœ°è½', '#2dd4bf', '48px');
      } else {
        log('ğŸ”” ä½ å®£å‘Šè½ç‰Œï¼èƒ¡ç‰Œæ™‚å¤š 1 å°');
        showEffect('ğŸ”” è½ç‰Œ', '#2dd4bf', '44px');
      }
      SoundEffects.listen();
      log('âš ï¸ è«‹ä¸Ÿä¸€å¼µæ‰‹ç‰Œå¾Œé–å®šè½ç‰Œ');
      if (waitKeys.length > 0) {
        me.waitKeys = waitKeys.slice();
        log('ğŸ‘‚ ç­‰å¾…ç‰Œï¼š' + waitText);
      } else {
        me.waitKeys = [];
      }
    }
    overlay.classList.remove('show');
    renderAll();
  };
  
  document.getElementById('listenNo').onclick = () => {
    overlay.classList.remove('show');
  };
}

function handleAIReaction(reactions) {
  // é€£ç·šæ¨¡å¼ä¸‹ï¼Œåªæœ‰æˆ¿ä¸»è™•ç†AIåæ‡‰
  if (isOnlineMode && !isHost) {
    console.log('handleAIReaction: éæˆ¿ä¸»ï¼Œè·³éAIåæ‡‰è™•ç†');
    return;
  }
  
  // æª¢æŸ¥ reactions æ˜¯å¦æœ‰æ•ˆ
  if (!reactions || !Array.isArray(reactions) || reactions.length === 0) {
    console.warn('âš ï¸ handleAIReaction: reactions ç‚º null æˆ–ç©ºæ•¸çµ„');
    return;
  }
  
  // æª¢æŸ¥ S æ˜¯å¦å­˜åœ¨
  if (!S) {
    console.warn('âš ï¸ handleAIReaction: S ç‚º null');
    return;
  }
  
  // å„ªå…ˆç´š1ï¼šèƒ¡ç‰Œï¼ˆAIèƒ½èƒ¡æ™‚ï¼Œæ ¹æ“šæƒ…æ³æ±ºå®šæ˜¯å¦èƒ¡ï¼‰
  const huReact = reactions.find(r => r.type === 'hu');
  if (huReact) {
    // æª¢æŸ¥ S.lastDiscard æ˜¯å¦å­˜åœ¨
    if (!S.lastDiscard || S.lastDiscard.from === undefined) {
      console.warn('âš ï¸ handleAIReaction: S.lastDiscard ç‚º null æˆ– from æœªå®šç¾©ï¼Œç„¡æ³•è™•ç†èƒ¡ç‰Œåæ‡‰');
      return;
    }
    
    const aiPlayer = S.players[huReact.pid];
    // æª¢æŸ¥æ˜¯å¦å·²ç¶“å ±è½ï¼Œå¦‚æœå ±è½å‰‡å¿…é ˆèƒ¡
    if (aiPlayer.declaredListen) {
      // å ±è½å¾Œèƒ½èƒ¡å¿…é ˆèƒ¡
      doWin(huReact.pid, S.lastDiscard.from, huReact.tile, false);
      return;
    }
    
    // è¨ˆç®—èƒ¡ç‰Œçš„åˆ†æ•¸ï¼Œå¦‚æœåˆ†æ•¸è¼ƒé«˜ï¼Œæ›´å‚¾å‘æ–¼èƒ¡
    const detail = calcFanDetails(huReact.pid, huReact.tile, false);
    const fan = detail.fan;
    
    // æ ¹æ“šå°æ•¸æ±ºå®šèƒ¡ç‰Œæ©Ÿç‡ï¼šå°æ•¸è¶Šé«˜ï¼Œè¶Šå‚¾å‘æ–¼èƒ¡
    let winChance = 0.75; // åŸºç¤æ©Ÿç‡75%
    if (fan >= 5) winChance = 0.95; // 5å°ä»¥ä¸Šï¼Œ95%æ©Ÿç‡èƒ¡
    else if (fan >= 3) winChance = 0.85; // 3å°ä»¥ä¸Šï¼Œ85%æ©Ÿç‡èƒ¡
    else if (fan >= 2) winChance = 0.80; // 2å°ä»¥ä¸Šï¼Œ80%æ©Ÿç‡èƒ¡
    
    // å¦‚æœå‘è½æ•¸ç‚º0ï¼ˆå·²ç¶“è½ç‰Œï¼‰ï¼Œæé«˜èƒ¡ç‰Œæ©Ÿç‡
    const currentShanten = shantenAfterRemove(aiPlayer.hand);
    if (currentShanten === 0) {
      winChance = Math.min(0.95, winChance + 0.15);
    }
    
    // å¦‚æœå°æ‰‹å·²ç¶“å ±è½ï¼Œæ›´å‚¾å‘æ–¼èƒ¡ï¼ˆé¿å…è¢«å°æ‰‹å…ˆèƒ¡ï¼‰
    let hasListeningOpponent = false;
    for (let i = 0; i < 4; i++) {
      if (i !== huReact.pid && S.players[i].declaredListen) {
        hasListeningOpponent = true;
        break;
      }
    }
    if (hasListeningOpponent) {
      winChance = Math.min(0.98, winChance + 0.2);
    }
    
    if (Math.random() < winChance) {
      doWin(huReact.pid, S.lastDiscard.from, huReact.tile, false);
      return;
    }
  }
  
  reactions = reactions.filter(r => {
    const p = S.players[r.pid];
    if (p.declaredListen) {
      return r.type === 'hu' || r.type === 'kong';
    }
    return true;
  });
  
  // å¢å¼·æ§“çš„åæ‡‰åˆ¤æ–·ï¼ˆå„ªå…ˆç´šé«˜æ–¼ç¢°ï¼ŒåŒä¸€å›åˆåªèƒ½æ“‡ä¸€ï¼‰
  const kongReact = reactions.find(r => r.type === 'kong');
  if (kongReact) {
    const me = S.players[kongReact.pid];
    const currentShanten = shantenAfterRemove(me.hand);
    // å¦‚æœå‘è½æ•¸è¼ƒå¤§ï¼Œæ›´å‚¾å‘æ–¼æ§“
    let kongChance = currentShanten >= 3 ? 0.5 : (currentShanten >= 2 ? 0.35 : 0.2);
    // å¦‚æœå·²ç¶“è½ç‰Œï¼Œé™ä½æ§“çš„æ©Ÿç‡ï¼ˆé¿å…ç ´å£è½ç‰Œï¼‰
    if (currentShanten === 0) {
      kongChance = 0.15;
    }
    if (Math.random() < kongChance) {
      doKong(kongReact.pid, kongReact.tile);
      // doKong å‡½æ•°ä¼šåœ¨ç»“å°¾è°ƒç”¨ stepNextï¼Œä¸éœ€è¦è¿™é‡Œå†è°ƒç”¨
      return;
    }
    // å¦‚æœAIé¸æ“‡ä¸æ§“ï¼Œä¹Ÿä¸åŸ·è¡Œç¢°ï¼ˆåŒä¸€å›åˆåªèƒ½æ“‡ä¸€ï¼‰
    // ç›´æ¥è·³éï¼Œä¸åŸ·è¡Œç¢°
  }
  
  // å¢å¼·ç¢°çš„åæ‡‰åˆ¤æ–·ï¼ˆåªæœ‰åœ¨æ²’æœ‰æ§“é¸é …æ™‚æ‰åŸ·è¡Œï¼‰
  const pongReact = reactions.find(r => r.type === 'pong');
  if (pongReact && !kongReact) {
    const me = S.players[pongReact.pid];
    const currentShanten = shantenAfterRemove(me.hand);
    // æ ¹æ“šå‘è½æ•¸æ±ºå®šç¢°çš„æ©Ÿç‡
    let pongChance = currentShanten >= 3 ? 0.5 : (currentShanten >= 2 ? 0.4 : 0.25);
    // å¦‚æœå·²ç¶“è½ç‰Œï¼Œé™ä½ç¢°çš„æ©Ÿç‡
    if (currentShanten === 0) {
      pongChance = 0.2;
    }
    // å¦‚æœå·²ç¶“å ±è½ï¼Œåªèƒ½ç¢°æˆ–èƒ¡
    if (me.declaredListen) {
      pongChance = 0.3;
    }
    if (Math.random() < pongChance) {
    doPong(pongReact.pid, pongReact.tile);
    // doPong å‡½æ•°ä¼šåœ¨ç»“å°¾è°ƒç”¨ stepNextï¼Œä¸éœ€è¦è¿™é‡Œå†è°ƒç”¨
    return;
    }
  }
  
  // å¢å¼·åƒçš„åæ‡‰åˆ¤æ–·
  const chowReact = reactions.find(r => r.type === 'chow');
  if (chowReact) {
    const me = S.players[chowReact.pid];
    const pattern = chowReact.patterns[0];
    const tile = chowReact.tile;
    const suit = tile.suit;
    
    const afterChow = me.hand.filter(t => {
      const key = tileKey(t);
      const needed = pattern.map(r => suit + r);
      const idx = needed.indexOf(key);
      if (idx >= 0) {
        needed.splice(idx, 1);
        return false;
      }
      return true;
    });
    
    const shBefore = shantenAfterRemove(me.hand);
    const shAfter = shantenAfterRemove(afterChow);
    
    // å¦‚æœåƒèƒ½æ”¹å–„å‘è½æ•¸ï¼Œæ›´å‚¾å‘æ–¼åƒ
    if (shAfter < shBefore) {
      const improvement = shBefore - shAfter;
      let chowChance = 0.3 + (improvement * 0.25); // æ”¹å–„è¶Šå¤šï¼Œæ©Ÿç‡è¶Šé«˜
      if (shAfter === 0) chowChance += 0.2; // å¦‚æœèƒ½è½ç‰Œï¼Œæé«˜æ©Ÿç‡
      if (Math.random() < chowChance) {
        doChow(chowReact.pid, chowReact.tile, pattern);
        // doChow å‡½æ•°ä¼šåœ¨ç»“å°¾è°ƒç”¨ stepNextï¼Œä¸éœ€è¦è¿™é‡Œå†è°ƒç”¨
        return;
      }
    } else if (shAfter === shBefore && Math.random() < 0.25) {
      // å³ä½¿ä¸æ”¹å–„å‘è½æ•¸ï¼Œä¹Ÿæœ‰å°æ©Ÿç‡åƒï¼ˆç‚ºäº†æ”¹è®Šç‰Œå‹ï¼‰
      doChow(chowReact.pid, chowReact.tile, pattern);
      // doChow å‡½æ•°ä¼šåœ¨ç»“å°¾è°ƒç”¨ stepNextï¼Œä¸éœ€è¦è¿™é‡Œå†è°ƒç”¨
      return;
    }
  }
  
  // æª¢æŸ¥ S.lastDiscard æ˜¯å¦å­˜åœ¨
  if (!S.lastDiscard || S.lastDiscard.from === undefined) {
    console.warn('âš ï¸ handleAIReaction: S.lastDiscard ç‚º null æˆ– from æœªå®šç¾©ï¼Œç„¡æ³•è¨ˆç®—ä¸‹ä¸€å€‹å›åˆ');
    // å¦‚æœæ²’æœ‰ lastDiscardï¼Œä½¿ç”¨ç•¶å‰å›åˆçš„ä¸‹ä¸€å€‹ç©å®¶
    S.turn = (S.turn + 1) % 4;
  } else {
    S.turn = getNextTurn(S.lastDiscard.from);
  }
  
  S.lastDiscard = null;
  S.waitReact = null;
  
  // é€£ç·šæ¨¡å¼ï¼šæˆ¿ä¸»æ§åˆ¶ AI è·³éåæ‡‰å¾ŒåŒæ­¥ç‹€æ…‹
  if (isOnlineMode && isHost && socket) {
    syncGameStateToServer();
  }
  
  stepNext();
}

function canWinOn(pid, tile) {
  const pl = S.players[pid];
  const tmp = pl.hand.concat([tile]);
  return isWinningNow(tmp, pl.melds, tile);
}

// è¨ˆç®—é€£èŠå°æ•¸ï¼š2n + 1ï¼ˆnç‚ºé€£èŠæ¬¡æ•¸ï¼‰
function calcDealerStreakFan(streak) {
  // streak = 0 è¡¨ç¤ºèµ·èŠï¼ˆç¬¬ä¸€æ¬¡ç•¶èŠï¼‰ï¼Œå°æ•¸ç‚º 1
  // streak = 1 è¡¨ç¤ºé€£ä¸€ï¼Œå°æ•¸ç‚º 2Ã—1+1 = 3
  // streak = 2 è¡¨ç¤ºé€£äºŒï¼Œå°æ•¸ç‚º 2Ã—2+1 = 5
  // ä»¥æ­¤é¡æ¨
  return 2 * streak + 1;
}

function doWin(winner, from, tile, selfDraw) {
  S.winner = winner;
  S.fromPlayer = from;
  S.winTile = tile;
  S.phase = 'end';
  showEffect('ğŸ‰ èƒ¡äº†ï¼', '#f0c14b', '64px');
  SoundEffects.win();
  
  // èªéŸ³æ’­å ±ï¼ˆæ‰€æœ‰ç©å®¶éƒ½æ’­å ±ï¼‰
  if (selfDraw) {
    speakRandom('win', 'è‡ªæ‘¸ï¼');
  } else {
    speakRandom('win', 'é»èƒ¡ï¼');
  }
  
  const detail = calcFanDetails(winner, tile, selfDraw);
  const fan = detail.fan;
  
  // è¨ˆç®—é€£èŠå°æ•¸
  // æ³¨æ„ï¼šå¦‚æœèŠå®¶èƒ¡ç‰Œï¼Œç•¶å‰é€™ä¸€å±€çš„é€£èŠæ¬¡æ•¸æ˜¯ S.dealerStreakï¼ˆå·²ç¶“åŒ…å«ç•¶å‰å±€ï¼‰
  // ä¾‹å¦‚ï¼šå¦‚æœ S.dealerStreak = 5ï¼Œè¡¨ç¤ºå·²ç¶“é€£èŠ5æ¬¡ï¼Œç•¶å‰æ˜¯ç¬¬6æ¬¡ï¼Œæ‰€ä»¥å°æ•¸ = 2Ã—5+1 = 11å°
  // ä½†å¯¦éš›ä¸Šï¼Œå¦‚æœèŠå®¶ç¹¼çºŒç•¶èŠï¼Œä¸‹ä¸€å±€æœƒæ˜¯ S.dealerStreak + 1 = 6æ¬¡
  // æ‰€ä»¥ç•¶å‰é€™ä¸€å±€çš„é€£èŠæ¬¡æ•¸æ‡‰è©²æ˜¯ S.dealerStreakï¼ˆå¦‚æœèŠå®¶èƒ¡ç‰Œæˆ–æµå±€é€£èŠï¼‰
  // å¦‚æœèŠå®¶è¼¸äº†ï¼Œå‰‡ä¸è¨ˆç®—é€£èŠå°æ•¸
  const isDealer = winner === S.dealer;
  const isFromDealer = from === S.dealer;
  
  // ç¢ºå®šç•¶å‰é€™ä¸€å±€çš„é€£èŠæ¬¡æ•¸
  let currentDealerStreak = 0;
  if (isDealer || isFromDealer) {
    // èŠå®¶èƒ¡ç‰Œæˆ–é–’å®¶èƒ¡èŠå®¶ï¼šä½¿ç”¨ S.dealerStreakï¼ˆç•¶å‰å±€çš„é€£èŠæ¬¡æ•¸ï¼‰
    currentDealerStreak = S.dealerStreak || 0;
  }
  
  const streakFan = calcDealerStreakFan(currentDealerStreak);
  
  // èª¿è©¦ä¿¡æ¯ï¼šç¢ºèªé€£èŠå°æ•¸è¨ˆç®—
  if (currentDealerStreak > 0) {
    console.log(`ç•¶å‰é€£èŠ${currentDealerStreak}æ¬¡ï¼Œè¨ˆç®—å°æ•¸ï¼š2Ã—${currentDealerStreak}+1 = ${streakFan}å°`);
  }
  
  // è¨ˆç®—åŸºæœ¬åˆ†æ•¸ï¼ˆç‰Œå‹å°æ•¸ï¼‰
  const baseDelta = GAME_SETTINGS.basePoints + fan * GAME_SETTINGS.perFanPoints;
  
  const catStr = detail.categories.join('ã€');
  
  if (selfDraw) {
    // è‡ªæ‘¸æƒ…æ³
    if (isDealer) {
      // èŠå®¶è‡ªæ‘¸ï¼šå‘æ¯ä½é–’å®¶æ”¶å–ã€Œç‰Œå‹å°æ•¸ + é€£èŠå°æ•¸ã€
      const totalDelta = baseDelta + streakFan * GAME_SETTINGS.perFanPoints;
      for (let i = 0; i < 4; i++) {
        if (i !== winner) {
          S.players[i].points -= totalDelta;
        }
      }
      S.players[winner].points += totalDelta * 3;
      const streakText = currentDealerStreak > 0 ? `ï¼Œé€£èŠ${currentDealerStreak}æ¬¡åŠ ${streakFan}å°` : '';
      log(`ğŸ‰ ${playerName(winner)} è‡ªæ‘¸ ${keyToText(tileKey(tile))}ï¼ˆ${catStr}ï¼Œå…±${fan}å°${streakText}ï¼‰â†’ æ¯å®¶ä»˜ ${totalDelta.toLocaleString()}`);
    } else {
      // é–’å®¶è‡ªæ‘¸ï¼šèŠå®¶éœ€å¤šä»˜1å°ï¼Œå…¶ä»–é–’å®¶åªä»˜ç‰Œå‹å°æ•¸
      const dealerExtraFan = 1; // èŠå®¶é¡å¤–æ”¯ä»˜çš„å°æ•¸
      const dealerDelta = baseDelta + dealerExtraFan * GAME_SETTINGS.perFanPoints; // èŠå®¶æ”¯ä»˜çš„é‡‘é¡
      
      // èŠå®¶æ”¯ä»˜ï¼ˆç‰Œå‹å°æ•¸ + 1å°ï¼‰
      S.players[S.dealer].points -= dealerDelta;
      
      // å…¶ä»–é–’å®¶æ”¯ä»˜ï¼ˆç‰Œå‹å°æ•¸ï¼‰
      for (let i = 0; i < 4; i++) {
        if (i !== winner && i !== S.dealer) {
          S.players[i].points -= baseDelta;
        }
      }
      
      // é–’å®¶ç²å¾—ï¼šèŠå®¶æ”¯ä»˜çš„ + å…¶ä»–2å®¶æ”¯ä»˜çš„
      S.players[winner].points += dealerDelta + baseDelta * 2;
      
      log(`ğŸ‰ ${playerName(winner)} è‡ªæ‘¸ ${keyToText(tileKey(tile))}ï¼ˆ${catStr}ï¼Œå…±${fan}å°ï¼‰â†’ èŠå®¶ä»˜ ${dealerDelta.toLocaleString()}ï¼ˆå«1å°ï¼‰ï¼Œå…¶ä»–æ¯å®¶ä»˜ ${baseDelta.toLocaleString()}`);
    }
  } else {
    // é»èƒ¡æƒ…æ³
    if (isFromDealer) {
      // é–’å®¶èƒ¡èŠå®¶ï¼šèŠå®¶éœ€æ”¯ä»˜ã€Œç‰Œå‹å°æ•¸ + é€£èŠå°æ•¸ã€çµ¦è©²é–’å®¶
      const totalDelta = baseDelta + streakFan * GAME_SETTINGS.perFanPoints;
      S.players[from].points -= totalDelta * 3;
      S.players[winner].points += totalDelta * 3;
      const streakText = currentDealerStreak > 0 ? `ï¼Œé€£èŠ${currentDealerStreak}æ¬¡åŠ ${streakFan}å°` : '';
      log(`ğŸ‰ ${playerName(winner)} é»èƒ¡ ${playerName(from)}ï¼ˆ${keyToText(tileKey(tile))}ï¼Œ${catStr}ï¼Œå…±${fan}å°${streakText}ï¼‰â†’ æ”¾æ§è€…ä»˜ ${(totalDelta * 3).toLocaleString()}`);
    } else {
      // é–’å®¶èƒ¡é–’å®¶ï¼šèˆ‡èŠå®¶çš„é€£èŠå°æ•¸ç„¡é—œï¼Œåƒ…è¨ˆç®—ç‰Œå‹å°æ•¸
      S.players[from].points -= baseDelta * 3;
      S.players[winner].points += baseDelta * 3;
      log(`ğŸ‰ ${playerName(winner)} é»èƒ¡ ${playerName(from)}ï¼ˆ${keyToText(tileKey(tile))}ï¼Œ${catStr}ï¼Œå…±${fan}å°ï¼‰â†’ æ”¾æ§è€…ä»˜ ${(baseDelta * 3).toLocaleString()}`);
    }
  }
  
  renderAll();
  S.players[winner].rinshan = false;
  S.robKong = false;
  
  for (let i = 0; i < 4; i++) {
    if (S.players[i].points <= 0) {
      log(`âš ï¸ ${playerName(i)} ç ´ç”¢ï¼ŒéŠæˆ²çµæŸ`);
      setTimeout(() => showFinalScore(), 1500);
      return;
    }
  }
  
  // é€£ç·šæ¨¡å¼ï¼šç™¼é€èƒ¡ç‰Œæ“ä½œå’ŒåŒæ­¥ç‹€æ…‹
  if (isOnlineMode && socket) {
    if (winner === mySeat) {
      sendPlayerAction('win', { tile: tileKey(tile), from: from, selfDraw: selfDraw });
      syncGameStateToServer();
    } else if (isHost && !onlinePlayers.some(op => op.seat === winner)) {
      // æˆ¿ä¸»æ§åˆ¶ AI èƒ¡ç‰Œ
      syncGameStateToServer();
    }
  }
  
  setTimeout(() => showHandsAndContinue(), 1000);
}

function calcFanDetails(winner, winTile, selfDraw) {
  const pl = S.players[winner];
  const allTiles = pl.hand.concat(pl.melds.flatMap(m => m.tiles));
  let fan = 0;
  const categories = [];
  
  // ç²å–åº§é¢¨å’Œåœˆé¢¨
  const seatWind = seatNames[winner] || 'æ±';
  const roundWind = ['æ±', 'å—', 'è¥¿', 'åŒ—'][S.round - 1] || 'æ±';
  
  // ========= ç‰¹æ®Šå¤§ç‰Œå‹ï¼ˆå„ªå…ˆåˆ¤å®šï¼Œäº’æ–¥ï¼‰ =========
  
  // ä¹è“®å¯¶ç‡ˆ
  if (checkNineGates(pl, winTile)) {
    fan += RULES.scoring.NineGates;
    categories.push('ä¹è“®å¯¶ç‡ˆ');
    // ä¹è“®å¯¶ç‡ˆé€šå¸¸ä¸èˆ‡å…¶ä»–å°å‹ç–ŠåŠ ï¼Œä½†é€™è£¡æˆ‘å€‘ç¹¼çºŒæª¢æŸ¥å…¶ä»–å°å‹
  }
  
  // å››æ§“å­
  const kongType = checkKongs(pl);
  if (kongType === 'four') {
    fan += RULES.scoring.FourKongs;
    categories.push('å››æ§“å­');
  }
  
  // å¤§å››å–œ
  const fourWinds = checkFourWinds(pl, winTile, seatWind, roundWind);
  if (fourWinds === 'big') {
    fan += RULES.scoring.BigFourWinds;
    categories.push('å¤§å››å–œ');
  }
  
  // å¤§ä¸‰å…ƒ
  const threeDragons = checkThreeDragons(pl, winTile);
  if (threeDragons === 'big') {
    fan += RULES.scoring.BigThreeDragons;
    categories.push('å¤§ä¸‰å…ƒ');
  }
  
  // å­—ä¸€è‰²
  if (checkAllHonors(pl, winTile)) {
    fan += RULES.scoring.AllHonors;
    categories.push('å­—ä¸€è‰²');
  }
  
  // æ¸…è€é ­
  if (checkAllTerminals(pl, winTile)) {
    fan += RULES.scoring.AllTerminals;
    categories.push('æ¸…è€é ­');
  }
  
  // ========= å…¶ä»–ç‰¹æ®Šç‰Œå‹ =========
  
  // å°å››å–œ
  if (fourWinds === 'little') {
    fan += RULES.scoring.LittleFourWinds;
    categories.push('å°å››å–œ');
  }
  
  // å°ä¸‰å…ƒ
  if (threeDragons === 'little') {
    fan += RULES.scoring.LittleThreeDragons;
    categories.push('å°ä¸‰å…ƒ');
  }
  
  // æ··è€é ­
  if (checkAllTerminalsAndHonors(pl, winTile)) {
    fan += RULES.scoring.AllTerminalsAndHonors;
    categories.push('æ··è€é ­');
  }
  
  // äº”æš—åˆ»
  const concealedPungs = checkConcealedPungs(pl);
  if (concealedPungs >= 5) {
    fan += RULES.scoring.FiveConcealedPungs;
    categories.push('äº”æš—åˆ»');
  } else if (concealedPungs >= 4) {
    fan += RULES.scoring.FourConcealedPungs;
    categories.push('å››æš—åˆ»');
  } else if (concealedPungs >= 3) {
    fan += RULES.scoring.ThreeConcealedPungs;
    categories.push('ä¸‰æš—åˆ»');
  }
  
  // ä¸‰æ§“å­
  if (kongType === 'three') {
    fan += RULES.scoring.ThreeKongs;
    categories.push('ä¸‰æ§“å­');
  }
  
  // æ¸…ä¸€è‰²
  const suitCnt = { W: 0, T: 0, B: 0 };
  let honors = 0;
  for (const t of allTiles) {
    const k = tileKey(t)[0];
    if (suitCnt[k] != null) suitCnt[k]++;
    else if (k === 'F' || k === 'D') honors++;
  }
  
  const nz = Object.values(suitCnt).filter(x => x > 0).length;
  if (nz === 1 && honors === 0) {
    fan += RULES.scoring.PureOneSuit;
    categories.push('æ¸…ä¸€è‰²');
  } else if (nz === 1 && honors > 0) {
    fan += RULES.scoring.HalfFlush;
    categories.push('æ¹Šä¸€è‰²');
  }
  
  // å°å°èƒ¡ï¼ˆ4å°ï¼‰ï¼šå…¨éƒ¨ç”±åˆ»å­èˆ‡ä¸€å€‹å°å­çµ„æˆ
  const kinds = countByKey(pl.hand.concat([winTile]));
  const allTrip = isAllPungsPossible(kinds);
  if (allTrip) {
    fan += RULES.scoring.AllPungs;
    categories.push('å°å°èƒ¡');
  }
  
  // å…¨æ±‚äººï¼ˆ2å°ï¼‰
  if (checkAllChows(pl)) {
    fan += RULES.scoring.AllChows;
    categories.push('å…¨æ±‚äºº');
  }
  
  // å¹³èƒ¡ï¼ˆ2å°ï¼‰ï¼šå…¨é †å­ã€ç„¡åˆ»ã€ç„¡å­—ã€éç å°ã€éå–®åŠ
  if (checkPingHu(pl, winTile)) {
    fan += RULES.scoring.PingHu;
    categories.push('å¹³èƒ¡');
  }
  
  // ========= ç‰¹æ®Šæƒ…æ³ =========
  
  // å¤©è½
  if (pl.tianTing) {
    fan += RULES.scoring.HeavenReady;
    categories.push('å¤©è½');
  } else if (pl.diTing) {
    // åœ°è½
    fan += RULES.scoring.EarthReady;
    categories.push('åœ°è½');
  } else if (pl.declaredListen) {
    // å ±è½
    fan += RULES.scoring.DeclaredListen;
    categories.push('å ±è½');
  }
  
  // åº§é¢¨å’Œåœˆé¢¨
  const winds = checkSeatAndRoundWind(pl, winTile, seatWind, roundWind);
  if (winds.seatWind) {
    fan += RULES.scoring.SeatWind;
    categories.push('åº§é¢¨');
  }
  if (winds.roundWind && !winds.seatWind) { // å¦‚æœåº§é¢¨å’Œåœˆé¢¨ç›¸åŒï¼Œåªç®—ä¸€æ¬¡
    fan += RULES.scoring.RoundWind;
    categories.push('åœˆé¢¨');
  }
  
  // åŸºç¤å°æ•¸ï¼šé–€æ¸…ã€è‡ªæ‘¸ã€ä¸æ±‚äºº
  const menqing = pl.melds.length === 0 || pl.melds.every(m => m.concealed);
  
  if (selfDraw) {
    // è‡ªæ‘¸ï¼š1å°
    fan += RULES.scoring.SelfDraw;
    categories.push('è‡ªæ‘¸');
    
    // é–€æ¸…ï¼š1å°ï¼ˆèƒ¡ç‰Œå‰æ²’æœ‰åƒã€ç¢°ã€æ˜æ§“ï¼‰
    if (menqing) {
      fan += RULES.scoring.ConcealedHand;
      categories.push('é–€æ¸…');
      
      // ä¸æ±‚äººï¼š2å°ï¼ˆé–€æ¸…+è‡ªæ‘¸ï¼Œä½†é€™è£¡é–€æ¸…å’Œè‡ªæ‘¸å·²ç¶“å„åŠ 1å°ï¼Œæ‰€ä»¥ä¸æ±‚äººåªéœ€è¦é¡å¤–åŠ 1å°ï¼Œç¸½å…±2å°ï¼‰
      // å¯¦éš›ä¸Šä¸æ±‚äºº = é–€æ¸…(1) + è‡ªæ‘¸(1) = 2å°ï¼Œæ‰€ä»¥ä¸éœ€è¦é¡å¤–åŠ 
      // ä½†ç‚ºäº†æ˜ç¢ºæ¨™ç¤ºï¼Œæˆ‘å€‘å¯ä»¥æª¢æŸ¥æ˜¯å¦åŒæ™‚æ»¿è¶³é–€æ¸…å’Œè‡ªæ‘¸
      // æ³¨æ„ï¼šé€™è£¡é–€æ¸…å’Œè‡ªæ‘¸å·²ç¶“å„åŠ 1å°ï¼Œæ‰€ä»¥ä¸æ±‚äººç¸½å…±æ˜¯2å°ï¼Œç¬¦åˆè¦å‰‡
    }
  } else {
    // éè‡ªæ‘¸ï¼šæª¢æŸ¥é–€æ¸…
    if (menqing) {
      fan += RULES.scoring.ConcealedHand;
      categories.push('é–€æ¸…');
    }
    
    // æ²³åº•æ’ˆé­šï¼šèƒ¡åˆ¥äººæ‰“çš„æœ€å¾Œä¸€å¼µç‰Œï¼ˆç‰Œå±±å’Œç‹ç‰Œéƒ½å·²ç©ºï¼‰
    const dead = 16 + S.kongCount;
    if (S.wall.length === 0 && S.deadWall.length === 0) {
      fan += RULES.scoring.Houtei;
      categories.push('æ²³åº•æ’ˆé­š');
    }
  }
  
  // æµ·åº•æ’ˆæœˆï¼šè‡ªæ‘¸æœ€å¾Œä¸€å¼µç‰Œï¼ˆç‰Œå±±å·²ç©ºï¼Œå¾ç‹ç‰Œæ‘¸æœ€å¾Œä¸€å¼µï¼‰
  if (selfDraw) {
    const dead = 16 + S.kongCount;
    if (S.wall.length === 0 && S.deadWall.length > 0 && S.deadWall.length <= dead) {
      fan += RULES.scoring.Haitei;
      categories.push('æµ·åº•æ’ˆæœˆ');
    }
  }
  
  // æ¶æ§“
  if (S.robKong) {
    fan += RULES.scoring.RobKong;
    categories.push('æ¶æ§“');
  }
  
  // æ§“ä¸Šé–‹èŠ±
  if (selfDraw && pl.rinshan) {
    fan += RULES.scoring.Rinshan;
    categories.push('æ§“ä¸Šé–‹èŠ±');
  }
  
  
  // æª¢æŸ¥å¤©èƒ¡ã€åœ°èƒ¡ã€äººèƒ¡ï¼ˆå„ªå…ˆåˆ¤å®šï¼‰
  const heavenWin = checkHeavenWin(pl, selfDraw, winner);
  const earthWin = checkEarthWin(pl, selfDraw, winner);
  const humanWin = checkHumanWin(pl, selfDraw, winner);
  
  if (heavenWin) {
    fan += RULES.scoring.HeavenWin;
    categories.push('å¤©èƒ¡');
  } else if (earthWin) {
    fan += RULES.scoring.EarthWin;
    categories.push('åœ°èƒ¡');
  } else if (humanWin) {
    fan += RULES.scoring.HumanWin;
    categories.push('äººèƒ¡');
  }
  
  // å¦‚æœæ²’æœ‰ä»»ä½•å°å‹ï¼Œç®—å¹³èƒ¡ï¼ˆä½†å¹³èƒ¡å·²ç¶“åœ¨ä¸Šé¢æª¢æŸ¥éäº†ï¼‰
  if (categories.length === 0) {
    categories.push('å¹³èƒ¡');
    fan = 1; // å¹³èƒ¡è‡³å°‘1å°
  }
  
  return { fan: Math.max(1, fan), categories };
}

function isAllPungsPossible(counts) {
  let pairs = 0;
  let triples = 0;
  for (const k in counts) {
    const c = counts[k];
    if (c === 2) pairs++;
    else if (c >= 3) triples++;
    else if (c === 1) return false;
  }
  return pairs === 1 && triples >= 4;
}

/* ========= å°å‹åˆ¤å®šå‡½æ•¸ ========= */
function checkAllChows(pl) {
  // å…¨æ±‚äººï¼šæ‰€æœ‰å‰¯éœ²éƒ½æ˜¯åƒæˆ–ç¢°ï¼Œä¸”æœ€å¾Œä¸€å¼µæ˜¯åˆ¥äººæ‰“çš„
  if (pl.melds.length === 0) return false;
  if (pl.melds.length < 5) return false;
  const allChowsOrPongs = pl.melds.every(m => m.type === 'chow' || m.type === 'pong');
  return allChowsOrPongs && pl.hand.length === 1;
}

// å¹³èƒ¡æª¢æŸ¥ï¼šå…¨é †å­ã€ç„¡åˆ»ã€ç„¡å­—ã€éç å°ã€éå–®åŠ
function checkPingHu(pl, winTile) {
  // ä¸èƒ½æœ‰åˆ»å­ï¼ˆç¢°ã€æ§“ï¼‰
  const hasPungOrKong = pl.melds.some(m => m.type === 'pong' || m.type === 'kong');
  if (hasPungOrKong) return false;
  
  // ä¸èƒ½æœ‰å­—ç‰Œ
  const allTiles = pl.hand.concat([winTile]).concat(pl.melds.flatMap(m => m.tiles));
  const hasHonor = allTiles.some(t => t.suit === SUIT_F || t.suit === SUIT_D);
  if (hasHonor) return false;
  
  // å¿…é ˆå…¨éƒ¨æ˜¯é †å­ï¼ˆåƒï¼‰
  const allChows = pl.melds.every(m => m.type === 'chow');
  if (!allChows && pl.melds.length > 0) return false;
  
  // æª¢æŸ¥æ‰‹ç‰Œæ˜¯å¦éƒ½æ˜¯é †å­ï¼ˆä½¿ç”¨canSplitMeldsæª¢æŸ¥ï¼‰
  const testHand = pl.hand.concat([winTile]);
  const counts = countByKey(testHand);
  
  // è¨ˆç®—éœ€è¦çš„é †å­æ•¸é‡ï¼ˆæ‰£é™¤å·²æœ‰çš„åƒï¼‰
  const chowCount = pl.melds.filter(m => m.type === 'chow').length;
  const neededChows = 5 - chowCount;
  
  // æª¢æŸ¥æ˜¯å¦èƒ½åˆ†è§£ç‚ºé †å­å’Œä¸€å€‹å°å­
  // å…ˆæ‰¾å°å­
  let pairFound = false;
  const countsCopy = {};
  for (const k in counts) {
    countsCopy[k] = counts[k];
  }
  
  for (const k in countsCopy) {
    if (countsCopy[k] >= 2) {
      countsCopy[k] -= 2;
      pairFound = true;
      break;
    }
  }
  
  if (!pairFound) return false;
  
  // å‰©ä¸‹çš„å¿…é ˆèƒ½çµ„æˆé †å­
  return canSplitMelds(countsCopy, neededChows);
}

// å¤©èƒ¡æª¢æŸ¥ï¼šèŠå®¶èµ·æ‰‹17å¼µç‰Œç›´æ¥èƒ¡ç‰Œ
// å¤©èƒ¡æª¢æŸ¥ï¼šèŠå®¶èµ·æ‰‹17å¼µç‰Œç›´æ¥èƒ¡ç‰Œ
function checkHeavenWin(pl, selfDraw, winner) {
  if (!selfDraw) return false;
  if (pl.drawCount !== 1) return false; // åªæ‘¸éä¸€æ¬¡ç‰Œï¼ˆèµ·æ‰‹ï¼‰
  if (S.dealer !== winner) return false; // å¿…é ˆæ˜¯èŠå®¶
  return true;
}

// åœ°èƒ¡æª¢æŸ¥ï¼šé–’å®¶èµ·æ‰‹è½ç‰Œï¼Œåœ¨ç¬¬ä¸€å·¡å…§æ‘¸ç‰Œå³èƒ¡ï¼ˆéœ€ç„¡äººåƒç¢°ï¼‰
function checkEarthWin(pl, selfDraw, winner) {
  if (!selfDraw) return false;
  if (S.dealer === winner) return false; // ä¸èƒ½æ˜¯èŠå®¶
  if (pl.drawCount > 1) return false; // ç¬¬ä¸€å·¡å…§ï¼ˆåªæ‘¸éä¸€æ¬¡ç‰Œï¼‰
  if (S.anyOpenMeld) return false; // éœ€ç„¡äººåƒç¢°
  if (!pl.diTing) return false; // å¿…é ˆæ˜¯åœ°è½
  return true;
}

// äººèƒ¡æª¢æŸ¥ï¼šé–’å®¶èµ·æ‰‹è½ç‰Œï¼Œåœ¨ç¬¬ä¸€å·¡å…§ç”±ä»–äººæ”¾éŠƒèƒ¡ç‰Œ
function checkHumanWin(pl, selfDraw, winner) {
  if (selfDraw) return false; // å¿…é ˆæ˜¯é»èƒ¡
  if (S.dealer === winner) return false; // ä¸èƒ½æ˜¯èŠå®¶
  if (pl.drawCount > 1) return false; // ç¬¬ä¸€å·¡å…§ï¼ˆåªæ‘¸éä¸€æ¬¡ç‰Œï¼‰
  if (S.anyOpenMeld) return false; // éœ€ç„¡äººåƒç¢°
  if (!pl.diTing) return false; // å¿…é ˆæ˜¯åœ°è½
  return true;
}

function checkConcealedPungs(pl) {
  // è¨ˆç®—æš—åˆ»æ•¸é‡
  // 1. æ‰‹ç‰Œä¸­çš„åˆ»å­ï¼ˆ3å¼µç›¸åŒï¼Œä¸”æ²’æœ‰å‰¯éœ²ï¼‰
  const handCounts = countByKey(pl.hand);
  let concealedPungs = 0;
  for (const k in handCounts) {
    // æª¢æŸ¥æ˜¯å¦æœ‰å°æ‡‰çš„æ˜åˆ»æˆ–æ˜æ§“
    const hasOpenMeld = pl.melds.some(m => {
      if (m.type === 'pong' || (m.type === 'kong' && !m.concealed)) {
        return tileKey(m.tiles[0]) === k;
      }
      return false;
    });
    // å¦‚æœæ‰‹ç‰Œä¸­æœ‰3å¼µæˆ–4å¼µç›¸åŒï¼Œä¸”æ²’æœ‰æ˜åˆ»ï¼Œç®—ä½œæš—åˆ»
    if (handCounts[k] >= 3 && !hasOpenMeld) {
      concealedPungs++;
    }
  }
  // 2. åŠ ä¸Šæš—æ§“ï¼ˆæš—æ§“ä¹Ÿç®—æš—åˆ»ï¼‰
  const concealedKongs = pl.melds.filter(m => m.type === 'kong' && m.concealed).length;
  return concealedPungs + concealedKongs;
}

function checkThreeDragons(pl, winTile) {
  // æª¢æŸ¥ä¸‰å…ƒç‰Œ
  const allTiles = pl.hand.concat([winTile]).concat(pl.melds.flatMap(m => m.tiles));
  const dragonCounts = { C: 0, F: 0, B: 0 }; // ä¸­ç™¼ç™½
  for (const t of allTiles) {
    if (t.suit === SUIT_D) {
      dragonCounts[t.name] = (dragonCounts[t.name] || 0) + 1;
    }
  }
  const hasAll = dragonCounts.C >= 3 && dragonCounts.F >= 3 && dragonCounts.B >= 3;
  const hasTwo = Object.values(dragonCounts).filter(c => c >= 3).length === 2;
  const hasPair = Object.values(dragonCounts).some(c => c >= 2);
  
  if (hasAll) return 'big'; // å¤§ä¸‰å…ƒ
  if (hasTwo && hasPair) return 'little'; // å°ä¸‰å…ƒ
  return null;
}

function checkFourWinds(pl, winTile, seatWind, roundWind) {
  // æª¢æŸ¥å››å–œç‰Œ
  const allTiles = pl.hand.concat([winTile]).concat(pl.melds.flatMap(m => m.tiles));
  const windCounts = { E: 0, S: 0, W: 0, N: 0 };
  for (const t of allTiles) {
    if (t.suit === SUIT_F) {
      windCounts[t.name] = (windCounts[t.name] || 0) + 1;
    }
  }
  const hasAll = Object.values(windCounts).every(c => c >= 3);
  const hasThree = Object.values(windCounts).filter(c => c >= 3).length === 3;
  const hasPair = Object.values(windCounts).some(c => c >= 2);
  
  if (hasAll) return 'big'; // å¤§å››å–œ
  if (hasThree && hasPair) return 'little'; // å°å››å–œ
  return null;
}

function checkAllHonors(pl, winTile) {
  // å­—ä¸€è‰²ï¼šå…¨éƒ¨æ˜¯å­—ç‰Œï¼ˆé¢¨ç‰Œ+ä¸‰å…ƒç‰Œï¼‰
  const allTiles = pl.hand.concat([winTile]).concat(pl.melds.flatMap(m => m.tiles));
  return allTiles.every(t => t.suit === SUIT_F || t.suit === SUIT_D);
}

function checkAllTerminals(pl, winTile) {
  // æ¸…è€é ­ï¼šå…¨éƒ¨æ˜¯1å’Œ9
  const allTiles = pl.hand.concat([winTile]).concat(pl.melds.flatMap(m => m.tiles));
  return allTiles.every(t => {
    if (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) {
      return t.rank === 1 || t.rank === 9;
    }
    return false;
  });
}

function checkAllTerminalsAndHonors(pl, winTile) {
  // æ··è€é ­ï¼šå…¨éƒ¨æ˜¯1ã€9æˆ–å­—ç‰Œ
  const allTiles = pl.hand.concat([winTile]).concat(pl.melds.flatMap(m => m.tiles));
  return allTiles.every(t => {
    if (t.suit === SUIT_F || t.suit === SUIT_D) return true;
    if (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) {
      return t.rank === 1 || t.rank === 9;
    }
    return false;
  });
}

function checkNineGates(pl, winTile) {
  // ä¹è“®å¯¶ç‡ˆï¼šåŒä¸€èŠ±è‰²1112345678999 + ä»»æ„ä¸€å¼µåŒèŠ±è‰²
  if (pl.melds.length > 0) return false; // å¿…é ˆé–€æ¸…
  
  const allTiles = pl.hand.concat([winTile]);
  const suitCounts = { W: [], T: [], B: [] };
  
  for (const t of allTiles) {
    if (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) {
      suitCounts[t.suit].push(t.rank);
    } else {
      return false; // ä¸èƒ½æœ‰å­—ç‰Œ
    }
  }
  
  // æª¢æŸ¥æ˜¯å¦åªæœ‰ä¸€ç¨®èŠ±è‰²
  const suits = Object.keys(suitCounts).filter(s => suitCounts[s].length > 0);
  if (suits.length !== 1) return false;
  
  const suit = suits[0];
  const ranks = suitCounts[suit].sort((a, b) => a - b);
  
  // å¿…é ˆæ˜¯16å¼µï¼ˆèŠå®¶ï¼‰æˆ–15å¼µï¼ˆéèŠå®¶ï¼‰+ 1å¼µèƒ¡ç‰Œ = 16å¼µ
  if (ranks.length !== 16) return false;
  
  // æª¢æŸ¥æ˜¯å¦ç¬¦åˆä¹è“®å¯¶ç‡ˆæ¨¡å¼ï¼š1112345678999 + ä»»æ„ä¸€å¼µ
  const required = [1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 9];
  const counts = {};
  for (const r of ranks) {
    counts[r] = (counts[r] || 0) + 1;
  }
  
  // å¿…é ˆæœ‰3å€‹1å’Œ3å€‹9
  if (counts[1] < 3 || counts[9] < 3) return false;
  
  // 2-8æ¯å€‹è‡³å°‘è¦æœ‰1å€‹
  for (let r = 2; r <= 8; r++) {
    if (!counts[r] || counts[r] < 1) return false;
  }
  
  // ç¸½å…±16å¼µï¼Œç¬¦åˆä¹è“®å¯¶ç‡ˆ
  return true;
}

function checkKongs(pl) {
  // è¨ˆç®—æ§“çš„æ•¸é‡
  const kongCount = pl.melds.filter(m => m.type === 'kong').length;
  if (kongCount >= 4) return 'four'; // å››æ§“å­
  if (kongCount >= 3) return 'three'; // ä¸‰æ§“å­
  return null;
}

function checkSeatAndRoundWind(pl, winTile, seatWind, roundWind) {
  // æª¢æŸ¥åº§é¢¨å’Œåœˆé¢¨
  const allTiles = pl.hand.concat([winTile]).concat(pl.melds.flatMap(m => m.tiles));
  const windMap = { 'æ±': 'E', 'å—': 'S', 'è¥¿': 'W', 'åŒ—': 'N' };
  const seatWindCode = windMap[seatWind] || seatWind;
  const roundWindCode = windMap[roundWind] || roundWind;
  
  let seatWindCount = 0;
  let roundWindCount = 0;
  
  for (const t of allTiles) {
    if (t.suit === SUIT_F) {
      if (t.name === seatWindCode) seatWindCount++;
      if (t.name === roundWindCode) roundWindCount++;
    }
  }
  
  const hasSeatWind = seatWindCount >= 3 || (seatWindCount >= 2 && seatWindCode === roundWindCode);
  const hasRoundWind = roundWindCount >= 3 || (roundWindCount >= 2 && seatWindCode === roundWindCode);
  
  return { seatWind: hasSeatWind, roundWind: hasRoundWind };
}

/* ========= éŠæˆ²æµç¨‹ ========= */
function stepNext() {
  if (S.phase === 'end') return;
  
  const dead = 16 + S.kongCount;
  // æµå±€ï¼šç‰Œå±±å’Œç‹ç‰Œéƒ½ç‚ºç©º
  if (S.wall.length === 0 && S.deadWall.length === 0) {
    log('ğŸš« æµå±€ - ç‰Œå±±æ¯ç«­');
    S.phase = 'end';
    S.winner = null;
    
    // èªéŸ³æ’­å ±
    speakRandom('drawGame');
    
    renderAll();
    
    // é€£ç·šæ¨¡å¼ï¼šåŒæ­¥æµå±€ç‹€æ…‹
    if (isOnlineMode && socket && isHost) {
      syncGameStateToServer();
    }
    
    setTimeout(() => showHandsAndContinue(), 1000);
    return;
  }
  
  // ç¢ºä¿S.turnæ˜¯æœ‰æ•ˆçš„å€¼ï¼ˆ0-3ï¼‰
  if (S.turn === undefined || S.turn === null || S.turn < 0 || S.turn > 3) {
    log('âš ï¸ å›åˆæ•¸éŒ¯èª¤ï¼Œé‡ç½®ç‚º0');
    S.turn = 0;
  }
  
  const myPSeat = getMyPlayerSeat();
  
  if (S.turn === myPSeat) {
    // é˜²æ­¢é‡å¤è°ƒç”¨
    if (isProcessingStep) {
      console.log('âš ï¸ stepNext: æ­£åœ¨å¤„ç†ä¸­ï¼Œè·³è¿‡é‡å¤è°ƒç”¨');
      return;
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰ drawnTileï¼ˆä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤ï¼‰
    const me = S.players[myPSeat];
    if (me.drawnTile) {
      console.log('âš ï¸ stepNext: å·²ç»æœ‰ drawnTileï¼Œè·³è¿‡æ‘¸ç‰Œ:', tileKey(me.drawnTile));
      return;
    }
    
    isProcessingStep = true;
    
    // ç©å®¶çš„å›åˆï¼Œå…ˆæ‘¸ç‰Œ
    const hadDrawnTile = me.drawnTile; // è¨˜éŒ„ä¹‹å‰æ˜¯å¦æœ‰æ‘¸åˆ°çš„ç‰Œ
    
    console.log('stepNext: ç©å®¶æ‘¸ç‰Œå‰, æ‰‹ç‰Œæ•°:', me.hand.length, ', drawnTile:', me.drawnTile ? tileKey(me.drawnTile) : null);
    
    draw(myPSeat);
    
    console.log('stepNext: ç©å®¶æ‘¸ç‰Œå, æ‰‹ç‰Œæ•°:', me.hand.length, ', drawnTile:', me.drawnTile ? tileKey(me.drawnTile) : null);
    
    // æª¢æŸ¥æ˜¯å¦æˆåŠŸæ‘¸ç‰Œ
    if (!me.drawnTile && !hadDrawnTile) {
      // æ‘¸ç‰Œå¤±æ•—ï¼Œå¯èƒ½æ˜¯æµå±€
      if (S.wall.length === 0 && S.deadWall.length === 0) {
        log('ğŸš« æµå±€ - ç‰Œå±±æ¯ç«­');
        S.phase = 'end';
        S.winner = null;
        
        // èªéŸ³æ’­å ±
        speakRandom('drawGame');
        
        renderAll();
        isProcessingStep = false;
        
        // é€£ç·šæ¨¡å¼ï¼šåŒæ­¥æµå±€ç‹€æ…‹
        if (isOnlineMode && socket && isHost) {
          syncGameStateToServer();
        }
        
        setTimeout(() => showHandsAndContinue(), 1000);
        return;
      }
      // å¦‚æœé‚„æœ‰ç‰Œä½†æ‘¸ç‰Œå¤±æ•—ï¼Œè¨˜éŒ„éŒ¯èª¤
      log('âš ï¸ æ‘¸ç‰Œå¤±æ•—ï¼Œä½†é‚„æœ‰ç‰Œ');
      renderAll();
      isProcessingStep = false;
      return;
    }
    
    renderAll();
    
    // ç¢ºä¿æœ‰æ‰‹ç‰Œæ‰èƒ½æª¢æŸ¥
    if (me.hand.length > 0 && me.drawnTile) {
      const t = me.drawnTile;
      
      // æª¢æŸ¥æ˜¯å¦èƒ½èƒ¡ç‰Œ
    if (isWinningNow(me.hand, me.melds, t)) {
        // å¦‚æœå·²ç¶“å ±è½ï¼Œè‡ªå‹•èƒ¡ç‰Œ
        if (me.declaredListen) {
          isProcessingStep = false; // é‡ç½®æ ‡å¿—ï¼Œå› ä¸ºä¼šè°ƒç”¨ doWin
          setTimeout(() => {
            doWin(myPSeat, -1, t, true);
          }, 500); // ç¨å¾®å»¶é²ï¼Œè®“ç©å®¶çœ‹åˆ°æ‘¸åˆ°çš„ç‰Œ
          return;
        } else {
      document.getElementById('btnHu').disabled = false;
      log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
          isProcessingStep = false; // é‡ç½®æ ‡å¿—ï¼Œç­‰å¾…ç©å®¶æ“ä½œ
          return; // å¦‚æœèƒ½èƒ¡ï¼Œä¸è‡ªå‹•ä¸Ÿç‰Œ
        }
      }
      
      // å¦‚æœå·²ç¶“å ±è½ï¼Œè‡ªå‹•åŸ·è¡Œæ‰€æœ‰æ“ä½œ
      if (me.declaredListen) {
        // å„ªå…ˆç´š1ï¼šæª¢æŸ¥åŠ æ§“ï¼ˆæ˜æ§“ï¼‰
        const aks = canAddedKong(myPSeat);
        if (aks.length > 0) {
          const drawnKey = tileKey(t);
          // æ‰¾åˆ°å¯ä»¥ç”¨æ‘¸åˆ°çš„ç‰ŒåŠ æ§“çš„é¸é …
          const validKongs = aks.filter(ak => {
            const meld = me.melds[ak.meldIndex];
            if (!meld || meld.type !== 'pong') return false;
            const meldKey = tileKey(meld.tiles[0]);
            if (meldKey !== drawnKey) return false;
            
            // æª¢æŸ¥åŠ æ§“å¾Œæ˜¯å¦æœƒç ´å£è½ç‰Œ
            // æ¨¡æ“¬åŠ æ§“ï¼šå°‡æ‘¸åˆ°çš„ç‰ŒåŠ å…¥meldï¼Œæª¢æŸ¥æ‰‹ç‰Œæ˜¯å¦é‚„èƒ½è½ç‰Œ
            const testHand = me.hand.filter(ht => ht !== t); // ç§»é™¤æ‘¸åˆ°çš„ç‰Œï¼ˆæœƒç”¨æ–¼åŠ æ§“ï¼‰
            const testMelds = me.melds.map((m, idx) => {
              if (idx === ak.meldIndex) {
                // æ¨¡æ“¬åŠ æ§“å¾Œçš„meldï¼ˆè®Šæˆkongï¼‰
                return { ...m, type: 'kong', tiles: [...m.tiles, t] };
              }
              return m;
            });
            
            // æª¢æŸ¥åŠ æ§“å¾Œæ˜¯å¦é‚„èƒ½è½ç‰Œ
            return isListening(testHand, testMelds);
          });
          
          if (validKongs.length > 0) {
            // è‡ªå‹•åŠ æ§“ï¼ˆä¸æœƒç ´å£è½ç‰Œï¼‰
            isProcessingStep = false; // é‡ç½®æ ‡å¿—ï¼Œå› ä¸ºä¼šè°ƒç”¨ doAddedKong
            setTimeout(() => {
              doAddedKong(myPSeat, validKongs[0].meldIndex);
            }, 500);
            return;
          }
        }
        
        // å„ªå…ˆç´š2ï¼šæª¢æŸ¥æš—æ§“
        const cks = canConcealedKong(myPSeat);
        if (cks.length > 0) {
          const drawnKey = tileKey(t);
          if (cks.includes(drawnKey)) {
            // æª¢æŸ¥æš—æ§“å¾Œæ˜¯å¦æœƒç ´å£è½ç‰Œ
            // æ¨¡æ“¬æš—æ§“ï¼šå¾æ‰‹ç‰Œä¸­ç§»é™¤4å¼µç›¸åŒçš„ç‰Œï¼ˆåŒ…æ‹¬æ‘¸åˆ°çš„ç‰Œï¼‰ï¼Œæª¢æŸ¥æ˜¯å¦é‚„èƒ½è½ç‰Œ
            const testHand = me.hand.filter(ht => {
              const htKey = tileKey(ht);
              return htKey !== drawnKey; // ç§»é™¤æ‰€æœ‰ç›¸åŒkeyçš„ç‰Œï¼ˆåŒ…æ‹¬æ‘¸åˆ°çš„ç‰Œï¼‰
            });
            
            // æ¨¡æ“¬æš—æ§“å¾Œçš„meldï¼ˆæ·»åŠ ä¸€å€‹æš—æ§“ï¼‰
            const testMelds = [...me.melds, { type: 'kong', tiles: [], concealed: true }];
            
            // æª¢æŸ¥æš—æ§“å¾Œæ˜¯å¦é‚„èƒ½è½ç‰Œ
            if (isListening(testHand, testMelds)) {
              // è‡ªå‹•æš—æ§“ï¼ˆä¸æœƒç ´å£è½ç‰Œï¼‰
              isProcessingStep = false; // é‡ç½®æ ‡å¿—ï¼Œå› ä¸ºä¼šè°ƒç”¨ doConcealedKong
              setTimeout(() => {
                doConcealedKong(myPSeat, drawnKey);
              }, 500);
              return;
            }
          }
        }
        
        // å„ªå…ˆç´š3ï¼šè‡ªå‹•ä¸Ÿæ‰æ‘¸åˆ°çš„ç‰Œï¼ˆå¦‚æœèƒ½ä¿æŒè½ç‰Œï¼‰
        if (me.drawnTile) {
          // æª¢æŸ¥ä¸Ÿæ‰æ‘¸åˆ°çš„ç‰Œå¾Œæ˜¯å¦é‚„èƒ½ä¿æŒè½ç‰Œ
          const testHand = me.hand.filter(ht => ht !== me.drawnTile);
          const canKeepListening = isListening(testHand, me.melds);
          
          if (canKeepListening) {
            // å¦‚æœèƒ½ä¿æŒè½ç‰Œï¼Œè‡ªå‹•ä¸Ÿæ‰æ‘¸åˆ°çš„ç‰Œ
            isProcessingStep = false; // é‡ç½®æ ‡å¿—ï¼Œå› ä¸ºä¼šè°ƒç”¨ discard
            setTimeout(() => {
              discard(myPSeat, me.drawnTile);
            }, 500); // ç¨å¾®å»¶é²ï¼Œè®“ç©å®¶çœ‹åˆ°æ‘¸åˆ°çš„ç‰Œ
            return;
          }
        }
      }
    }
    
    // å¦‚æœæ²¡æœ‰è‡ªåŠ¨æ“ä½œï¼Œé‡ç½®æ ‡å¿—ï¼Œç­‰å¾…ç©å®¶æ‰‹åŠ¨æ“ä½œ
    if (isProcessingStep && S.turn === myPSeat) {
      isProcessingStep = false;
    }
  } else {
    // ä¸æ˜¯ç•¶å‰ç©å®¶çš„å›åˆ
    // é€£ç·šæ¨¡å¼ï¼šåˆ¤æ–·æ˜¯å¦æ˜¯AIï¼ˆåªæœ‰æˆ¿ä¸»æ§åˆ¶AIï¼‰
    if (isOnlineMode) {
      // ç¢ºä¿ onlinePlayers å·²å®šç¾©
      if (!onlinePlayers || onlinePlayers.length === 0) {
        console.error('âŒ onlinePlayers æœªå®šç¾©æˆ–ç‚ºç©ºï¼');
        return;
      }
      
      // æª¢æŸ¥æ˜¯å¦æ˜¯çœŸäººç©å®¶
      const isRealPlayer = onlinePlayers.some(p => p.seat === S.turn);
      
      // Debug log
      console.log('=== stepNext é€£ç·šæ¨¡å¼åˆ¤æ–· ===');
      console.log('S.turn:', S.turn);
      console.log('isHost:', isHost);
      console.log('onlinePlayers seats:', onlinePlayers.map(p => p.seat));
      console.log('isRealPlayer:', isRealPlayer);
      
      if (isRealPlayer) {
        // çœŸäººç©å®¶ï¼Œç­‰å¾…ä»–å€‘è‡ªå·±å‡ºç‰Œ
        log(`â³ ç­‰å¾… ${S.names[S.turn]} å‡ºç‰Œ...`);
      } else {
        // AIç©å®¶ï¼Œåªæœ‰æˆ¿ä¸»æ§åˆ¶
        if (isHost) {
          console.log('æˆ¿ä¸»æ§åˆ¶AIç©å®¶:', S.turn);
          setTimeout(stepAI, 800 + Math.random() * 800);
        } else {
          // éæˆ¿ä¸»ç­‰å¾…ç‹€æ…‹åŒæ­¥
          log(`â³ ç­‰å¾… ${S.names[S.turn]} å‡ºç‰Œ...`);
        }
      }
    } else {
      // å–®æ©Ÿæ¨¡å¼
      setTimeout(stepAI, 800 + Math.random() * 800);
    }
  }
}

function stepAI() {
  console.log('=== stepAI é–‹å§‹ ===');
  console.log('S.phase:', S?.phase);
  console.log('S.turn:', S?.turn);
  console.log('isOnlineMode:', isOnlineMode);
  console.log('isHost:', isHost);
  console.log('mySeat:', mySeat);
  console.log('onlinePlayers:', JSON.stringify(onlinePlayers?.map(p => ({seat: p.seat, name: p.name}))));
  
  if (S.phase === 'end') return;
  
  // é€£ç·šæ¨¡å¼ä¸‹ï¼Œåªæœ‰æˆ¿ä¸»æ§åˆ¶AI
  if (isOnlineMode && !isHost) {
    console.log('stepAI: éæˆ¿ä¸»ï¼Œè·³éAIæ§åˆ¶');
    return;
  }
  
  const myPSeatAI = getMyPlayerSeat();
  if (S.turn === myPSeatAI) {
    console.log('stepAI: ç•¶å‰å›åˆæ˜¯è‡ªå·±ï¼Œè·³é');
    return;
  }
  
  console.log('stepAI: æº–å‚™æ§åˆ¶ AI ç©å®¶:', S.turn);
  
  const pid = S.turn;
  const pl = S.players[pid];
  
  if (S.lastAction === 'discard' || S.lastAction === null) {
    draw(pid);
    // å¦‚æœæ‘¸ç‰Œå¤±æ•—ï¼ˆæ²’æœ‰ç‰Œäº†ï¼‰ï¼Œæª¢æŸ¥æ˜¯å¦æµå±€
    if (pl.hand.length === 0 || !pl.drawnTile) {
      if (S.wall.length === 0 && S.deadWall.length === 0) {
        log('ğŸš« æµå±€ - ç‰Œå±±æ¯ç«­');
        S.phase = 'end';
        S.winner = null;
        
        // èªéŸ³æ’­å ±
        speakRandom('drawGame');
        
        renderAll();
        
        // é€£ç·šæ¨¡å¼ï¼šåŒæ­¥æµå±€ç‹€æ…‹
        if (isOnlineMode && socket && isHost) {
          syncGameStateToServer();
        }
        
        setTimeout(() => showHandsAndContinue(), 1000);
        return;
      }
      // å¦‚æœæ‘¸ç‰Œå¤±æ•—ä½†é‚„æœ‰ç‰Œï¼Œå¯èƒ½æ˜¯é‚è¼¯éŒ¯èª¤ï¼Œç›´æ¥è¿”å›é¿å…å¡ä½
      return;
    }
  }
  
  // ç¢ºä¿æœ‰æ‰‹ç‰Œæ‰èƒ½ç¹¼çºŒ
  if (pl.hand.length === 0) return;
  
  // å„ªå…ˆæª¢æŸ¥è‡ªæ‘¸ï¼šä½¿ç”¨drawnTileï¼ˆå‰›æ‘¸åˆ°çš„ç‰Œï¼‰
  const drawnTile = pl.drawnTile;
  if (drawnTile && isWinningNow(pl.hand, pl.melds, drawnTile)) {
    // AIèƒ½è‡ªæ‘¸æ™‚ï¼Œ100%æœƒè‡ªæ‘¸
    doWin(pid, -1, drawnTile, true);
    return;
  }
  
  // å¦‚æœæ²’æœ‰drawnTileï¼Œæª¢æŸ¥æ‰‹ç‰Œæœ€å¾Œä¸€å¼µï¼ˆå¯èƒ½æ˜¯å‰›æ‘¸åˆ°çš„ç‰Œï¼‰
  const lastTile = pl.hand[pl.hand.length - 1];
  if (isWinningNow(pl.hand, pl.melds, lastTile)) {
    doWin(pid, -1, lastTile, true);
    return;
  }
  
  // å¢å¼·æš—æ§“åˆ¤æ–·ï¼šè€ƒæ…®æ‰‹ç‰Œç‹€æ³
  const cks = canConcealedKong(pid);
  if (cks.length > 0) {
    const currentShanten = shantenAfterRemove(pl.hand);
    // å¦‚æœå‘è½æ•¸è¼ƒå¤§ï¼Œæ›´å‚¾å‘æ–¼æš—æ§“
    let kongChance = currentShanten >= 3 ? 0.6 : (currentShanten >= 2 ? 0.45 : 0.3);
    // å¦‚æœå·²ç¶“è½ç‰Œï¼Œé™ä½æš—æ§“æ©Ÿç‡ï¼ˆé™¤éèƒ½æ”¹å–„è½ç‰Œï¼‰
    if (currentShanten === 0) {
      kongChance = 0.2;
    }
    if (Math.random() < kongChance) {
    doConcealedKong(pid, cks[0]);
    return;
    }
  }
  
  // å¢å¼·åŠ æ§“åˆ¤æ–·
  const aks = canAddedKong(pid);
  if (aks.length > 0) {
    const currentShanten = shantenAfterRemove(pl.hand);
    // å¦‚æœå‘è½æ•¸è¼ƒå¤§ï¼Œæ›´å‚¾å‘æ–¼åŠ æ§“
    let kongChance = currentShanten >= 3 ? 0.55 : (currentShanten >= 2 ? 0.45 : 0.35);
    // å¦‚æœå·²ç¶“è½ç‰Œï¼Œé™ä½åŠ æ§“æ©Ÿç‡ï¼ˆé¿å…è¢«æ¶æ§“ï¼‰
    if (currentShanten === 0) {
      // æª¢æŸ¥æ˜¯å¦æœ‰å°æ‰‹è½ç‰Œ
      let hasListeningOpponent = false;
      for (let i = 0; i < 4; i++) {
        if (i !== pid && S.players[i].declaredListen) {
          hasListeningOpponent = true;
          break;
        }
      }
      kongChance = hasListeningOpponent ? 0.15 : 0.3;
    }
    if (Math.random() < kongChance) {
      const candidate = aks[0];
      // æ¶æ§“æª¢æŸ¥å·²ç¶“åœ¨doAddedKongå…§éƒ¨é€²è¡Œï¼Œé€™è£¡ç›´æ¥èª¿ç”¨
    doAddedKong(pid, candidate.meldIndex);
    return;
  }
  }
  
  // å¢å¼·å ±è½åˆ¤æ–·ï¼šæª¢æŸ¥æ˜¯å¦å·²ç¶“è½ç‰Œæˆ–ä¸€é€²è½
  if (!pl.declaredListen) {
    const kongCount = countKongs(pl);
    const totalTiles = pl.hand.length + pl.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    const expectedFull = (S.dealer === pid ? 17 : 16) + kongCount;
    const expectedEmpty = (S.dealer === pid ? 16 : 15) + kongCount;
    
    let canListen = false;
    let listenAfterDiscard = false;
    let discardTile = null;
    let waits = [];
    
    // æª¢æŸ¥æ˜¯å¦å·²ç¶“è½ç‰Œ
    if (totalTiles === expectedEmpty && isListening(pl.hand, pl.melds)) {
      canListen = true;
      waits = calcWaitingTiles(pl.hand, pl.melds);
    }
    // æª¢æŸ¥æ˜¯å¦ä¸€é€²è½ï¼ˆä¸Ÿæ‰ä¸€å¼µç‰Œå°±èƒ½è½ç‰Œï¼‰
    else if (totalTiles === expectedFull) {
      // æ‰¾åˆ°èƒ½è½ç‰Œçš„ä¸Ÿç‰Œé¸æ“‡
      for (const tile of pl.hand) {
        const testHand = pl.hand.filter(t => t !== tile);
        if (isListening(testHand, pl.melds)) {
          canListen = true;
          listenAfterDiscard = true;
          discardTile = tile;
          waits = calcWaitingTiles(testHand, pl.melds);
          break;
        }
      }
    }
    // æª¢æŸ¥å…¶ä»–æƒ…æ³çš„ä¸€é€²è½
    else {
      for (const tile of pl.hand) {
        const testHand = pl.hand.filter(t => t !== tile);
        if (isListening(testHand, pl.melds)) {
          canListen = true;
          listenAfterDiscard = true;
          discardTile = tile;
          waits = calcWaitingTiles(testHand, pl.melds);
          break;
        }
      }
    }
    
    // å¦‚æœå¯ä»¥è½ç‰Œï¼Œæ±ºå®šæ˜¯å¦å ±è½
    if (canListen && waits.length > 0) {
      const visible = [];
      S.players.forEach(p => visible.push(...p.discards, ...p.flowers));
      
      // è¨ˆç®—ç­‰ç‰Œçš„å‰©é¤˜æ•¸é‡
      let totalRemain = 0;
      waits.forEach(wk => {
        const used = visible.filter(vt => tileKey(vt) === wk).length;
        totalRemain += (4 - used);
      });
      
      // æ ¹æ“šç­‰ç‰Œæ•¸é‡å’Œå‰©é¤˜ç‰Œæ•¸æ±ºå®šå ±è½æ©Ÿç‡
      let listenChance = 0.5; // åŸºç¤æ©Ÿç‡50%
      if (waits.length >= 4) listenChance = 0.8; // ç­‰ç‰Œå¤šï¼Œæ›´å‚¾å‘å ±è½
      else if (waits.length >= 3) listenChance = 0.7;
      else if (waits.length >= 2) listenChance = 0.6;
      
      if (totalRemain >= 10) listenChance += 0.2; // å‰©é¤˜ç‰Œå¤šï¼Œæ›´å‚¾å‘å ±è½
      else if (totalRemain >= 8) listenChance += 0.15;
      else if (totalRemain <= 4) listenChance -= 0.25; // å‰©é¤˜ç‰Œå°‘ï¼Œé™ä½å ±è½æ©Ÿç‡
      else if (totalRemain <= 6) listenChance -= 0.15;
      
      // å¦‚æœå‘è½æ•¸ç‚º0ï¼ˆå·²ç¶“è½ç‰Œï¼‰ï¼Œæé«˜å ±è½æ©Ÿç‡
      const currentShanten = shantenAfterRemove(pl.hand);
      if (currentShanten === 0) {
        listenChance = Math.min(0.95, listenChance + 0.25);
      }
      
      // å¦‚æœå°æ‰‹å·²ç¶“å ±è½ï¼Œæé«˜å ±è½æ©Ÿç‡ï¼ˆç«¶çˆ­æ€§ï¼‰
      let hasListeningOpponent = false;
      for (let i = 0; i < 4; i++) {
        if (i !== pid && S.players[i].declaredListen) {
          hasListeningOpponent = true;
          break;
        }
      }
      if (hasListeningOpponent) {
        listenChance = Math.min(0.9, listenChance + 0.2);
      }
      
      // å¦‚æœç­‰ç‰Œæ˜¯å±éšªç‰Œï¼ˆå°æ‰‹å¯èƒ½è½é€™äº›ç‰Œï¼‰ï¼Œé™ä½å ±è½æ©Ÿç‡
      let dangerousWaits = 0;
      for (let i = 0; i < 4; i++) {
        if (i !== pid && S.players[i].declaredListen) {
          const opponentWaits = S.players[i].waitKeys || [];
          waits.forEach(wk => {
            if (opponentWaits.includes(wk)) {
              dangerousWaits++;
            }
          });
        }
      }
      if (dangerousWaits > 0) {
        listenChance -= dangerousWaits * 0.1; // å±éšªç‰Œè¶Šå¤šï¼Œé™ä½å ±è½æ©Ÿç‡
      }
      
      // ç¢ºä¿æ©Ÿç‡åœ¨åˆç†ç¯„åœå…§
      listenChance = Math.max(0.1, Math.min(0.95, listenChance));
      
      if (Math.random() < listenChance) {
        pl.declaredListen = true;
        pl.waitKeys = waits.slice();
        updateTianDiTing(pid);
        log(`ğŸ”” ${playerName(pid)} å ±è½`);
        
        // èªéŸ³æ’­å ±ï¼ˆæ‰€æœ‰ç©å®¶éƒ½æ’­å ±ï¼‰
        speakRandom('listen');
        
        // å¦‚æœæ˜¯ä¸€é€²è½ï¼Œéœ€è¦ä¸Ÿæ‰ç‰¹å®šç‰Œ
        if (listenAfterDiscard && discardTile) {
          // ç›´æ¥ä¸Ÿæ‰èƒ½å½¢æˆè½ç‰Œçš„ç‰Œ
          const discardTileIndex = pl.hand.findIndex(t => t === discardTile);
          if (discardTileIndex >= 0) {
            discard(pid, discardTile);
            return;
          }
        }
      }
    }
  }
  
  const discardTile = aiChooseDiscard(pid);
  discard(pid, discardTile);
}

function draw(p) {
  // é€£ç·šæ¨¡å¼ä¸‹ï¼Œç¢ºä¿åªæœ‰æ­£ç¢ºçš„ç©å®¶å¯ä»¥æ‘¸ç‰Œ
  if (isOnlineMode) {
    const isRealPlayer = onlinePlayers.some(op => op.seat === p);
    
    // å¦‚æœæ˜¯çœŸäººç©å®¶
    if (isRealPlayer) {
      // åªæœ‰è‡ªå·±å¯ä»¥åŸ·è¡Œè‡ªå·±çš„æ‘¸ç‰Œ
      if (p !== mySeat) {
        console.log('âš ï¸ draw: å˜—è©¦ç‚ºå…¶ä»–çœŸäººç©å®¶æ‘¸ç‰Œï¼Œè·³é (p=' + p + ', mySeat=' + mySeat + ')');
        return;
      }
    } else {
      // å¦‚æœæ˜¯AIç©å®¶ï¼Œåªæœ‰æˆ¿ä¸»å¯ä»¥åŸ·è¡Œ
      if (!isHost) {
        console.log('âš ï¸ draw: éæˆ¿ä¸»å˜—è©¦ç‚ºAIæ‘¸ç‰Œï¼Œè·³é');
        return;
      }
    }
  }
  
  // ã€é‡è¦ã€‘æ£€æŸ¥å‰©ä½™ç‰Œæ•°ï¼šå¦‚æœå‰©ä½™ç‰Œæ•°ä¸º0ä¸”æ²¡æœ‰ç‹ç‰Œï¼Œæ— æ³•æ‘¸ç‰Œ
  if (S.remain === 0 && S.wall.length === 0 && S.deadWall.length === 0) {
    console.log('âš ï¸ draw: å‰©ä½™ç‰Œæ•°ä¸º0ï¼Œæ— æ³•æ‘¸ç‰Œ');
    return;
  }
  
  // ã€é‡è¦ã€‘æ£€æŸ¥ç‰Œå±±å’Œç‹ç‰Œï¼šå¦‚æœéƒ½æ²¡æœ‰ç‰Œäº†ï¼Œæ— æ³•æ‘¸ç‰Œ
  if (S.wall.length === 0 && S.deadWall.length === 0) {
    console.log('âš ï¸ draw: ç‰Œå±±å’Œç‹ç‰Œéƒ½ä¸ºç©ºï¼Œæ— æ³•æ‘¸ç‰Œ');
    // è§¦å‘æµå±€
    if (S.phase !== 'end') {
      log('ğŸš« æµå±€ - ç‰Œå±±æ¯ç«­');
      S.phase = 'end';
      S.winner = null;
      speakRandom('drawGame');
      renderAll();
      if (isOnlineMode && socket && isHost) {
        syncGameStateToServer();
      }
      setTimeout(() => showHandsAndContinue(), 1000);
    }
    return;
  }
  
  let t = null;
  
  // å„ªå…ˆå¾ç‰Œå±±æ‘¸ç‰Œ
  if (S.wall.length > 0) {
    t = S.wall.pop();
  } 
  // å¦‚æœç‰Œå±±ç‚ºç©ºï¼Œå¾ç‹ç‰Œæ‘¸ç‰Œ
  else if (S.deadWall.length > 0) {
    t = S.deadWall.pop();
  } 
  // å¦‚æœéƒ½æ²’æœ‰ç‰Œäº†ï¼Œç„¡æ³•æ‘¸ç‰Œï¼ˆè¿™ä¸ªæ£€æŸ¥åº”è¯¥ä¸ä¼šåˆ°è¾¾ï¼Œå› ä¸ºä¸Šé¢å·²ç»æ£€æŸ¥è¿‡äº†ï¼‰
  else {
    console.error('âš ï¸ draw: ä¸åº”è¯¥åˆ°è¾¾è¿™é‡Œï¼Œç‰Œå±±å’Œç‹ç‰Œéƒ½ä¸ºç©º');
    return;
  }
  
  S.players[p].hand.push(t);
  S.players[p].drawnTile = t;
  S.players[p].drawCount = (S.players[p].drawCount || 0) + 1;
  // å‰©ä½™ç‰Œæ•° = å®é™…å¯ä¾›æ‘¸æ‰“çš„ç‰Œæ•°ï¼ˆä¸åŒ…æ‹¬ç‹ç‰Œï¼‰
  S.remain = S.wall.length;
  S.drawCount++;
  SoundEffects.draw();
  
  // åªæœ‰è‡ªå·±æ‘¸ç‰Œæ™‚æ‰é¡¯ç¤º log
  const myPSeat = getMyPlayerSeat();
  if (p === myPSeat) {
    const k = tileKey(t);
    log(`ğŸ¤² ä½ æ‘¸åˆ° ${keyToText(k)}`);
  }
  
  S.lastAction = 'draw';
  S.lastActor = p;
  
  // é€£ç·šæ¨¡å¼ï¼šç™¼é€æ‘¸ç‰Œæ“ä½œ
  if (isOnlineMode && p === mySeat && socket) {
    console.log('å‘é€æ‘¸ç‰Œæ“ä½œ, drawnTile:', tileKey(t));
    sendPlayerAction('draw', {});
    // å»¶è¿ŸåŒæ­¥ï¼Œç¡®ä¿æœ¬åœ°çŠ¶æ€å…ˆæ¸²æŸ“
    setTimeout(() => {
      syncGameStateToServer();
    }, 100);
  }
}

/* ========= UI æ¸²æŸ“ ========= */
function renderAll() {
  // æ£€æŸ¥æ¸¸æˆçŠ¶æ€æ˜¯å¦å­˜åœ¨
  if (!S || !S.round) {
    console.warn('âš ï¸ renderAll: æ¸¸æˆçŠ¶æ€æœªåˆå§‹åŒ–ï¼Œè·³è¿‡æ¸²æŸ“');
    return;
  }
  
  // ç¡®å®šå½“å‰ç©å®¶çš„åº§ä½ï¼ˆè¿çº¿æ¨¡å¼ç”¨ mySeatï¼Œå•æœºæ¨¡å¼ç”¨ 0ï¼‰
  const myPlayerSeat = (gameMode === 'online' && mySeat >= 0) ? mySeat : 0;
  
  // æ›´æ–°å›åˆè³‡è¨Š
  const roundStr = ['æ±','å—','è¥¿','åŒ—'][S.round - 1] + 'é¢¨' + (seatNames?.[S.dealer] || ['æ±','å—','è¥¿','åŒ—'][S.dealer]);
  document.getElementById('centerRound').textContent = roundStr;
  // å‰©ä½™ç‰Œæ•° = å®é™…å¯ä¾›æ‘¸æ‰“çš„ç‰Œæ•°ï¼ˆwall.lengthï¼Œä¸åŒ…æ‹¬ç‹ç‰Œï¼‰
  document.getElementById('centerRemain').textContent = Math.max(0, S.remain !== undefined ? S.remain : S.wall.length);
  
  // å°æ‰‹å€åŸŸï¼ˆæ ¹æ® myPlayerSeat è°ƒæ•´é¡ºåºï¼‰
  const opponentsArea = document.getElementById('opponentsArea');
  let opponentsHTML = '';
  // å¯¹æ‰‹åº§ä½é¡ºåºï¼šä»å½“å‰ç©å®¶çš„ä¸‹ä¸€ä½å¼€å§‹ï¼Œä¾æ¬¡æ˜¯ +1, +2, +3
  for (let offset = 1; offset <= 3; offset++) {
    const i = (myPlayerSeat + offset) % 4;
    const p = S.players[i];
    const wind = seatNames[i] || ['æ±','å—','è¥¿','åŒ—'][i];
    const name = S.names && S.names[i] ? S.names[i] : wind + 'å®¶';
    const isActive = S.turn === i && S.phase !== 'end';
    const isDealer = S.dealer === i;
    
    opponentsHTML += `
      <div class="opponent-card ${isActive ? 'active-turn' : ''}">
        <div class="opponent-header">
          <div class="opponent-name">
            <div class="wind-icon">${wind}</div>
            <span>${name}</span>
            ${isDealer ? `<span class="dealer-mark">èŠ${S.dealerStreak > 0 ? `<span class="streak-mark">${S.dealerStreak}</span>` : ''}</span>` : ''}
            ${p.declaredListen ? '<span class="listen-mark">è½</span>' : ''}
          </div>
          <div class="opponent-score">${p.points.toLocaleString()}</div>
        </div>
        <div class="opponent-content">
          <div class="discard-zone">
            ${p.discards.map(t => {
              const k = tileKey(t);
              return `<div class="tile tile-xs suit-${t.suit}">${keyToText(k)}</div>`;
            }).join('')}
          </div>
          ${p.melds.length > 0 ? `
            <div class="meld-zone">
              ${p.melds.map(m => {
                const isConcealed = m.concealed;
                return `<div class="meld-group">
                  ${m.tiles.map(t => {
                    if (isConcealed) {
                      return `<div class="tile tile-xs" style="background: #4a5568; color: transparent;">ç‰Œ</div>`;
                    }
                    const k = tileKey(t);
                    return `<div class="tile tile-xs suit-${t.suit}">${keyToText(k)}</div>`;
                  }).join('')}
                </div>`;
              }).join('')}
            </div>
          ` : ''}
        </div>
      </div>
    `;
  }
  opponentsArea.innerHTML = opponentsHTML;
  
  // æˆ‘çš„è³‡è¨Šï¼ˆä½¿ç”¨ myPlayerSeatï¼‰
  const me = S.players[myPlayerSeat];
  const myWind = seatNames[myPlayerSeat] || ['æ±','å—','è¥¿','åŒ—'][myPlayerSeat];
  document.getElementById('myWind').textContent = myWind;
  document.getElementById('myName').textContent = S.names && S.names[myPlayerSeat] ? S.names[myPlayerSeat] + '(ä½ )' : 'ä½ ';
  document.getElementById('myScore').textContent = me.points.toLocaleString();
  
  // æˆ‘çš„æ¨ç‰Œå€
  const myDiscardZone = document.getElementById('myDiscardZone');
  myDiscardZone.innerHTML = me.discards.map(t => {
    const k = tileKey(t);
    return `<div class="tile tile-xs suit-${t.suit}">${keyToText(k)}</div>`;
  }).join('');
  
  const myDealerMark = document.getElementById('myDealerMark');
  const myListenMark = document.getElementById('myListenMark');
  if (S.dealer === myPlayerSeat) {
    myDealerMark.classList.remove('hidden');
    // é¡¯ç¤ºé€£èŠæ¬¡æ•¸
    const streakText = S.dealerStreak > 0 ? `<span class="streak-mark">${S.dealerStreak}</span>` : '';
    myDealerMark.innerHTML = 'èŠ' + streakText;
  } else {
    myDealerMark.classList.add('hidden');
  }
  if (me.declaredListen) {
    myListenMark.classList.remove('hidden');
  } else {
    myListenMark.classList.add('hidden');
  }
  
  // è½ç‰Œæç¤ºï¼šç„¡è«–æœ‰æ²’æœ‰æŒ‰è½ï¼Œéƒ½é¡¯ç¤ºè½å“ªäº›ç‰Œ
  const listenHint = document.getElementById('listenHint');
  let waitingTiles = [];
  
  // æª¢æŸ¥æ˜¯å¦è½ç‰Œ
  const myKongCount = countKongs(me);
  const totalTiles = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
  const expectedFull = (S.dealer === myPlayerSeat ? 17 : 16) + myKongCount;
  const expectedEmpty = (S.dealer === myPlayerSeat ? 16 : 15) + myKongCount;
  
  if (totalTiles === expectedFull) {
    // æ‰‹ç‰Œæ»¿çš„ï¼Œæª¢æŸ¥ä¸Ÿæ‰ä¸€å¼µå¾Œæ˜¯å¦èƒ½è½ç‰Œ
    for (const tile of me.hand) {
      const testHand = me.hand.filter(t => t !== tile);
      if (isListening(testHand, me.melds)) {
        const waits = calcWaitingTiles(testHand, me.melds);
        waitingTiles = waits;
        break;
      }
    }
  } else if (totalTiles === expectedEmpty) {
    // æ‰‹ç‰Œç©ºçš„ï¼Œæª¢æŸ¥ç•¶å‰æ˜¯å¦å·²ç¶“è½ç‰Œ
    if (isListening(me.hand, me.melds)) {
      waitingTiles = calcWaitingTiles(me.hand, me.melds);
    }
  }
  
  // å¦‚æœæœ‰ç­‰ç‰Œï¼Œé¡¯ç¤º
  if (waitingTiles.length > 0) {
    listenHint.classList.remove('hidden');
    const status = me.declaredListen ? 'ğŸ”” å·²å ±è½' : 'ğŸ‘‚ å¯è½ç‰Œ';
    listenHint.innerHTML = `${status} ç­‰ç‰Œï¼š` + waitingTiles.map(k => `<span class="tile log-tile suit-${k[0]}">${keyToText(k)}</span>`).join(' ');
    // æ›´æ–°waitKeysä»¥ä¾¿å…¶ä»–åŠŸèƒ½ä½¿ç”¨
    me.waitKeys = waitingTiles.slice();
  } else {
    listenHint.classList.add('hidden');
    me.waitKeys = [];
  }
  
  // æˆ‘çš„æ‰‹ç‰Œ
  const handKongCount = countKongs(me);
  
  // ç¡®ä¿ me å¼•ç”¨çš„æ˜¯æ­£ç¡®çš„ç©å®¶
  if (!me || !me.hand) {
    console.error('é”™è¯¯: me æˆ– me.hand ä¸å­˜åœ¨', me);
    return;
  }
  
  const origTiles = me.hand.map((t, idx) => ({ tile: t, index: idx }));
  
  // è°ƒè¯•ï¼šè¾“å‡ºæ‰‹ç‰Œå’Œæ‘¸åˆ°çš„ç‰Œ
  console.log('æ¸²æŸ“æ‰‹ç‰Œ - åº§ä½:', myPlayerSeat, ', æ‰‹ç‰Œæ•°:', me.hand.length, ', drawnTile:', me.drawnTile ? tileKey(me.drawnTile) : null, ', origTilesæ•°é‡:', origTiles.length);
  
  // æª¢æŸ¥æ˜¯å¦æœ‰æ‘¸åˆ°çš„ç‰Œ
  // æ‘¸åˆ°çš„ç‰Œæ‡‰è©²æ˜¯æœ€å¾Œä¸€å¼µï¼ˆå› ç‚ºdrawå‡½æ•¸ä½¿ç”¨pushï¼‰ï¼Œæˆ–è€…é€šédrawnTileæ¨™è¨˜æ‰¾åˆ°
  let drawnObj = null;
  let displayRest = [];
  
  if (me.drawnTile) {
    const drawnTileKey = tileKey(me.drawnTile);
    console.log('æŸ¥æ‰¾drawnTile:', drawnTileKey, ', æ‰‹ç‰Œkeys:', me.hand.map(t => tileKey(t)));
    
    // å…ˆå˜—è©¦é€šédrawnTileæ‰¾åˆ°
    const drawnIndex = me.hand.findIndex(t => {
      // ä½¿ç”¨å°è±¡å¼•ç”¨æ¯”è¼ƒï¼Œå¦‚æœå¤±æ•—å‰‡ä½¿ç”¨å±¬æ€§æ¯”è¼ƒ
      if (t === me.drawnTile) return true;
      // å‚™ç”¨ï¼šæ¯”è¼ƒtileKeyï¼ˆæ›´å¯é ï¼‰
      if (t && me.drawnTile && tileKey(t) === tileKey(me.drawnTile)) return true;
      // å‚™ç”¨ï¼šæ¯”è¼ƒå±¬æ€§
      if (t && me.drawnTile && t.suit === me.drawnTile.suit && t.rank === me.drawnTile.rank && t.name === me.drawnTile.name) return true;
      return false;
    });
    
    console.log('drawnIndex:', drawnIndex);
    
    if (drawnIndex >= 0) {
      drawnObj = origTiles[drawnIndex];
      // å…¶ä»–ç‰Œæ’åºé¡¯ç¤º
      displayRest = origTiles.filter((_, idx) => idx !== drawnIndex)
        .sort((a, b) => tileSortKey(a.tile) - tileSortKey(b.tile));
    } else if (me.hand.length > 0) {
      // å¦‚æœæ‰¾ä¸åˆ°ï¼Œä½¿ç”¨æœ€å¾Œä¸€å¼µç‰Œï¼ˆå› ç‚ºdrawä½¿ç”¨pushï¼‰
      console.log('æ‰¾ä¸åˆ°drawnTileï¼Œä½¿ç”¨æœ€å¾Œä¸€å¼µ');
      const lastIdx = me.hand.length - 1;
      drawnObj = origTiles[lastIdx];
      displayRest = origTiles.slice(0, -1)
        .sort((a, b) => tileSortKey(a.tile) - tileSortKey(b.tile));
    }
  } else {
    console.log('æ²¡æœ‰drawnTile');
  }
  
  // å¦‚æœæ²’æœ‰æ‘¸åˆ°çš„ç‰Œï¼Œæ‰€æœ‰ç‰Œéƒ½æ’åºé¡¯ç¤º
  if (!drawnObj) {
    displayRest = origTiles.slice().sort((a, b) => tileSortKey(a.tile) - tileSortKey(b.tile));
  }
  
  let handHTML = '';
  // å…ˆé¡¯ç¤ºå…¶ä»–ç‰Œï¼ˆå·²æ’åºï¼‰
  displayRest.forEach(item => {
    const t = item.tile;
    const idx = item.index;
    const k = tileKey(t);
    handHTML += `<div class="tile tile-md suit-${t.suit}" onclick="onClickYourTile(${idx})">${keyToText(k)}</div>`;
  });
  
  // æ‘¸åˆ°çš„ç‰Œå§‹çµ‚é¡¯ç¤ºåœ¨æœ€å³å´
  if (drawnObj) {
    const t = drawnObj.tile;
    const idx = drawnObj.index;
    const k = tileKey(t);
    handHTML += `<div style="width: 12px; flex-shrink: 0;"></div>`;
    handHTML += `<div class="tile tile-md drawn suit-${t.suit}" onclick="onClickYourTile(${idx})">${keyToText(k)}</div>`;
  }
  
  console.log('æ¸²æŸ“æ‰‹ç‰Œå®Œæˆ: displayRestæ•°é‡:', displayRest.length, ', drawnObj:', drawnObj ? tileKey(drawnObj.tile) : null, ', æ€»HTMLé•¿åº¦:', handHTML.length);
  
  const handElement = document.getElementById('yourHand');
  handElement.innerHTML = handHTML;
  
  // å¦‚æœæœ‰æ‘¸åˆ°çš„ç‰Œï¼Œè‡ªå‹•æ»¾å‹•åˆ°æœ€å³å´é¡¯ç¤º
  if (drawnObj) {
    requestAnimationFrame(() => {
      handElement.scrollLeft = handElement.scrollWidth;
    });
  }
  
  // æˆ‘çš„å‰¯éœ²
  let meldsHTML = '';
  if (me.melds.length > 0) {
    meldsHTML = me.melds.map(m => {
      let label = '';
      if (m.type === 'pong') label = 'ç¢°';
      if (m.type === 'kong') label = m.concealed ? 'æš—æ§“' : 'æ§“';
      if (m.type === 'chow') label = 'åƒ';
      
      let tilesForDisp;
      if (m.type === 'chow' && typeof m.centerIdx === 'number') {
        const arr = m.tiles.slice();
        const center = arr.splice(m.centerIdx, 1)[0];
        const lower = arr[0];
        const higher = arr[1];
        tilesForDisp = [lower, center, higher];
      } else {
        tilesForDisp = m.tiles;
      }
      
      const tilesHTML = tilesForDisp.map(t => {
        const k = tileKey(t);
        return `<span class="tile tile-sm suit-${t.suit}">${keyToText(k)}</span>`;
      }).join('');
      
      return `<div class="meld-badge"><span class="meld-label">${label}</span>${tilesHTML}</div>`;
    }).join('');
  }
  document.getElementById('yourMelds').innerHTML = meldsHTML;
  
  // æŒ‰éˆ•ç‹€æ…‹
  const btnHu = document.getElementById('btnHu');
  btnHu.disabled = true;
  if (S.turn === myPlayerSeat && S.phase !== 'end' && S.waitReact === null) {
    // æª¢æŸ¥è‡ªæ‘¸ï¼šå¦‚æœæœ‰æ‘¸åˆ°çš„ç‰Œï¼Œæª¢æŸ¥æ˜¯å¦èƒ½èƒ¡
    if (me.drawnTile) {
      // drawnTileå·²ç»åœ¨handä¸­äº†ï¼ˆdrawå‡½æ•°ä¸­å·²ç»pushï¼‰ï¼Œç›´æ¥ç”¨handæ£€æŸ¥
      // æ£€æŸ¥æ˜¯å¦èƒ½èƒ¡ï¼šisWinningNowä¼šæ£€æŸ¥handä¸­çš„æ‰€æœ‰ç‰Œï¼ŒåŒ…æ‹¬drawnTile
      if (isWinningNow(me.hand, me.melds, me.drawnTile)) {
        btnHu.disabled = false;
        console.log('renderAll: æ£€æµ‹åˆ°è‡ªæ‘¸ï¼Œå¯ç”¨èƒ¡ç‰ŒæŒ‰é’®, drawnTile:', tileKey(me.drawnTile));
      } else {
        console.log('renderAll: ä¸èƒ½è‡ªæ‘¸, handé•¿åº¦:', me.hand.length, ', drawnTile:', tileKey(me.drawnTile));
      }
    }
    // å¦‚æœæ²’æœ‰drawnTileï¼Œæª¢æŸ¥æ‰‹ç‰Œæœ€å¾Œä¸€å¼µï¼ˆå¯èƒ½æ˜¯å‰›æ‘¸åˆ°çš„ç‰Œï¼Œä¾‹å¦‚æ§“ç‰Œå¾Œï¼‰
    if (!me.drawnTile && me.hand.length > 0) {
      const lastTile = me.hand[me.hand.length - 1];
      if (isWinningNow(me.hand, me.melds, lastTile)) {
        btnHu.disabled = false;
        console.log('renderAll: æ£€æµ‹åˆ°è‡ªæ‘¸ï¼ˆæ— drawnTileï¼‰ï¼Œå¯ç”¨èƒ¡ç‰ŒæŒ‰é’®');
      }
    }
    // æª¢æŸ¥æ¦®èƒ¡ï¼šå¦‚æœæœ‰lastDiscardä¸”èƒ½èƒ¡
    if (S.lastDiscard && S.lastDiscard.from !== myPlayerSeat) {
      if (canWinOn(myPlayerSeat, S.lastDiscard.tile)) {
        btnHu.disabled = false;
        console.log('renderAll: æ£€æµ‹åˆ°è£èƒ¡ï¼Œå¯ç”¨èƒ¡ç‰ŒæŒ‰é’®');
      }
    }
  }
  
  // è½ç‰ŒæŒ‰éˆ•
  let canListenBtn = false;
  if (me.declaredListen) {
    canListenBtn = false;
  } else if (S.turn === myPlayerSeat && S.phase !== 'end' && S.waitReact === null) {
    const listenKongCount = countKongs(me);
    const totalTilesMe = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    const expectedFullBtn = (S.dealer === myPlayerSeat ? 17 : 16) + listenKongCount;
    const expectedEmptyBtn = (S.dealer === myPlayerSeat ? 16 : 15) + listenKongCount;
    
    // å¦‚æœæ‰‹ç‰Œæ˜¯æ»¿çš„ï¼ˆå‰›æ‘¸åˆ°ç‰Œï¼‰ï¼Œæª¢æŸ¥ä¸Ÿæ‰ä¸€å¼µå¾Œæ˜¯å¦èƒ½è½ç‰Œ
    if (totalTilesMe === expectedFullBtn) {
      canListenBtn = me.hand.some(tile => {
        const testHand = me.hand.filter(t => t !== tile);
        return isListening(testHand, me.melds);
      });
    }
    // å¦‚æœæ‰‹ç‰Œæ˜¯ç©ºçš„ï¼ˆå·²ç¶“ä¸Ÿéç‰Œï¼‰ï¼Œæª¢æŸ¥ç•¶å‰æ˜¯å¦å·²ç¶“è½ç‰Œ
    else if (totalTilesMe === expectedEmptyBtn) {
      canListenBtn = isListening(me.hand, me.melds);
    }
    // ä¸€é€²è½ï¼šæª¢æŸ¥ä¸Ÿæ‰ä»»æ„ä¸€å¼µç‰Œå¾Œæ˜¯å¦èƒ½è½ç‰Œï¼ˆæ‰‹ç‰Œæ•¸é‡åœ¨åˆç†ç¯„åœå…§ï¼‰
    else {
      // æª¢æŸ¥æ˜¯å¦ä¸€é€²è½ï¼ˆä¸Ÿæ‰ä¸€å¼µç‰Œå°±èƒ½è½ç‰Œï¼‰
      canListenBtn = me.hand.some(tile => {
        const testHand = me.hand.filter(t => t !== tile);
        return isListening(testHand, me.melds);
      });
    }
  }
  document.getElementById('btnListen').disabled = !canListenBtn;
  
  // æ§“æŒ‰éˆ•
  const btnKong = document.getElementById('btnKong');
  if (S.turn === myPlayerSeat && S.phase !== 'end' && S.waitReact === null) {
    const cks = canConcealedKong(myPlayerSeat);
    const aks = canAddedKong(myPlayerSeat);
    btnKong.disabled = (cks.length === 0 && aks.length === 0);
  } else {
    btnKong.disabled = true;
  }
}

function showHandsAndContinue() {
  const overlay = document.getElementById('modalOverlay');
  const content = document.getElementById('modalContent');
  
  // è¿çº¿æ¨¡å¼ï¼šæ¸…ç©ºå‡†å¤‡çŠ¶æ€
  if (isOnlineMode) {
    readyPlayers.clear();
  }
  
  let html = '';
  
  // è¨ˆç®—æ¯ä½ç©å®¶çš„å°æ•¸è®ŠåŒ–
  let playerFanDetails = {};
  if (S.winner !== null) {
    const winner = S.winner;
    const from = S.fromPlayer;
    const selfDraw = (from === -1);
    const detail = calcFanDetails(winner, S.winTile, selfDraw);
    const fan = detail.fan;
    
    // è¨ˆç®—é€£èŠå°æ•¸ï¼ˆä½¿ç”¨å…¨å±€è®Šé‡dealerStreakï¼‰
    const currentDealerStreak = dealerStreak || 0;
    const streakFan = calcDealerStreakFan(currentDealerStreak);
    const isDealer = winner === S.dealer;
    const isFromDealer = from === S.dealer;
    
    // è¨ˆç®—åŸºæœ¬åˆ†æ•¸ï¼ˆç‰Œå‹å°æ•¸ï¼‰
    const baseDelta = GAME_SETTINGS.basePoints + fan * GAME_SETTINGS.perFanPoints;
    
    // è¨ˆç®—æ¯ä½ç©å®¶çš„å°æ•¸å’Œåˆ†æ•¸è®ŠåŒ–
    if (selfDraw) {
      if (isDealer) {
        // èŠå®¶è‡ªæ‘¸ï¼šå‘æ¯ä½é–’å®¶æ”¶å–ã€Œç‰Œå‹å°æ•¸ + é€£èŠå°æ•¸ã€
        const totalFan = fan + streakFan;
        const totalDelta = baseDelta + streakFan * GAME_SETTINGS.perFanPoints;
        playerFanDetails[winner] = { fan: totalFan, delta: totalDelta * 3, label: 'è‡ªæ‘¸ï¼ˆèŠå®¶ï¼‰' };
        for (let i = 0; i < 4; i++) {
          if (i !== winner) {
            playerFanDetails[i] = { fan: totalFan, delta: -totalDelta, label: 'æ”¯ä»˜' };
          }
        }
      } else {
        // é–’å®¶è‡ªæ‘¸ï¼šèŠå®¶éœ€å¤šä»˜1å°ï¼Œå…¶ä»–é–’å®¶åªä»˜ç‰Œå‹å°æ•¸
        const dealerExtraFan = 1; // èŠå®¶é¡å¤–æ”¯ä»˜çš„å°æ•¸
        const dealerDelta = baseDelta + dealerExtraFan * GAME_SETTINGS.perFanPoints; // èŠå®¶æ”¯ä»˜çš„é‡‘é¡
        const totalFanForDealer = fan + dealerExtraFan; // èŠå®¶æ”¯ä»˜çš„ç¸½å°æ•¸
        
        playerFanDetails[winner] = { fan: fan, delta: dealerDelta + baseDelta * 2, label: 'è‡ªæ‘¸' };
        playerFanDetails[S.dealer] = { fan: totalFanForDealer, delta: -dealerDelta, label: 'æ”¯ä»˜ï¼ˆèŠå®¶ï¼‰' };
        for (let i = 0; i < 4; i++) {
          if (i !== winner && i !== S.dealer) {
            playerFanDetails[i] = { fan: fan, delta: -baseDelta, label: 'æ”¯ä»˜' };
          }
        }
      }
    } else {
      if (isFromDealer) {
        // é–’å®¶èƒ¡èŠå®¶ï¼šèŠå®¶éœ€æ”¯ä»˜ã€Œç‰Œå‹å°æ•¸ + é€£èŠå°æ•¸ã€çµ¦è©²é–’å®¶
        const totalFan = fan + streakFan;
        const totalDelta = baseDelta + streakFan * GAME_SETTINGS.perFanPoints;
        playerFanDetails[winner] = { fan: totalFan, delta: totalDelta * 3, label: 'é»èƒ¡' };
        playerFanDetails[from] = { fan: totalFan, delta: -totalDelta * 3, label: 'æ”¾æ§ï¼ˆèŠå®¶ï¼‰' };
        for (let i = 0; i < 4; i++) {
          if (i !== winner && i !== from) {
            playerFanDetails[i] = { fan: 0, delta: 0, label: 'ç„¡é—œ' };
          }
        }
      } else {
        // é–’å®¶èƒ¡é–’å®¶ï¼šèˆ‡èŠå®¶çš„é€£èŠå°æ•¸ç„¡é—œï¼Œåƒ…è¨ˆç®—ç‰Œå‹å°æ•¸
        playerFanDetails[winner] = { fan: fan, delta: baseDelta * 3, label: 'é»èƒ¡' };
        playerFanDetails[from] = { fan: fan, delta: -baseDelta * 3, label: 'æ”¾æ§' };
        for (let i = 0; i < 4; i++) {
          if (i !== winner && i !== from) {
            playerFanDetails[i] = { fan: 0, delta: 0, label: 'ç„¡é—œ' };
          }
        }
      }
    }
    
    const catStr = detail.categories.join('ã€');
    const winnerName = playerName(winner);
    
    if (selfDraw) {
      html += `<div class="modal-title">ğŸ‰ ${winnerName} è‡ªæ‘¸èƒ¡ç‰Œ</div>`;
    } else {
      const loserName = playerName(from);
      html += `<div class="modal-title">ğŸ‰ ${winnerName} é»èƒ¡</div>`;
      html += `<div style="text-align: center; color: var(--accent-red); margin-bottom: 12px;">æ”¾æ§ï¼š${loserName}</div>`;
    }
    const streakText = currentDealerStreak > 0 ? `ï¼ˆå«é€£èŠ${currentDealerStreak}æ¬¡${streakFan}å°ï¼‰` : '';
    html += `<div style="text-align: center; color: var(--accent-jade); font-size: 16px; margin-bottom: 16px;">${catStr}ï¼Œå…± <strong>${detail.fan}å°${streakText}</strong></div>`;
  } else {
    html += '<div class="modal-title">ğŸš« æµå±€</div>';
    html += '<div style="text-align: center; color: var(--text-secondary); margin-bottom: 16px;">ç‰Œå±±æ¯ç«­</div>';
    
    // èªéŸ³æ’­å ±
    speakRandom('drawGame');
  }
  
  html += '<div class="modal-section-title">æ‰€æœ‰ç©å®¶æ‰‹ç‰Œèˆ‡å°æ•¸</div>';
  
  for (let i = 0; i < 4; i++) {
    const p = S.players[i];
    const name = playerName(i);
    const isWinner = (S.winner === i);
    const fanInfo = playerFanDetails[i] || { fan: 0, delta: 0, label: '' };
    
    html += `<div class="modal-player ${isWinner ? 'winner' : ''}">`;
    html += `<div class="modal-player-header">
      <span class="modal-player-name">${isWinner ? 'ğŸ† ' : ''}${name}</span>
      <span class="modal-player-score">${p.points.toLocaleString()}</span>
    </div>`;
    
    // é¡¯ç¤ºå°æ•¸å’Œåˆ†æ•¸è®ŠåŒ–
    if (S.winner !== null && fanInfo.label) {
      const deltaText = fanInfo.delta > 0 ? `+${fanInfo.delta.toLocaleString()}` : fanInfo.delta.toLocaleString();
      const deltaColor = fanInfo.delta > 0 ? 'var(--accent-jade)' : (fanInfo.delta < 0 ? 'var(--accent-red)' : 'var(--text-secondary)');
      html += `<div style="text-align: center; margin: 8px 0; padding: 6px; background: rgba(241,245,249,0.5); border-radius: 6px;">
        <div style="font-size: 14px; color: var(--text-secondary);">${fanInfo.label}</div>
        <div style="font-size: 16px; font-weight: 700; color: ${deltaColor};">${fanInfo.fan > 0 ? fanInfo.fan + 'å°' : ''} ${deltaText}</div>
      </div>`;
    }
    
    html += '<div class="modal-hand">';
    const sortedHand = p.hand.slice().sort((a, b) => tileSortKey(a) - tileSortKey(b));
    sortedHand.forEach(t => {
      const k = tileKey(t);
      html += `<div class="tile tile-sm suit-${t.suit}">${keyToText(k)}</div>`;
    });
    html += '</div>';
    
    if (p.melds.length > 0) {
      html += '<div style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px;">';
      p.melds.forEach(m => {
        html += '<div style="display: flex; gap: 2px;">';
        m.tiles.forEach(t => {
          const k = tileKey(t);
          html += `<div class="tile tile-sm suit-${t.suit}">${keyToText(k)}</div>`;
        });
        html += '</div>';
      });
      html += '</div>';
    }
    
    html += '</div>';
  }
  
  // è¿çº¿æ¨¡å¼ï¼šæ˜¾ç¤ºæ¯ä¸ªç©å®¶çš„å‡†å¤‡çŠ¶æ€
  if (isOnlineMode && onlinePlayers && onlinePlayers.length > 0) {
    html += '<div class="modal-section-title" style="margin-top: 16px;">æº–å‚™ç‹€æ…‹</div>';
    html += '<div style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 16px;">';
    onlinePlayers.forEach(player => {
      const isReady = readyPlayers.has(player.seat);
      const playerName = S.names && S.names[player.seat] ? S.names[player.seat] : `ç©å®¶${player.seat}`;
      const statusIcon = isReady ? 'âœ…' : 'â³';
      const statusText = isReady ? 'å·²æº–å‚™' : 'ç­‰å¾…ä¸­';
      html += `<div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(241,245,249,0.5); border-radius: 6px;">
        <span>${playerName}</span>
        <span style="color: ${isReady ? 'var(--accent-jade)' : 'var(--text-secondary)'};">${statusIcon} ${statusText}</span>
      </div>`;
    });
    html += '</div>';
    
    // æ˜¾ç¤ºç­‰å¾…æç¤º
    if (readyPlayers.size < onlinePlayers.length) {
      html += `<div style="text-align: center; color: var(--text-secondary); font-size: 14px; margin-bottom: 12px;">
        ç­‰å¾…æ‰€æœ‰ç©å®¶æº–å‚™... (${readyPlayers.size}/${onlinePlayers.length})
      </div>`;
    }
  }
  
  html += '<button class="modal-btn" id="btnContinueNext">â–¶ï¸ ç¹¼çºŒä¸‹ä¸€å±€</button>';
  
  content.innerHTML = html;
  overlay.classList.add('show');
  
  // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
  if (continueModalTimeout) {
    clearTimeout(continueModalTimeout);
    continueModalTimeout = null;
  }
  
  // 3ç§’åè‡ªåŠ¨å…³é—­ï¼ˆä»…å•æœºæ¨¡å¼æˆ–æ‰€æœ‰ç©å®¶éƒ½å‡†å¤‡å¥½åï¼‰
  if (!isOnlineMode || (isOnlineMode && readyPlayers.size >= onlinePlayers.length)) {
    continueModalTimeout = setTimeout(() => {
      overlay.classList.remove('show');
      if (!isOnlineMode) {
        log('â€”â€” é–‹ä¸‹ä¸€å±€ â€”â€”');
        startNewHand();
      }
    }, 3000);
  }
  
  document.getElementById('btnContinueNext').onclick = () => {
    if (isOnlineMode && socket && currentRoomId) {
      // è¿çº¿æ¨¡å¼ï¼šå‘é€å‡†å¤‡çŠ¶æ€
      socket.emit('playerReady', { roomId: currentRoomId, seat: mySeat });
      
      // æ›´æ–°æœ¬åœ°å‡†å¤‡çŠ¶æ€
      readyPlayers.add(mySeat);
      
      // æ›´æ–°UI
      updateReadyStatus();
      
      // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç©å®¶éƒ½å‡†å¤‡å¥½äº†
      if (readyPlayers.size >= onlinePlayers.length) {
        // æ‰€æœ‰ç©å®¶éƒ½å‡†å¤‡å¥½äº†ï¼Œå¼€å§‹æ–°å±€
        if (isHost) {
          // æˆ¿ä¸»è´Ÿè´£å¼€å§‹æ–°å±€
          setTimeout(() => {
            overlay.classList.remove('show');
            readyPlayers.clear(); // æ¸…ç©ºå‡†å¤‡çŠ¶æ€
            log('â€”â€” é–‹ä¸‹ä¸€å±€ â€”â€”');
            startNewHand();
          }, 500);
        } else {
          // éæˆ¿ä¸»ç­‰å¾…æˆ¿ä¸»å¼€å§‹æ–°å±€
          log('â³ ç­‰å¾…æˆ¿ä¸»é–‹å§‹æ–°å±€...');
        }
      } else {
        log(`â³ å·²æº–å‚™ï¼Œç­‰å¾…å…¶ä»–ç©å®¶... (${readyPlayers.size}/${onlinePlayers.length})`);
      }
    } else {
      // å•æœºæ¨¡å¼ï¼šç›´æ¥å¼€å§‹æ–°å±€
      overlay.classList.remove('show');
      if (continueModalTimeout) {
        clearTimeout(continueModalTimeout);
        continueModalTimeout = null;
      }
      log('â€”â€” é–‹ä¸‹ä¸€å±€ â€”â€”');
      startNewHand();
    }
  };
  
  // æ›´æ–°å‡†å¤‡çŠ¶æ€çš„å‡½æ•°
  function updateReadyStatus() {
    if (!isOnlineMode || !onlinePlayers) return;
    
    const currentContent = document.getElementById('modalContent');
    if (!currentContent) return;
    
    onlinePlayers.forEach(player => {
      const isReady = readyPlayers.has(player.seat);
      const playerName = S.names && S.names[player.seat] ? S.names[player.seat] : `ç©å®¶${player.seat}`;
      const statusIcon = isReady ? 'âœ…' : 'â³';
      const statusText = isReady ? 'å·²æº–å‚™' : 'ç­‰å¾…ä¸­';
      
      // æŸ¥æ‰¾åŒ…å«è¯¥ç©å®¶åç§°çš„div
      const allDivs = currentContent.querySelectorAll('div');
      for (const div of allDivs) {
        if (div.textContent.includes(playerName)) {
          const statusSpan = div.querySelector('span:last-child');
          if (statusSpan && (statusSpan.textContent.includes('å·²æº–å‚™') || statusSpan.textContent.includes('ç­‰å¾…ä¸­'))) {
            statusSpan.innerHTML = `${statusIcon} ${statusText}`;
            statusSpan.style.color = isReady ? 'var(--accent-jade)' : 'var(--text-secondary)';
            break;
          }
        }
      }
    });
    
    // æ›´æ–°ç­‰å¾…æç¤º
    const waitTexts = currentContent.querySelectorAll('div');
    for (const div of waitTexts) {
      if (div.textContent.includes('ç­‰å¾…æ‰€æœ‰ç©å®¶æº–å‚™')) {
        if (readyPlayers.size < onlinePlayers.length) {
          div.textContent = `ç­‰å¾…æ‰€æœ‰ç©å®¶æº–å‚™... (${readyPlayers.size}/${onlinePlayers.length})`;
        }
        break;
      }
    }
  }
  
  // ä¿å­˜updateReadyStatuså‡½æ•°åˆ°å…¨å±€ï¼Œä»¥ä¾¿socketäº‹ä»¶ä½¿ç”¨
  window.updateReadyStatus = updateReadyStatus;
}

function showFinalScore() {
  S.phase = 'end';
  renderAll();
  
  const overlay = document.getElementById('modalOverlay');
  const content = document.getElementById('modalContent');
  
  const rankings = S.players.map((p, i) => ({ name: playerName(i), points: p.points, index: i }))
    .sort((a, b) => b.points - a.points);
  
  let html = '<div class="modal-title">ğŸ† éŠæˆ²çµæŸ</div>';
  html += '<div class="modal-section">';
  
  const medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', '4ï¸âƒ£'];
  rankings.forEach((r, rank) => {
    html += `<div style="display: flex; justify-content: space-between; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px; margin-bottom: 8px;">
      <span>${medals[rank]} ${r.name}</span>
      <span style="color: var(--accent-jade); font-weight: 700;">${r.points.toLocaleString()}</span>
    </div>`;
  });
  
  html += '</div>';
  html += '<button class="modal-btn" id="btnNewGame">ğŸ® é–‹å§‹æ–°éŠæˆ²</button>';
  
  content.innerHTML = html;
  overlay.classList.add('show');
  
  document.getElementById('btnNewGame').onclick = () => {
    overlay.classList.remove('show');
    document.getElementById('log').innerHTML = '';
    dealerStreak = 0;
    startNewHand(true);
  };
}

/* ========= äº‹ä»¶ç¶å®š ========= */
document.getElementById('btnHu').onclick = () => {
  initAudio();
  const myPSeat = getMyPlayerSeat();
  if (S.currentReactions) {
    handleHuClick();
  } else {
    const me = S.players[myPSeat];
    // è‡ªæ‘¸æƒ…æ³ï¼šå„ªå…ˆæª¢æŸ¥drawnTile
    if (me.drawnTile) {
      // æª¢æŸ¥drawnTileæ˜¯å¦åœ¨æ‰‹ç‰Œä¸­
      const drawnInHand = me.hand.find(t => t === me.drawnTile || 
        (t.suit === me.drawnTile.suit && t.rank === me.drawnTile.rank && 
         (!t.name || t.name === me.drawnTile.name)));
      if (drawnInHand && isWinningNow(me.hand, me.melds, me.drawnTile)) {
        doWin(myPSeat, -1, me.drawnTile, true);
        return;
      }
    }
    // å¦‚æœæ²’æœ‰drawnTileï¼Œæª¢æŸ¥æ‰‹ç‰Œæœ€å¾Œä¸€å¼µï¼ˆå¯èƒ½æ˜¯å‰›æ‘¸åˆ°çš„ç‰Œï¼Œä¾‹å¦‚æ§“ç‰Œå¾Œï¼‰
    if (me.hand.length > 0) {
      const lastTile = me.hand[me.hand.length - 1];
      if (isWinningNow(me.hand, me.melds, lastTile)) {
        doWin(myPSeat, -1, lastTile, true);
      }
    }
  }
};

document.getElementById('btnListen').onclick = () => {
  initAudio();
  const myPSeat = getMyPlayerSeat();
  if (S.turn !== myPSeat || S.phase === 'end' || S.waitReact !== null) return;
  const me = S.players[myPSeat];
  if (me.declaredListen) return;
  
  const kongCount = countKongs(me);
  const total = me.hand.length + me.melds.reduce((s, m) => s + m.tiles.length, 0);
  const expectedFull = (S.dealer === myPSeat ? 17 : 16) + kongCount;
  const expectedEmpty = (S.dealer === myPSeat ? 16 : 15) + kongCount;
  
  let canListen = false;
  let listenAfterDiscard = false;
  let discardTile = null;
  
  // å¦‚æœæ‰‹ç‰Œæ˜¯æ»¿çš„ï¼ˆå‰›æ‘¸åˆ°ç‰Œï¼‰ï¼Œæª¢æŸ¥ä¸Ÿæ‰ä¸€å¼µå¾Œæ˜¯å¦èƒ½è½ç‰Œ
  if (total === expectedFull) {
    // æ‰¾åˆ°èƒ½è½ç‰Œçš„ä¸Ÿç‰Œé¸æ“‡
    for (const tile of me.hand) {
      const testHand = me.hand.filter(t => t !== tile);
      if (isListening(testHand, me.melds)) {
        canListen = true;
        listenAfterDiscard = true;
        discardTile = tile;
        break;
      }
    }
  } 
  // å¦‚æœæ‰‹ç‰Œæ˜¯ç©ºçš„ï¼ˆå·²ç¶“ä¸Ÿéç‰Œï¼‰ï¼Œæª¢æŸ¥ç•¶å‰æ˜¯å¦å·²ç¶“è½ç‰Œ
  else if (total === expectedEmpty) {
    canListen = isListening(me.hand, me.melds);
  }
  // ä¸€é€²è½ï¼šæª¢æŸ¥ä¸Ÿæ‰ä»»æ„ä¸€å¼µç‰Œå¾Œæ˜¯å¦èƒ½è½ç‰Œ
  else {
    // æª¢æŸ¥æ˜¯å¦ä¸€é€²è½ï¼ˆä¸Ÿæ‰ä¸€å¼µç‰Œå°±èƒ½è½ç‰Œï¼‰
    for (const tile of me.hand) {
      const testHand = me.hand.filter(t => t !== tile);
      if (isListening(testHand, me.melds)) {
        canListen = true;
        listenAfterDiscard = true;
        discardTile = tile;
        break;
      }
    }
  }
  
  if (!canListen) {
    log('âš ï¸ ä½ é‚„æ²’æœ‰è½ç‰Œï¼Œç„¡æ³•å ±è½');
    return;
  }
  
  me.declaredListen = true;
  updateTianDiTing(0);
  
  // è¨ˆç®—ç­‰ç‰Œ
  let waits = [];
  if (listenAfterDiscard) {
    // å¦‚æœä¸Ÿæ‰æŸå¼µç‰Œå¾Œèƒ½è½ç‰Œï¼Œè®“ç©å®¶è‡ªå·±é¸æ“‡è¦ä¸Ÿçš„ç‰Œ
    // æ‰¾å‡ºæ‰€æœ‰èƒ½è½ç‰Œçš„ä¸Ÿç‰Œé¸æ“‡
    const validDiscards = [];
    for (const tile of me.hand) {
      const testHand = me.hand.filter(t => t !== tile);
      if (isListening(testHand, me.melds)) {
        validDiscards.push(tile);
      }
    }
    
    if (validDiscards.length > 0) {
      // é¡¯ç¤ºæ‰€æœ‰èƒ½è½ç‰Œçš„é¸æ“‡ï¼ˆä½¿ç”¨ç¬¬ä¸€å€‹ä½œç‚ºç¤ºä¾‹è¨ˆç®—ç­‰ç‰Œï¼‰
      const firstDiscard = validDiscards[0];
      const testHand = me.hand.filter(t => t !== firstDiscard);
      waits = calcWaitingTiles(testHand, me.melds);
      me.tingLocked = false; // å…ˆä¸é–å®šï¼Œç­‰ä¸Ÿç‰Œå¾Œå†é–å®š
      me.requiredDiscard = null; // ä¸æŒ‡å®šç‰¹å®šç‰Œï¼Œè®“ç©å®¶è‡ªå·±é¸æ“‡
      log('ğŸ”” ä½ å ±è½äº†ï¼');
      log('ğŸ‘‚ è«‹é¸æ“‡ä¸€å¼µèƒ½å½¢æˆè½ç‰Œçš„ç‰Œæ‰“å‡º');
      if (validDiscards.length > 1) {
        const discardTexts = validDiscards.map(t => keyToText(tileKey(t))).join('ã€');
        log('ğŸ’¡ å¯é¸ï¼š' + discardTexts);
      }
      // è¨ˆç®—æ‰€æœ‰å¯èƒ½çš„ç­‰ç‰Œï¼ˆå–ä¸¦é›†ï¼‰
      const allWaits = new Set();
      validDiscards.forEach(tile => {
        const testHand = me.hand.filter(t => t !== tile);
        const tileWaits = calcWaitingTiles(testHand, me.melds);
        tileWaits.forEach(w => allWaits.add(w));
      });
      waits = Array.from(allWaits);
      if (waits.length > 0) {
        log('ğŸ‘‚ ç­‰ç‰Œï¼š' + waits.map(k => keyToText(k)).join(' '));
      }
    }
  } else {
    // å·²ç¶“è½ç‰Œï¼Œç›´æ¥è¨ˆç®—ç­‰ç‰Œ
    waits = calcWaitingTiles(me.hand, me.melds);
    me.tingLocked = false; // ä¸é–å®šï¼Œå¯ä»¥æ‰“ä»»æ„èƒ½ä¿æŒè½ç‰Œçš„ç‰Œ
    me.requiredDiscard = null; // æ¸…é™¤éœ€è¦ä¸Ÿçš„ç‰Œ
    log('ğŸ”” ä½ å ±è½äº†ï¼');
    log('ğŸ‘‚ ç­‰ç‰Œï¼š' + waits.map(k => keyToText(k)).join(' '));
  }
  
  me.waitKeys = waits.slice();
  SoundEffects.listen();
  showEffect('ğŸ”” è½ç‰Œ', '#2dd4bf', '44px');
  
  // èªéŸ³æ’­å ±
  speakRandom('listen');
  
  // é€£ç·šæ¨¡å¼ï¼šç™¼é€å ±è½æ“ä½œ
  if (isOnlineMode && socket) {
    sendPlayerAction('listen', {});
    syncGameStateToServer();
  }
  
  renderAll();
};

document.getElementById('btnKong').onclick = () => {
  initAudio();
  const myPSeat = getMyPlayerSeat();
  // å¦‚æœå…¶ä»–ç©å®¶æ‰“å‡ºç‰Œï¼Œä½¿ç”¨åæ‡‰è™•ç†
  if (S.lastDiscard !== null && S.waitReact !== null) {
    handleKongClick();
    return;
  }
  // å¦‚æœæ˜¯è‡ªå·±çš„å›åˆï¼Œé€²è¡Œæš—æ§“æˆ–åŠ æ§“
  if (S.turn !== myPSeat || S.phase === 'end' || S.lastDiscard !== null) return;
  const me = S.players[myPSeat];
  const added = canAddedKong(myPSeat);
  const concealed = canConcealedKong(myPSeat);
  
  if (added.length > 0) {
    const cand = added[0];
    // æ¶æ§“æª¢æŸ¥å·²ç¶“åœ¨doAddedKongå…§éƒ¨é€²è¡Œ
    doAddedKong(myPSeat, cand.meldIndex);
    return;
  }
  
  if (concealed.length > 0) {
    const key = concealed[0];
    doConcealedKong(myPSeat, key);
    return;
  }
};

document.getElementById('newGameBtn').onclick = () => {
  initAudio();
  if (confirm('ç¢ºå®šè¦é–‹å§‹æ–°éŠæˆ²å—ï¼Ÿç•¶å‰éŠæˆ²é€²åº¦å°‡è¢«æ¸…é™¤ã€‚')) {
    S = { players: Array.from({ length: 4 }, () => ({ points: GAME_SETTINGS.initialPoints })) };
    document.getElementById('log').innerHTML = '';
    dealerStreak = 0;
    stopAutoSave();
    startNewHand(true);
    startAutoSave();
  }
};

document.getElementById('btnChow').onclick = () => {
  initAudio();
  handleChowClick();
};

document.getElementById('btnPong').onclick = () => {
  initAudio();
  handlePongClick();
};

document.getElementById('btnPass').onclick = () => {
  initAudio();
  handlePassClick();
};

function onClickYourTile(idx) {
  initAudio();
  const myPSeat = getMyPlayerSeat();
  if (S.turn !== myPSeat || S.phase === 'end') return;
  const me = S.players[myPSeat];
  
  if (S.waitReact !== null) {
    log('âš ï¸ è«‹å…ˆé¸æ“‡åƒã€ç¢°ã€æ§“æˆ–é');
    return;
  }
  
  // å¦‚æœå·²ç¶“å ±è½ä½†é‚„æ²’é–å®šï¼ˆå‰›æŒ‰è½ç‰ŒæŒ‰éˆ•çš„é‚£å›åˆï¼‰
  if (me.declaredListen && !me.tingLocked) {
    const tile = me.hand[idx];
    
    // æª¢æŸ¥ä¸Ÿç‰Œå¾Œæ˜¯å¦èƒ½å½¢æˆè½ç‰Œï¼ˆè®“ç©å®¶è‡ªå·±é¸æ“‡ï¼‰
    const afterDiscard = me.hand.filter(t => t !== tile);
    if (!isListening(afterDiscard, me.melds)) {
      log('âš ï¸ å ±è½å¾Œåªèƒ½ä¸Ÿæœƒå½¢æˆè½ç‰Œçš„æ‰‹ç‰Œ');
      return;
    }
    
    // ä¸Ÿç‰Œå¾Œé–å®šè½ç‰Œï¼Œä¸¦é‡æ–°è¨ˆç®—ç­‰ç‰Œ
    discard(myPSeat, tile);
    me.tingLocked = true;
    const waits = calcWaitingTiles(afterDiscard, me.melds);
    me.waitKeys = waits.slice();
    if (waits.length > 0) {
      log('ğŸ”’ è½ç‰Œå·²é–å®šï¼Œç­‰ç‰Œï¼š' + waits.map(k => keyToText(k)).join(' '));
      log('âš ï¸ ä¹‹å¾Œåªèƒ½æ‰“æ‘¸åˆ°çš„ç‰Œ');
    } else {
      log('ğŸ”’ è½ç‰Œå·²é–å®šï¼Œä¹‹å¾Œåªèƒ½æ‰“æ‘¸åˆ°çš„ç‰Œ');
    }
    return;
  }
  
  // å¦‚æœå·²ç¶“é–å®šè½ç‰Œï¼ˆå ±è¯å¾Œçš„å›åˆï¼‰
  if (me.declaredListen && me.tingLocked) {
    // å¦‚æœå‰›æ‘¸åˆ°ç‰Œï¼Œåªèƒ½æ‰“æ‘¸åˆ°çš„ç‰Œ
    if (me.drawnTile) {
      const selected = me.hand[idx];
      if (selected !== me.drawnTile) {
        log('âš ï¸ å·²é–å®šè½ç‰Œï¼Œåªèƒ½æ‰“å‰›æ‘¸çš„ç‰Œ');
        return;
      }
    } else {
      // å¦‚æœæ²’æœ‰æ‘¸åˆ°çš„ç‰Œï¼ˆä¸æ‡‰è©²ç™¼ç”Ÿï¼‰ï¼Œæª¢æŸ¥æ˜¯å¦èƒ½ä¿æŒè½ç‰Œ
      const selectedTile = me.hand[idx];
      const afterDiscard = me.hand.filter(t => t !== selectedTile);
      if (!isListening(afterDiscard, me.melds)) {
        log('âš ï¸ å·²é–å®šè½ç‰Œï¼Œåªèƒ½æ‰“èƒ½ä¿æŒè½ç‰Œçš„ç‰Œ');
        return;
      }
    }
  }
  
  const tile = me.hand[idx];
  discard(myPSeat, tile);
}

/* ========= å•Ÿå‹•éŠæˆ² ========= */
// åˆå§‹åŒ–èªéŸ³ç³»çµ±
initSpeech();

// ç­‰å¾…èªéŸ³åˆ—è¡¨è¼‰å…¥
if ('speechSynthesis' in window) {
  speechSynthesis.onvoiceschanged = () => {
    // èªéŸ³åˆ—è¡¨å·²è¼‰å…¥
  };
}

// é¡¯ç¤ºè¨­å®šç•Œé¢
function showSettings() {
  const overlay = document.getElementById('modalOverlay');
  const content = document.getElementById('modalContent');
  
  let html = '<div class="modal-title">âš™ï¸ éŠæˆ²è¨­å®š</div>';
  html += '<div style="display: flex; flex-direction: column; gap: 16px;">';
  
  // åº•å°è¨­å®š
  html += '<div class="modal-section">';
  html += '<label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary);">åº•å°ï¼ˆåŸºæœ¬åˆ†æ•¸ï¼‰</label>';
  html += `<input type="number" id="settingBasePoints" value="${GAME_SETTINGS.basePoints}" min="100" max="10000" step="100" style="width: 100%; padding: 10px; border: 2px solid var(--border-subtle); border-radius: 8px; font-size: 16px;">`;
  html += '</div>';
  
  // æ¯å°è¨­å®š
  html += '<div class="modal-section">';
  html += '<label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary);">æ¯å°åˆ†æ•¸</label>';
  html += `<input type="number" id="settingPerFanPoints" value="${GAME_SETTINGS.perFanPoints}" min="100" max="10000" step="100" style="width: 100%; padding: 10px; border: 2px solid var(--border-subtle); border-radius: 8px; font-size: 16px;">`;
  html += '</div>';
  
  // åˆå§‹è³‡é‡‘è¨­å®š
  html += '<div class="modal-section">';
  html += '<label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary);">åˆå§‹è³‡é‡‘</label>';
  html += `<input type="number" id="settingInitialPoints" value="${GAME_SETTINGS.initialPoints}" min="10000" max="1000000" step="10000" style="width: 100%; padding: 10px; border: 2px solid var(--border-subtle); border-radius: 8px; font-size: 16px;">`;
  html += '</div>';
  
  // ç©å®¶åå­—è¨­å®š
  html += '<div class="modal-section">';
  html += '<label style="display: block; margin-bottom: 8px; font-weight: 700; color: var(--text-primary);">ç©å®¶åå­—ï¼ˆç•™ç©ºä½¿ç”¨éš¨æ©Ÿåå­—ï¼Œæ¯è¡Œä¸€å€‹ï¼Œè‡³å°‘4å€‹ï¼‰</label>';
  const namesText = GAME_SETTINGS.playerNames ? GAME_SETTINGS.playerNames.join('\n') : '';
  html += `<textarea id="settingPlayerNames" rows="4" placeholder="ä¾‹å¦‚ï¼š\nå‘¨æ°å€«\nè”¡ä¾æ—\næ—å¿—ç©\nç‹åŠ›å®" style="width: 100%; padding: 10px; border: 2px solid var(--border-subtle); border-radius: 8px; font-size: 14px; resize: vertical;">${namesText}</textarea>`;
  html += '</div>';
  
  html += '<div style="display: flex; gap: 12px; margin-top: 8px;">';
  html += '<button class="btn btn-primary" id="saveSettings" style="flex: 1; padding: 12px;">ğŸ’¾ å„²å­˜</button>';
  html += '<button class="btn btn-secondary" id="cancelSettings" style="flex: 1; padding: 12px;">å–æ¶ˆ</button>';
  html += '</div>';
  html += '</div>';
  
  content.innerHTML = html;
  overlay.classList.add('show');
  
  document.getElementById('saveSettings').onclick = () => {
    const basePoints = parseInt(document.getElementById('settingBasePoints').value) || 2000;
    const perFanPoints = parseInt(document.getElementById('settingPerFanPoints').value) || 1000;
    const initialPoints = parseInt(document.getElementById('settingInitialPoints').value) || 100000;
    const namesText = document.getElementById('settingPlayerNames').value.trim();
    
    GAME_SETTINGS.basePoints = basePoints;
    GAME_SETTINGS.perFanPoints = perFanPoints;
    GAME_SETTINGS.initialPoints = initialPoints;
    
    if (namesText) {
      const names = namesText.split('\n').filter(n => n.trim()).map(n => n.trim());
      if (names.length >= 4) {
        GAME_SETTINGS.playerNames = names;
      } else {
        alert('ç©å®¶åå­—è‡³å°‘éœ€è¦4å€‹ï¼');
        return;
      }
    } else {
      GAME_SETTINGS.playerNames = null;
    }
    
    overlay.classList.remove('show');
    log('âš™ï¸ éŠæˆ²è¨­å®šå·²æ›´æ–°');
  };
  
  document.getElementById('cancelSettings').onclick = () => {
    overlay.classList.remove('show');
  };
}

// å­˜æª”æŒ‰éˆ•
document.getElementById('saveBtn').onclick = () => {
  initAudio();
  saveGame();
};

// è®€æª”æŒ‰éˆ•
document.getElementById('loadBtn').onclick = () => {
  initAudio();
  if (confirm('ç¢ºå®šè¦è®€å–ä¿å­˜çš„éŠæˆ²å—ï¼Ÿç•¶å‰éŠæˆ²é€²åº¦å°‡è¢«è¦†è“‹ã€‚')) {
    loadGame();
  }
};

document.getElementById('settingsBtn').onclick = () => {
  initAudio();
  showSettings();
};

// ========= æ¨¡å¼é¸æ“‡åŠŸèƒ½ =========
let gameMode = null; // 'single' æˆ– 'online'

function startSinglePlayerMode() {
  gameMode = 'single';
  const modePanel = document.getElementById('modeSelectPanel');
  if (modePanel) {
    modePanel.classList.remove('show');
    setTimeout(() => {
      modePanel.style.display = 'none';
    }, 300);
  }
  initAudio();
  startNewHand(true);
}

function startOnlineMode() {
  gameMode = 'online';
  const modePanel = document.getElementById('modeSelectPanel');
  if (modePanel) {
    modePanel.classList.remove('show');
    setTimeout(() => {
      modePanel.style.display = 'none';
    }, 300);
  }
  initAudio();
  // æ˜¾ç¤ºè¿çº¿é¢æ¿ï¼ˆä½¿ç”¨ show ç±»ï¼Œè€Œä¸æ˜¯ inline styleï¼‰
  const onlinePanel = document.getElementById('onlinePanel');
  if (onlinePanel) {
    onlinePanel.style.display = '';  // æ¸…é™¤ inline style
    onlinePanel.classList.add('show');  // ä½¿ç”¨ show ç±»æ¥æ˜¾ç¤º
    onlinePanel.hidden = false;
    if (!socket || !socket.connected) {
      initOnline();
    }
  }
}

// ========= é€£ç·šæ¨¡å¼åŠŸèƒ½ =========
let socket = null;
let currentRoomId = null;
let mySeat = -1;
let isOnlineMode = false;
let isHost = false;  // æ˜¯å¦æ˜¯æˆ¿ä¸»ï¼ˆåªæœ‰æˆ¿ä¸»æ§åˆ¶AIï¼‰
let onlinePlayers = [];
let isProcessingStep = false; // é˜²æ­¢ stepNext é‡å¤è°ƒç”¨
let gameInitialized = false;  // æ¸¸æˆæ˜¯å¦å·²åˆå§‹åŒ–
let readyPlayers = new Set(); // è¿çº¿æ¨¡å¼ä¸‹ï¼Œå·²å‡†å¤‡å¥½ç»§ç»­ä¸‹ä¸€å±€çš„ç©å®¶
let continueModalTimeout = null; // 3ç§’è‡ªåŠ¨å…³é—­çš„å®šæ—¶å™¨

// å…³é—­è¿çº¿é¢æ¿çš„å¯é å‡½æ•°
function closeOnlinePanel() {
  const onlinePanel = document.getElementById('onlinePanel');
  if (onlinePanel) {
    console.log('å…³é—­è¿çº¿é¢æ¿');
    // ç§»é™¤ show ç±»
    onlinePanel.classList.remove('show');
    // è®¾ç½® hidden å±æ€§
    onlinePanel.hidden = true;
    // æ¸…é™¤æ‰€æœ‰å¯èƒ½çš„ display æ ·å¼
    onlinePanel.style.cssText = 'display: none !important;';
    // å»¶è¿Ÿå†æ¬¡ç¡®è®¤å…³é—­
    setTimeout(() => {
      if (onlinePanel) {
        onlinePanel.classList.remove('show');
        onlinePanel.hidden = true;
        onlinePanel.style.cssText = 'display: none !important;';
      }
    }, 50);
    setTimeout(() => {
      if (onlinePanel) {
        onlinePanel.classList.remove('show');
        onlinePanel.hidden = true;
        onlinePanel.style.cssText = 'display: none !important;';
      }
    }, 200);
  }
}

// åˆå§‹åŒ–é€£ç·š
function initOnline() {
  const serverUrl = document.getElementById('serverUrl')?.value || 'http://localhost:3000';
  
  if (socket) {
    socket.disconnect();
  }
  
  socket = io(serverUrl);
  
  socket.on('connect', () => {
    console.log('å·²é€£æ¥åˆ°æœå‹™å™¨');
    log('âœ… å·²é€£æ¥åˆ°æœå‹™å™¨');
  });
  
  socket.on('disconnect', () => {
    console.log('èˆ‡æœå‹™å™¨æ–·é–‹é€£æ¥');
    log('âŒ èˆ‡æœå‹™å™¨æ–·é–‹é€£æ¥');
  });
  
  socket.on('connect_error', (error) => {
    console.error('é€£æ¥éŒ¯èª¤:', error);
    log('âŒ ç„¡æ³•é€£æ¥åˆ°æœå‹™å™¨ï¼Œè«‹æª¢æŸ¥æœå‹™å™¨åœ°å€');
  });
  
  socket.on('roomCreated', (data) => {
    currentRoomId = data.roomId;
    mySeat = data.seat;
    isHost = data.isHost || true;  // å‰µå»ºæˆ¿é–“çš„äººæ˜¯æˆ¿ä¸»
    log(`ğŸ® æˆ¿é–“å·²å‰µå»º: ${data.roomId}`);
    const roomDisplay = document.getElementById('roomIdDisplay');
    if (roomDisplay) {
      roomDisplay.textContent = `æˆ¿é–“ID: ${data.roomId}`;
    }
    updateRoomUI();
  });
  
  socket.on('roomJoined', (data) => {
    currentRoomId = data.roomId;
    mySeat = data.seat;
    isHost = data.isHost || false;  // åŠ å…¥æˆ¿é–“çš„äººä¸æ˜¯æˆ¿ä¸»
    log(`âœ… å·²åŠ å…¥æˆ¿é–“: ${data.roomId}`);
    updateRoomUI();
  });
  
  socket.on('roomState', (data) => {
    onlinePlayers = data.players;
    // æ›´æ–°æˆ¿ä¸»ç‹€æ…‹
    const myPlayer = data.players.find(p => p.id === socket.id);
    if (myPlayer) {
      isHost = myPlayer.isHost;
    }
    updateRoomPlayers(data.players);
    const startBtn = document.getElementById('startGameBtn');
    if (startBtn) {
      startBtn.style.display = (isHost && data.players.length >= 2 && data.status === 'waiting') ? 'block' : 'none';
    }
    if (data.status === 'playing' && !gameInitialized) {
      // å¦‚æœæ¸¸æˆçŠ¶æ€æ˜¯ playing ä¸”æ¸¸æˆè¿˜æ²¡åˆå§‹åŒ–ï¼Œè¯´æ˜æ¸¸æˆå·²ç»å¼€å§‹äº†
      closeOnlinePanel();
      startOnlineGame(data);
    }
  });
  
  socket.on('gameStarted', (data) => {
    console.log('æ”¶åˆ° gameStarted äº‹ä»¶:', data);
    log('ğŸ® éŠæˆ²é–‹å§‹ï¼');
    
    // æ›´æ–°æˆ¿ä¸»ç‹€æ…‹
    const myPlayer = data.players?.find(p => p.id === socket.id);
    if (myPlayer) {
      isHost = myPlayer.isHost;
    }
    
    // ç¡®ä¿ data.status ä¸º 'playing'ï¼ˆå³ä½¿æœåŠ¡å™¨æ²¡æœ‰å‘é€ï¼‰
    if (!data.status) {
      data.status = 'playing';
    }
    
    // å…³é—­è¿çº¿é¢æ¿
    closeOnlinePanel();
    
    // ç›´æ¥åˆå§‹åŒ–æ¸¸æˆï¼ˆä¸ç»è¿‡ startOnlineGame çš„æ£€æŸ¥é€»è¾‘ï¼‰
    initOnlineGame(data);
  });
  
  socket.on('gameStateSync', (data) => {
    if (isOnlineMode) {
      // ã€é‡è¦ã€‘å¦‚æœæ˜¯æˆ¿ä¸»çš„çŠ¶æ€ï¼Œæ‰€æœ‰ç©å®¶éƒ½åº”è¯¥åŒæ­¥
      // å¦‚æœä¸æ˜¯æˆ¿ä¸»çš„çŠ¶æ€ï¼Œéæˆ¿ä¸»ä¹Ÿåº”è¯¥åŒæ­¥ï¼ˆå› ä¸ºæˆ¿ä¸»ä¼šè½¬å‘ï¼‰
      if (data.isHost || !isHost) {
        // æˆ¿ä¸»çš„çŠ¶æ€ï¼šæ‰€æœ‰ç©å®¶éƒ½åŒæ­¥
        // éæˆ¿ä¸»çš„çŠ¶æ€ï¼šéæˆ¿ä¸»ç©å®¶ä¹ŸåŒæ­¥ï¼ˆæˆ¿ä¸»ä¼šè½¬å‘ï¼‰
        if (data.fromPlayer !== mySeat) {
          console.log('æ”¶åˆ°çŠ¶æ€åŒæ­¥, fromPlayer:', data.fromPlayer, ', isHost:', data.isHost);
          syncGameState(data.gameState, data.fromPlayer);
        }
      }
    }
  });
  
  socket.on('gameReadyNotify', (data) => {
    console.log('æ”¶åˆ° gameReadyNotify äº‹ä»¶');
    if (!isHost && data.gameState) {
      syncGameState(data.gameState, null);
    }
  });
  
  socket.on('actionBroadcast', (data) => {
    if (isOnlineMode) {
      handleRemoteAction(data);
    }
  });
  
  socket.on('playerDisconnected', (data) => {
    log(`âš ï¸ ç©å®¶æ–·ç·š`);
    // å¦‚æœæ–°æˆ¿ä¸»æ˜¯è‡ªå·±ï¼Œæ›´æ–°ç‹€æ…‹
    if (data.newHostId === socket.id) {
      isHost = true;
      log('ğŸ‘‘ ä½ å·²æˆç‚ºæ–°æˆ¿ä¸»');
    }
  });
  
  // å¤„ç†ç©å®¶å‡†å¤‡çŠ¶æ€
  socket.on('playerReady', (data) => {
    console.log('æ”¶åˆ°ç©å®¶å‡†å¤‡çŠ¶æ€:', data);
    if (data.seat !== undefined) {
      readyPlayers.add(data.seat);
      // æ›´æ–°UI
      if (window.updateReadyStatus) {
        window.updateReadyStatus();
      }
      
      // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç©å®¶éƒ½å‡†å¤‡å¥½äº†
      if (isOnlineMode && onlinePlayers && readyPlayers.size >= onlinePlayers.length) {
        if (isHost) {
          // æˆ¿ä¸»è´Ÿè´£å¼€å§‹æ–°å±€
          setTimeout(() => {
            const overlay = document.getElementById('modalOverlay');
            if (overlay && overlay.classList.contains('show')) {
              overlay.classList.remove('show');
              readyPlayers.clear(); // æ¸…ç©ºå‡†å¤‡çŠ¶æ€
              log('â€”â€” é–‹ä¸‹ä¸€å±€ â€”â€”');
              startNewHand();
            }
          }, 500);
        }
      }
    }
  });
  
  // å¤„ç†æ‰€æœ‰ç©å®¶éƒ½å‡†å¤‡å¥½çš„é€šçŸ¥
  socket.on('allPlayersReady', (data) => {
    console.log('æ‰€æœ‰ç©å®¶éƒ½å‡†å¤‡å¥½äº†');
    if (isOnlineMode && !isHost) {
      // éæˆ¿ä¸»æ”¶åˆ°é€šçŸ¥åï¼Œç­‰å¾…æˆ¿ä¸»å¼€å§‹æ–°å±€
      const overlay = document.getElementById('modalOverlay');
      if (overlay && overlay.classList.contains('show')) {
        overlay.classList.remove('show');
        readyPlayers.clear(); // æ¸…ç©ºå‡†å¤‡çŠ¶æ€
        log('â³ ç­‰å¾…æˆ¿ä¸»é–‹å§‹æ–°å±€...');
      }
    }
  });
  
  socket.on('error', (error) => {
    log('âŒ éŒ¯èª¤: ' + error);
  });
}

// å‰µå»ºæˆ¿é–“
function createOnlineRoom() {
  if (!socket || !socket.connected) {
    initOnline();
    setTimeout(() => createOnlineRoom(), 500);
    return;
  }
  
  const playerName = document.getElementById('playerName')?.value || 'ç©å®¶';
  const settings = {
    playerName: playerName,
    basePoints: GAME_SETTINGS.basePoints,
    perFanPoints: GAME_SETTINGS.perFanPoints,
    initialPoints: GAME_SETTINGS.initialPoints
  };
  
  socket.emit('createRoom', settings, (response) => {
    if (response.success) {
      isOnlineMode = true;
      log(`ğŸ® æˆ¿é–“å·²å‰µå»º: ${response.roomId}`);
    } else {
      log('âŒ å‰µå»ºæˆ¿é–“å¤±æ•—');
    }
  });
}

// åŠ å…¥æˆ¿é–“
function joinOnlineRoom() {
  if (!socket || !socket.connected) {
    initOnline();
    setTimeout(() => joinOnlineRoom(), 500);
    return;
  }
  
  const roomId = document.getElementById('roomIdInput')?.value?.toUpperCase().trim();
  const playerName = document.getElementById('playerName')?.value || 'ç©å®¶';
  
  if (!roomId) {
    log('âŒ è«‹è¼¸å…¥æˆ¿é–“ID');
    return;
  }
  
  socket.emit('joinRoom', { roomId, playerName }, (response) => {
    if (response.success) {
      isOnlineMode = true;
      // è®¾ç½® mySeatï¼ˆä»æœåŠ¡å™¨è¿”å›çš„ç©å®¶ä¿¡æ¯ä¸­è·å–ï¼‰
      if (response.player && typeof response.player.seat !== 'undefined') {
        mySeat = response.player.seat;
      }
      log(`âœ… å·²åŠ å…¥æˆ¿é–“: ${roomId}ï¼Œåº§ä½: ${mySeat}`);
    } else {
      log('âŒ ' + (response.error || 'åŠ å…¥æˆ¿é–“å¤±æ•—'));
    }
  });
}

// ç›´æ¥åˆå§‹åŒ–æ¸¸æˆï¼ˆç”¨äº gameStarted äº‹ä»¶ï¼Œè·³è¿‡æ‰€æœ‰æ£€æŸ¥ï¼‰
function initOnlineGame(data) {
  console.log('initOnlineGame è¢«è°ƒç”¨:', data, ', isHost:', isHost);
  
  // ã€é‡è¦ã€‘è®¾ç½®è¿çº¿æ¨¡å¼æ ‡å¿—
  isOnlineMode = true;
  gameMode = 'online';
  gameInitialized = false;  // å…ˆè®¾ä¸ºfalseï¼Œåˆå§‹åŒ–å®Œæˆåè®¾ä¸ºtrue
  
  // ã€é‡è¦ã€‘è¨­ç½® onlinePlayers
  if (data.players && data.players.length > 0) {
    onlinePlayers = data.players;
    console.log('è¨­ç½® onlinePlayers:', onlinePlayers.map(p => ({seat: p.seat, name: p.name})));
  }
  
  // å¼ºåˆ¶å…³é—­è¿çº¿é¢æ¿
  closeOnlinePanel();
  
  // éšè—æ¨¡å¼é€‰æ‹©é¢æ¿ï¼ˆå¦‚æœè¿˜æ˜¾ç¤ºçš„è¯ï¼‰
  const modePanel = document.getElementById('modeSelectPanel');
  if (modePanel) {
    modePanel.classList.remove('show');
    modePanel.style.cssText = 'display: none !important;';
  }
  
  // è®¾ç½®ç©å®¶åå­—ï¼ˆè¿çº¿æ¨¡å¼ï¼‰
  if (data.players && data.players.length > 0) {
    const onlinePlayerNames = data.players.map(p => p.name);
    const totalPlayers = 4;
    
    if (onlinePlayerNames.length < totalPlayers) {
      const needAI = totalPlayers - onlinePlayerNames.length;
      const shuffled = [...NAME_POOL].sort(() => Math.random() - 0.5);
      const aiNames = shuffled.slice(0, needAI);
      const allNames = [...onlinePlayerNames, ...aiNames];
      GAME_SETTINGS.playerNames = allNames;
      if (isHost) {
        log(`ğŸ¤– è‡ªå‹•è£œä½ ${needAI} ä½AIç©å®¶ï¼š${aiNames.join('ã€')}`);
      }
    } else {
      GAME_SETTINGS.playerNames = onlinePlayerNames;
    }
  }
  
  // ç¡®ä¿ mySeat å·²æ­£ç¡®è®¾ç½®
  if (mySeat < 0 || mySeat === undefined) {
    const player = data.players?.find(p => p.id === socket?.id);
    if (player && typeof player.seat !== 'undefined') {
      mySeat = player.seat;
    }
  }
  
  // ç¡®å®šæ˜¯å¦æ˜¯æˆ¿ä¸»
  const playerInfo = data.players?.find(p => p.id === socket?.id);
  isHost = playerInfo?.isHost || false;
  
  console.log('å½“å‰åº§ä½ mySeat:', mySeat, ', isOnlineMode:', isOnlineMode, ', isHost:', isHost);
  
  // æ¸…ç©ºæ—¥å¿—
  document.getElementById('log').innerHTML = '';
  log('ğŸ® é€£ç·šéŠæˆ²é–‹å§‹ï¼');
  log(`ğŸ“ ä½ çš„åº§ä½: ${mySeat}, ${isHost ? 'ğŸ‘‘ æˆ¿ä¸»' : 'ç©å®¶'}`);
  
  if (isHost) {
    // æˆ¿ä¸»ï¼šç”Ÿæˆæ¸¸æˆçŠ¶æ€å¹¶åŒæ­¥ç»™å…¶ä»–ç©å®¶
    console.log('æˆ¿ä¸»ç”Ÿæˆæ¸¸æˆçŠ¶æ€...');
    S = null;
    dealerStreak = 0;
    startNewHand(true);
    gameInitialized = true;
    
    // å»¶è¿ŸåŒæ­¥ï¼Œç¡®ä¿æ¸¸æˆåˆå§‹åŒ–å®Œæˆ
    setTimeout(() => {
      if (S && S.round) {
        console.log('æˆ¿ä¸»åŒæ­¥æ¸¸æˆçŠ¶æ€ç»™å…¶ä»–ç©å®¶...');
        syncGameStateToServer();
        // é€šçŸ¥æœåŠ¡å™¨æ¸¸æˆå·²å‡†å¤‡å¥½
        socket.emit('gameReady', { roomId: currentRoomId });
      }
    }, 500);
  } else {
    // éæˆ¿ä¸»ï¼šç­‰å¾…æˆ¿ä¸»åŒæ­¥æ¸¸æˆçŠ¶æ€
    console.log('éæˆ¿ä¸»ç­‰å¾…æ¸¸æˆçŠ¶æ€åŒæ­¥...');
    log('â³ ç­‰å¾…æˆ¿ä¸»åŒæ­¥éŠæˆ²ç‹€æ…‹...');
    
    // æ˜¾ç¤ºç­‰å¾…ç•Œé¢
    S = null;
    
    // æŒç»­è¯·æ±‚æ¸¸æˆçŠ¶æ€ï¼Œç›´åˆ°æ”¶åˆ°
    let retryCount = 0;
    const maxRetries = 30;  // å¢åŠ é‡è¯•æ¬¡æ•°
    
    function requestGameState() {
      if (gameInitialized && S && S.round) {
        console.log('å·²æ”¶åˆ°æ¸¸æˆçŠ¶æ€');
        return;
      }
      
      retryCount++;
      if (retryCount > maxRetries) {
        console.warn('è¯·æ±‚æ¸¸æˆçŠ¶æ€è¶…æ—¶');
        log('âŒ åŒæ­¥è¶…æ™‚ï¼Œè«‹é‡æ–°åŠ å…¥æˆ¿é–“');
        return;
      }
      
      console.log(`è¯·æ±‚æ¸¸æˆçŠ¶æ€... (å°è¯• ${retryCount}/${maxRetries})`);
      
      if (socket && currentRoomId) {
        socket.emit('getRoomState', currentRoomId, (response) => {
          if (response.success && response.room && response.room.gameState) {
            console.log('æ”¶åˆ°æ¸¸æˆçŠ¶æ€:', response.room.gameState);
            syncGameState(response.room.gameState, null);
            gameInitialized = true;
            renderAll();
            
            // æ£€æŸ¥æ˜¯å¦è½®åˆ°è‡ªå·±
            if (S && S.turn === mySeat && !S.players[mySeat].drawnTile) {
              log('ğŸ‘‰ è¼ªåˆ°ä½ äº†ï¼Œè«‹å‡ºç‰Œ');
            }
          } else {
            // ç»§ç»­é‡è¯•
            setTimeout(requestGameState, 500);
          }
        });
      } else {
        setTimeout(requestGameState, 500);
      }
    }
    
    // å¼€å§‹è¯·æ±‚
    setTimeout(requestGameState, 800);
  }
}

// é–‹å§‹éŠæˆ²ï¼ˆæ‰€æœ‰ç©å®¶éƒ½æœƒæ”¶åˆ° gameStarted äº‹ä»¶ï¼‰
function startOnlineGame(data) {
  if (!data) {
    // å¦‚æœæ˜¯æˆ¿ä¸»æ‰‹åŠ¨ç‚¹å‡»å¼€å§‹æ¸¸æˆæŒ‰é’®ï¼Œå‘é€ startGame äº‹ä»¶
    if (socket && currentRoomId) {
      socket.emit('startGame', currentRoomId);
    }
    return;
  }
  
  // å…³é—­è¿çº¿é¢æ¿
  closeOnlinePanel();
  
  // æ£€æŸ¥æ˜¯å¦æ˜¯æˆ¿ä¸»ï¼Œæˆ–è€…æ¸¸æˆçŠ¶æ€å·²ç»æ˜¯ playing
  const isHost = data.players?.find(p => p.id === socket?.id)?.isHost;
  
  // å¦‚æœæ¸¸æˆçŠ¶æ€æ˜¯ playingï¼Œç›´æ¥åˆå§‹åŒ–æ¸¸æˆ
  if (data.status === 'playing') {
    initOnlineGame(data);
    return;
  }
  
  // å¦‚æœæ˜¯æˆ¿ä¸»ï¼Œç›´æ¥åˆå§‹åŒ–æ¸¸æˆ
  if (isHost) {
    initOnlineGame(data);
    return;
  }
  
  // å…¶ä»–æƒ…å†µï¼Œç­‰å¾…æ¸¸æˆå¼€å§‹ï¼ˆä¸åº”è¯¥æ‰§è¡Œåˆ°è¿™é‡Œï¼Œå› ä¸º gameStarted äº‹ä»¶ä¼šè§¦å‘ initOnlineGameï¼‰
  log('â³ ç­‰å¾…æˆ¿ä¸»é–‹å§‹éŠæˆ²...');
}

// åŒæ­¥éŠæˆ²ç‹€æ…‹åˆ°æœå‹™å™¨
function syncGameStateToServer() {
  if (!socket || !currentRoomId || !isOnlineMode || !S) return;
  
  // æ·±æ‹·è²ç‹€æ…‹
  const fullState = JSON.parse(JSON.stringify(S));
  fullState.seatNames = seatNames ? [...seatNames] : null;
  fullState.dealerStreak = dealerStreak || 0;
  
  // ã€é‡è¦ã€‘ç¢ºä¿å‰©ä½™ç‰Œæ•¸æ­£ç¢ºè¨ˆç®—ï¼ˆåªè¨ˆç®—å¯æ‘¸çš„ç‰Œæ•¸ï¼Œä¸åŒ…æ‹¬ç‹ç‰Œï¼‰
  fullState.remain = fullState.wall.length;
  
  // ã€é‡è¦ã€‘éš±ç§ä¿è­·ï¼šæ¸…é™¤å…¶ä»–ç©å®¶çš„ drawnTile
  // æ¯å€‹å®¢æˆ¶ç«¯åªèƒ½çŸ¥é“è‡ªå·±æ‘¸åˆ°çš„ç‰Œ
  for (let i = 0; i < 4; i++) {
    if (i !== mySeat && fullState.players[i]) {
      fullState.players[i].drawnTile = null;
    }
  }
  
  console.log('åŒæ­¥æ¸¸æˆçŠ¶æ€åˆ°æœåŠ¡å™¨, mySeat:', mySeat, ', turn:', fullState.turn, ', remain:', fullState.remain);
  
  socket.emit('gameStateUpdate', {
    roomId: currentRoomId,
    gameState: fullState
  });
}

// å¾æœå‹™å™¨åŒæ­¥éŠæˆ²ç‹€æ…‹
function syncGameState(gameState, fromPlayerSeat) {
  if (!isOnlineMode) return;
  
  if (!gameState || !gameState.round) {
    console.warn('âš ï¸ syncGameState: æ”¶åˆ°çš„æ¸¸æˆçŠ¶æ€æ— æ•ˆ');
    return;
  }
  
  const myPSeatSync = getMyPlayerSeat();
  
  // å¦‚æœå½“å‰ç©å®¶æœ‰ drawnTileï¼Œä¸”çŠ¶æ€æ¥è‡ªå…¶ä»–ç©å®¶ï¼Œä¿ç•™æœ¬åœ° drawnTile
  let preserveDrawnTile = null;
  if (S && S.players && S.players[myPSeatSync] && S.players[myPSeatSync].drawnTile) {
    // å¦‚æœçŠ¶æ€æ¥è‡ªå…¶ä»–ç©å®¶ï¼ˆæˆ–æœªçŸ¥ï¼‰ï¼Œä¸”å½“å‰ç©å®¶æœ‰ drawnTileï¼Œä¿ç•™å®ƒ
    if (fromPlayerSeat === null || fromPlayerSeat === undefined || fromPlayerSeat !== myPSeatSync) {
      preserveDrawnTile = S.players[myPSeatSync].drawnTile;
      console.log('âš ï¸ syncGameState: å½“å‰ç©å®¶æœ‰ drawnTileï¼Œä¿ç•™æœ¬åœ°çŠ¶æ€:', tileKey(preserveDrawnTile), ', fromPlayer:', fromPlayerSeat);
    }
  }
  
  console.log('åŒæ­¥æ¸¸æˆçŠ¶æ€:', gameState, ', fromPlayer:', fromPlayerSeat);
  console.log('åŒæ­¥å‰ - wallé•¿åº¦:', S?.wall?.length, ', deadWallé•¿åº¦:', S?.deadWall?.length, ', remain:', S?.remain);
  console.log('åŒæ­¥å - wallé•¿åº¦:', gameState?.wall?.length, ', deadWallé•¿åº¦:', gameState?.deadWall?.length, ', remain:', gameState?.remain);
  
  // æ·±æ‹·è´æ¸¸æˆçŠ¶æ€
  try {
    S = JSON.parse(JSON.stringify(gameState));
    
    // ã€é‡è¦ã€‘å¼ºåˆ¶ä½¿ç”¨æ­£ç¡®çš„å‰©ä½™ç‰Œæ•°è®¡ç®—ï¼ˆåªè®¡ç®—å¯æ‘¸çš„ç‰Œæ•°ï¼Œä¸åŒ…æ‹¬ç‹ç‰Œï¼‰
    // è¿™å¯ä»¥é˜²æ­¢ä¸åŒå®¢æˆ·ç«¯ç‰Œå¢™çŠ¶æ€ä¸ä¸€è‡´çš„é—®é¢˜
    S.remain = S.wall.length;
    if (isOnlineMode) {
      console.log('ä½¿ç”¨æœåŠ¡å™¨ç«¯ç‰Œå¢™çŠ¶æ€ - wall:', S.wall.length, ', deadWall:', S.deadWall.length, ', remain:', S.remain);
    }
    
    // ã€é‡è¦ã€‘åœ¨è¿çº¿æ¨¡å¼ä¸‹ï¼Œæ¸…é™¤å…¶ä»–ç©å®¶çš„ drawnTileï¼ˆéšç§ä¿æŠ¤ï¼‰
    // åªä¿ç•™å½“å‰ç©å®¶çš„ drawnTileï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
    for (let i = 0; i < 4; i++) {
      if (i !== myPSeatSync && S.players[i]) {
        // æ¸…é™¤å…¶ä»–ç©å®¶çš„ drawnTile
        if (S.players[i].drawnTile) {
          console.log('æ¸…é™¤å…¶ä»–ç©å®¶çš„ drawnTile:', i);
          S.players[i].drawnTile = null;
        }
      }
    }
    
    // å¦‚æœä¿ç•™äº† drawnTileï¼Œæ¢å¤å®ƒ
    if (preserveDrawnTile && S.players[myPSeatSync]) {
      const drawnKey = tileKey(preserveDrawnTile);
      // åœ¨æ‰‹ç‰Œä¸­æ‰¾åˆ°å¯¹åº”çš„ç‰Œï¼ˆä½¿ç”¨ tileKey åŒ¹é…ï¼Œå› ä¸ºå¯¹è±¡å¼•ç”¨å¯èƒ½ä¸åŒï¼‰
      const tileInHand = S.players[myPSeatSync].hand.find(t => tileKey(t) === drawnKey);
      if (tileInHand) {
        // ä½¿ç”¨æ‰‹ç‰Œä¸­çš„å®é™…å¯¹è±¡å¼•ç”¨
        S.players[myPSeatSync].drawnTile = tileInHand;
        console.log('æ¢å¤ drawnTile:', drawnKey);
      } else {
        // å¦‚æœæ‰‹ç‰Œä¸­æ²¡æœ‰ï¼ˆä¸åº”è¯¥å‘ç”Ÿï¼‰ï¼Œä½¿ç”¨ä¿ç•™çš„å¯¹è±¡
        S.players[myPSeatSync].drawnTile = preserveDrawnTile;
        S.players[myPSeatSync].hand.push(preserveDrawnTile);
        console.log('æ¢å¤ drawnTileï¼ˆæ·»åŠ åˆ°æ‰‹ç‰Œï¼‰:', drawnKey);
      }
    }
    
    // åŒæ­¥å…¶ä»–å…¨å±€å˜é‡
    if (gameState.dealerStreak !== undefined) {
      dealerStreak = gameState.dealerStreak;
    }
    
    // åŒæ­¥åº§ä½åç§°
    if (gameState.seatNames) {
      seatNames = [...gameState.seatNames];
    }
    
    console.log('æ¸¸æˆçŠ¶æ€åŒæ­¥å®Œæˆ, å½“å‰å›åˆ:', S.turn, ', èŠå®¶:', S.dealer, ', mySeat:', myPSeatSync);
    
    // å¼ºåˆ¶é‡æ–°æ¸²æŸ“
    renderAll();
    
    // æ£€æŸ¥æ˜¯å¦è½®åˆ°å½“å‰ç©å®¶çš„å›åˆ
    const myPlayer = S.players[myPSeatSync];
    
    console.log('syncGameState æ£€æŸ¥å›åˆ: turn=', S.turn, ', mySeat=', myPSeatSync, ', drawnTile=', myPlayer.drawnTile ? 'yes' : 'no', ', waitReact=', S.waitReact, ', lastAction=', S.lastAction, ', phase=', S.phase);
    
    // å¦‚æœè½®åˆ°å½“å‰ç©å®¶çš„å›åˆ
    if (S.turn === myPSeatSync && S.phase !== 'end' && !isProcessingStep) {
      // æª¢æŸ¥æ˜¯å¦éœ€è¦æ‘¸ç‰Œï¼ˆæ²’æœ‰ drawnTile ä¸”ä¸æ˜¯ç­‰å¾…åæ‡‰ï¼‰
      if (!myPlayer.drawnTile && !S.waitReact) {
        // èŠå®¶ç¬¬ä¸€æ¬¡å‡ºç‰Œä¸éœ€è¦æ‘¸ç‰Œï¼ˆæ‰‹ç‰Œå·²ç¶“æœ‰17å¼µï¼‰
        const isFirstDealerTurn = S.dealer === myPSeatSync && myPlayer.drawCount === 0 && myPlayer.hand.length === 17;
        
        if (isFirstDealerTurn) {
          console.log('èŠå®¶ç¬¬ä¸€æ¬¡å‡ºç‰Œï¼Œä¸éœ€è¦æ‘¸ç‰Œ');
          log('ğŸ‘‰ è¼ªåˆ°ä½ äº†ï¼Œè«‹å‡ºç‰Œ');
        } else {
          console.log('è½®åˆ°å½“å‰ç©å®¶å›åˆï¼Œè§¦å‘ stepNext');
          setTimeout(stepNext, 300);
        }
      } else if (myPlayer.drawnTile) {
        // å·²ç¶“æ‘¸ç‰Œäº†ï¼Œç­‰å¾…ç©å®¶å‡ºç‰Œ
        console.log('å·²æœ‰ drawnTileï¼Œç­‰å¾…å‡ºç‰Œ');
        log('ğŸ‘‰ è¼ªåˆ°ä½ äº†ï¼Œè«‹å‡ºç‰Œ');
      }
    } else if (S.waitReact && S.waitReact.length > 0) {
      // æœ‰åæ‡‰å¯é¸
      const myReactions = S.waitReact.filter(r => r.pid === myPSeatSync);
      if (myReactions.length > 0) {
        // å½“å‰ç©å®¶æœ‰ååº”
        console.log('æœ‰åæ‡‰å¯é¸');
        showReactionPanel(myReactions);
      } else if (isOnlineMode && isHost) {
        // å½“å‰ç©å®¶æ²¡æœ‰ååº”ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰AIç©å®¶å¯ä»¥ååº”
        if (!onlinePlayers || onlinePlayers.length === 0) {
          console.error('âŒ syncGameState: onlinePlayers æœªå®šç¾©æˆ–ç‚ºç©ºï¼');
          return;
        }
        // æ£€æŸ¥æ˜¯å¦æœ‰AIç©å®¶å¯ä»¥ååº”
        const aiReactions = S.waitReact.filter(r => {
          const isRealPlayer = onlinePlayers.some(p => p.seat === r.pid);
          return !isRealPlayer;
        });
        if (aiReactions.length > 0) {
          // æœ‰AIç©å®¶å¯ä»¥ååº”ï¼Œæˆ¿ä¸»å¤„ç†
          console.log('syncGameState: æœ‰AIç©å®¶å¯ä»¥ååº”ï¼Œè°ƒç”¨ handleAIReaction');
          setTimeout(() => handleAIReaction(S.waitReact), 1000 + Math.random() * 1000);
        } else {
          // åªæœ‰çœŸäººç©å®¶å¯ä»¥ååº”ï¼Œç­‰å¾…ä»–ä»¬æ“ä½œ
          console.log('syncGameState: åªæœ‰çœŸäººç©å®¶å¯ä»¥ååº”ï¼Œç­‰å¾…ä»–ä»¬æ“ä½œ');
        }
      }
    } else if (isProcessingStep) {
      console.log('âš ï¸ syncGameState: stepNext æ­£åœ¨å¤„ç†ä¸­ï¼Œè·³è¿‡è§¦å‘');
    } else if (S.turn !== myPSeatSync && S.phase !== 'end' && isOnlineMode && isHost) {
      // ä¸æ˜¯å½“å‰ç©å®¶çš„å›åˆï¼Œä½†æ˜¯è¿çº¿æ¨¡å¼ä¸”æ˜¯æˆ¿ä¸»ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯AIç©å®¶
      if (!onlinePlayers || onlinePlayers.length === 0) {
        console.error('âŒ syncGameState: onlinePlayers æœªå®šç¾©æˆ–ç‚ºç©ºï¼');
        return;
      }
      const isRealPlayer = onlinePlayers.some(p => p.seat === S.turn);
      if (!isRealPlayer) {
        // AIç©å®¶ï¼Œæˆ¿ä¸»æ§åˆ¶
        console.log('syncGameState: è½®åˆ°AIç©å®¶', S.turn, 'ï¼Œæˆ¿ä¸»æ§åˆ¶ï¼Œè°ƒç”¨ stepNext');
        setTimeout(stepNext, 300);
      } else {
        // çœŸäººç©å®¶ï¼Œç­‰å¾…ä»–ä»¬è‡ªå·±æ“ä½œ
        console.log('syncGameState: è½®åˆ°çœŸäººç©å®¶', S.turn, 'ï¼Œç­‰å¾…ä»–ä»¬è‡ªå·±æ“ä½œ');
      }
    }
  } catch (e) {
    console.error('syncGameState é”™è¯¯:', e);
  }
}

// ç™¼é€ç©å®¶æ“ä½œ
function sendPlayerAction(action, params) {
  if (!socket || !currentRoomId || !isOnlineMode) return;
  
  socket.emit('playerAction', {
    roomId: currentRoomId,
    action: action,
    params: params
  });
}

// è™•ç†é ç¨‹ç©å®¶æ“ä½œ
function handleRemoteAction(data) {
  const { action, params, playerSeat } = data;
  
  if (playerSeat === mySeat) return;
  
  // ç¡®ä¿æ¸¸æˆçŠ¶æ€å·²åˆå§‹åŒ–
  if (!S || !S.round) {
    console.warn('âš ï¸ handleRemoteAction: æ¸¸æˆçŠ¶æ€æœªåˆå§‹åŒ–ï¼Œè¯·æ±‚åŒæ­¥');
    // è¯·æ±‚åŒæ­¥æ¸¸æˆçŠ¶æ€
    if (socket && currentRoomId) {
      socket.emit('getRoomState', currentRoomId, (response) => {
        if (response.success && response.room && response.room.gameState) {
          syncGameState(response.room.gameState, null);
          // åŒæ­¥åé‡æ–°å¤„ç†æ“ä½œ
          setTimeout(() => {
            handleRemoteAction(data);
          }, 100);
        }
      });
    }
    return;
  }
  
  switch (action) {
    case 'discard':
      handleRemoteDiscard(playerSeat, params.tile);
      break;
    case 'pong':
      handleRemotePong(playerSeat, params.tile);
      break;
    case 'kong':
      handleRemoteKong(playerSeat, params.tile);
      break;
    case 'chow':
      handleRemoteChow(playerSeat, params.tile, params.pattern);
      break;
    case 'win':
      handleRemoteWin(playerSeat, params);
      break;
    case 'listen':
      handleRemoteListen(playerSeat);
      break;
    case 'draw':
      handleRemoteDraw(playerSeat);
      break;
  }
  
  // ã€é‡è¦ã€‘å»¶è¿Ÿè¯·æ±‚çŠ¶æ€åŒæ­¥ï¼Œç¡®ä¿æˆ˜å†µå³æ—¶æ›´æ–°
  // æ‰€æœ‰ç©å®¶ï¼ˆåŒ…æ‹¬æˆ¿ä¸»ï¼‰éƒ½åº”è¯¥è¯·æ±‚æˆ¿ä¸»çš„çŠ¶æ€ï¼Œå› ä¸ºæˆ¿ä¸»çš„çŠ¶æ€æ˜¯æœ€æƒå¨çš„
  // æˆ¿ä¸»çš„çŠ¶æ€åŒ…å«äº†æ‰€æœ‰ç©å®¶çš„æœ€æ–°æˆ˜å†µï¼ˆåˆ†æ•°ã€æ‰‹ç‰Œæ•°ã€å‰©ä½™ç‰Œæ•°ç­‰ï¼‰
  if (socket && currentRoomId) {
    setTimeout(() => {
      socket.emit('getRoomState', currentRoomId, (response) => {
        if (response.success && response.room && response.room.gameState) {
          if (isHost) {
            console.log('handleRemoteAction: æˆ¿ä¸»è¯·æ±‚çŠ¶æ€åŒæ­¥ï¼Œç¡®ä¿æˆ˜å†µå³æ—¶æ›´æ–°, action:', action);
          } else {
            console.log('handleRemoteAction: éæˆ¿ä¸»è¯·æ±‚æˆ¿ä¸»çŠ¶æ€åŒæ­¥ï¼Œç¡®ä¿æˆ˜å†µå³æ—¶æ›´æ–°, action:', action);
          }
          // ä»æˆ¿ä¸»åŒæ­¥çŠ¶æ€ï¼ˆæˆ¿ä¸»çš„çŠ¶æ€æ˜¯æœ€æƒå¨çš„ï¼‰
          syncGameState(response.room.gameState, playerSeat);
        }
      });
    }, 300); // å»¶è¿Ÿ300msï¼Œç­‰å¾…æ“ä½œç©å®¶åŒæ­¥çŠ¶æ€åˆ°æœåŠ¡å™¨
  }
}

// è™•ç†é ç¨‹å‡ºç‰Œ
function handleRemoteDiscard(playerSeat, tileKeyStr) {
  console.log('handleRemoteDiscard:', playerSeat, tileKeyStr);
  
  if (!S || !S.round || !S.players[playerSeat]) {
    console.warn('âš ï¸ handleRemoteDiscard: æ¸¸æˆçŠ¶æ€æœªåˆå§‹åŒ–ï¼Œç­‰å¾…åŒæ­¥');
    return;
  }
  
  // æ’­æ”¾å‡ºç‰ŒéŸ³æ•ˆå’ŒèªéŸ³ï¼ˆä¸ä¾è³´ç‹€æ…‹åŒæ­¥ï¼‰
  SoundEffects.discard();
  const tileText = keyToText(tileKeyStr);
  const speechText = tileNameForSpeech(tileText);
  speakText(speechText, { rate: 1.0, pitch: 1.0, volume: 0.8 });
  
  // é¡¯ç¤ºå‡ºç‰Œ log
  log(`ğŸ´ ${playerName(playerSeat)} æ‰“å‡º ${tileText}`);
  
  // å¯¦éš›çš„ç‹€æ…‹æ›´æ–°ç”± syncGameState è™•ç†
  // é€™è£¡åªè² è²¬é¡¯ç¤ºå’ŒéŸ³æ•ˆ
}

// è™•ç†é ç¨‹ç¢°
function handleRemotePong(playerSeat, tileKey) {
  const tileObj = keyToTileFromKey(tileKey);
  doPong(playerSeat, tileObj);
}

// è™•ç†é ç¨‹æ§“
function handleRemoteKong(playerSeat, tileKey) {
  const tileObj = keyToTileFromKey(tileKey);
  doKong(playerSeat, tileObj);
}

// è™•ç†é ç¨‹åƒ
function handleRemoteChow(playerSeat, tileKey, pattern) {
  const tileObj = keyToTileFromKey(tileKey);
  doChow(playerSeat, tileObj, pattern);
}

// è™•ç†é ç¨‹èƒ¡ç‰Œ
function handleRemoteWin(playerSeat, params) {
  const tileObj = keyToTileFromKey(params.tile);
  doWin(playerSeat, params.from, tileObj, params.selfDraw);
}

// è™•ç†é ç¨‹å ±è½
function handleRemoteListen(playerSeat) {
  if (!S || !S.round || !S.players[playerSeat]) {
    console.warn('âš ï¸ handleRemoteListen: æ¸¸æˆçŠ¶æ€æœªåˆå§‹åŒ–ï¼Œç­‰å¾…åŒæ­¥');
    return;
  }
  S.players[playerSeat].declaredListen = true;
  updateTianDiTing(playerSeat);
  log(`ğŸ”” ${playerName(playerSeat)} å ±è½`);
  renderAll();
}

// è™•ç†é ç¨‹æ‘¸ç‰Œ
function handleRemoteDraw(playerSeat) {
  // è¿œç¨‹ç©å®¶æ‘¸ç‰Œæ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦çŸ¥é“ä»–æ‘¸ç‰Œäº†
  // å…·ä½“çš„ç‰Œæ˜¯ä»€ä¹ˆæ˜¯éšç§çš„ï¼Œä¸æ˜¾ç¤º
  // çŠ¶æ€ä¼šåœ¨ç©å®¶å‡ºç‰Œåé€šè¿‡ syncGameState æ›´æ–°
  console.log('é ç¨‹ç©å®¶æ‘¸ç‰Œ:', playerSeat);
  
  // ä¸éœ€è¦åšä»»ä½•äº‹æƒ…ï¼ŒçŠ¶æ€åŒæ­¥ä¼šå¤„ç†ä¸€åˆ‡
  // å¦‚æœéœ€è¦æ˜¾ç¤ºæ‘¸ç‰ŒåŠ¨ç”»ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ 
}

// æ›´æ–°æˆ¿é–“ç©å®¶åˆ—è¡¨
function updateRoomPlayers(players) {
  const playerList = document.getElementById('roomPlayers');
  if (playerList) {
    if (players.length === 0) {
      playerList.innerHTML = '<div style="text-align: center; color: var(--text-secondary);">ç­‰å¾…ç©å®¶åŠ å…¥...</div>';
    } else {
      playerList.innerHTML = players.map((p, idx) => {
        const isMe = p.id === socket.id;
        return `<div style="padding: 8px; margin: 4px 0; background: ${isMe ? 'rgba(16,185,129,0.2)' : 'rgba(241,245,249,0.5)'}; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
          <span>åº§ä½${idx + 1}: ${p.name} ${p.isHost ? 'ğŸ‘‘' : ''} ${isMe ? '(ä½ )' : ''}</span>
        </div>`;
      }).join('');
    }
  }
}

// æ›´æ–°æˆ¿é–“UI
function updateRoomUI() {
  // UIæ›´æ–°å·²åœ¨updateRoomPlayersä¸­å¤„ç†
}

// é€€å‡ºé€£ç·šæ¨¡å¼
function exitOnlineMode() {
  if (socket) {
    if (currentRoomId) {
      socket.emit('leaveRoom', currentRoomId);
    }
    socket.disconnect();
    socket = null;
  }
  
  isOnlineMode = false;
  currentRoomId = null;
  mySeat = -1;
  isHost = false;
  gameInitialized = false;
  onlinePlayers = [];
  
  const onlinePanel = document.getElementById('onlinePanel');
  if (onlinePanel) {
    onlinePanel.style.display = 'none';
  }
  
  log('å·²é€€å‡ºé€£ç·šæ¨¡å¼');
}

// é€£ç·šæŒ‰éˆ•é»æ“Š
document.getElementById('onlineBtn').onclick = () => {
  initAudio();
  const onlinePanel = document.getElementById('onlinePanel');
  if (onlinePanel) {
    onlinePanel.style.display = 'flex';
    if (!socket || !socket.connected) {
      initOnline();
    }
  }
};

// è¼”åŠ©å‡½æ•¸ï¼šå¾keyé‡å»ºtileå°è±¡
function keyToTileFromKey(k) {
  if (typeof k === 'string') {
    const s = k[0], v = k.slice(1);
    if (s === 'W' || s === 'T' || s === 'B') {
      return { suit: s, rank: parseInt(v), id: -1 };
    }
    if (s === 'F') {
      return { suit: SUIT_F, name: v, id: -1 };
    }
    if (s === 'D') {
      return { suit: SUIT_D, name: v, id: -1 };
    }
  }
  return k;
}

// ä¿®æ”¹éŠæˆ²æ“ä½œå‡½æ•¸ä»¥æ”¯æŒé€£ç·šï¼ˆåœ¨å‡½æ•¸å®šç¾©å¾ŒåŒ…è£ï¼‰
// æ³¨æ„ï¼šé€™äº›ä¿®æ”¹éœ€è¦åœ¨å‡½æ•¸å®šç¾©ä¹‹å¾Œé€²è¡Œ

// é¡µé¢åŠ è½½æ—¶ä¸è‡ªåŠ¨å¯åŠ¨æ¸¸æˆï¼Œç­‰å¾…ç”¨æˆ·é€‰æ‹©æ¨¡å¼
// startNewHand(true); // å·²ç§»é™¤ï¼Œæ”¹ä¸ºæ¨¡å¼é€‰æ‹©ç•Œé¢
</script>
</body>
</html>
