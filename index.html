<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>å¤§ç‘ç§‘æŠ€ - éº»å°‡å–®æ©Ÿ</title>
<style>
* {
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
}

body {
  font-family: system-ui, -apple-system, "Noto Sans TC", "Microsoft JhengHei", sans-serif;
  background: linear-gradient(135deg, #001a3d 0%, #003D7A 100%);
  color: #ffffff;
  margin: 0;
  padding: 0;
  min-height: 100vh;
  overflow-x: hidden;
}

header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  background: linear-gradient(180deg, #003D7A 0%, #002855 100%);
  border-bottom: 3px solid #0066CC;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  position: sticky;
  top: 0;
  z-index: 100;
  flex-wrap: wrap;
  gap: 8px;
}

.row {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
}

.pill {
  background: linear-gradient(135deg, #003D7A 0%, #002855 100%);
  border: 2px solid #0066CC;
  border-radius: 999px;
  padding: 6px 12px;
  font-size: 13px;
  white-space: nowrap;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

button {
  cursor: pointer;
  background: linear-gradient(135deg, #0066CC 0%, #003D7A 100%);
  border: 2px solid #0088FF;
  color: #ffffff;
  border-radius: 8px;
  padding: 10px 16px;
  font-size: 14px;
  font-weight: 600;
  transition: all 0.2s ease;
  box-shadow: 0 3px 8px rgba(0,0,0,0.3);
}

button:hover:not(:disabled) {
  background: linear-gradient(135deg, #0088FF 0%, #0066CC 100%);
  transform: translateY(-1px);
  box-shadow: 0 5px 12px rgba(0,102,204,0.5);
}

button:active:not(:disabled) {
  transform: translateY(0);
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

  button:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }
  
  /* æŒ‰éˆ•äº®ç‡ˆæ•ˆæœ */
  button.active {
    background: linear-gradient(135deg, #FFC107 0%, #FFD54F 100%);
    color: #003D7A;
    font-weight: bold;
    box-shadow: 0 0 20px rgba(255, 193, 7, 0.8), 0 0 40px rgba(255, 193, 7, 0.4);
    animation: pulse 1.5s ease-in-out infinite;
    transform: scale(1.05);
  }
  
  @keyframes pulse {
    0%, 100% { box-shadow: 0 0 20px rgba(255, 193, 7, 0.8), 0 0 40px rgba(255, 193, 7, 0.4); }
    50% { box-shadow: 0 0 30px rgba(255, 193, 7, 1), 0 0 60px rgba(255, 193, 7, 0.6); }
  }

#newGameBtn {
  background: linear-gradient(135deg, #8BC34A 0%, #689F38 100%);
  border-color: #9CCC65;
  color: #ffffff;
  font-weight: 700;
}

#newGameBtn:hover {
  background: linear-gradient(135deg, #9CCC65 0%, #7CB342 100%);
}

#table {
  max-width: 1200px;
  margin: 16px auto;
  padding: 0 12px;
}

.score {
  background: linear-gradient(135deg, #002855 0%, #001a3d 100%);
  border: 2px solid #0066CC;
  border-radius: 12px;
  padding: 14px;
  margin-bottom: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

.score h3 {
  margin: 0 0 8px 0;
  font-size: 16px;
  color: #8BC34A;
  font-weight: 700;
}

.hand {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  margin-top: 8px;
  justify-content: center;
}

.tile {
  cursor: pointer;
  border: 2px solid #4a6d8c;
  background: linear-gradient(180deg, #ffffff 0%, #f0f8ff 100%);
  color: #1a2634;
  border-radius: 6px;
  padding: 6px 4px;
  min-width: 36px;
  width: 36px;
  height: 48px;
  text-align: center;
  font-weight: 700;
  font-size: 15px;
  line-height: 1;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2), inset 0 1px 2px rgba(255,255,255,0.5);
  position: relative;
  user-select: none;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.tile:hover {
  transform: translateY(-4px);
  box-shadow: 0 6px 12px rgba(0,0,0,0.4), inset 0 1px 2px rgba(255,255,255,0.7);
  border-color: #6a8dac;
}

.tile:active {
  transform: translateY(-2px);
}

.tile.gold {
  background: linear-gradient(180deg, #ffd700 0%, #ffed4e 100%);
  border-color: #d4af37;
  box-shadow: 0 3px 8px rgba(255, 215, 0, 0.4), inset 0 1px 2px rgba(255,255,255,0.6);
  /* åœæ­¢é–ƒçˆå‹•ç•«ï¼Œç¶­æŒéœæ…‹é‡‘é‚Š */
  animation: none;
}

@keyframes goldGlow {
  0%, 100% { box-shadow: 0 3px 8px rgba(255, 215, 0, 0.4), inset 0 1px 2px rgba(255,255,255,0.6); }
  50% { box-shadow: 0 3px 12px rgba(255, 215, 0, 0.7), inset 0 1px 2px rgba(255,255,255,0.8); }
}

.tile.dim {
  opacity: 0.6;
  filter: grayscale(0.3);
}

.tile.ai {
  background: linear-gradient(180deg, #e0e8f0 0%, #d0dce8 100%);
  font-size: 14px;
  min-width: 36px;
  padding: 8px 6px;
}

/* ä¸åŒèŠ±è‰²çš„ç‰Œé¢é¡è‰² */
.tile.suit-W {
  background: linear-gradient(180deg, #ffe5e5 0%, #ffcccc 100%);
  border-color: #cc6666;
  color: #cc0000;
}

.tile.suit-T {
  background: linear-gradient(180deg, #e5f0ff 0%, #cce0ff 100%);
  border-color: #6699cc;
  color: #0066cc;
}

.tile.suit-B {
  background: linear-gradient(180deg, #e5ffe5 0%, #ccffcc 100%);
  border-color: #66cc66;
  color: #009900;
}

.tile.suit-F, .tile.suit-D {
  background: linear-gradient(180deg, #fff5e5 0%, #ffe5cc 100%);
  border-color: #cc9966;
  color: #cc6600;
  font-weight: 800;
}

.tile.suit-H {
  background: linear-gradient(180deg, #ffe5ff 0%, #ffccff 100%);
  border-color: #cc66cc;
  color: #cc00cc;
}

.hand {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: center;
  margin: 12px 0;
}

.meld {
  background: linear-gradient(135deg, #003D7A 0%, #002855 100%);
  border: 2px dashed #0066CC;
  border-radius: 8px;
  padding: 6px 10px;
  margin-right: 8px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
}

.sec {
  margin: 20px 0;
}

.sec h3 {
  color: #8BC34A;
  margin: 0 0 10px 0;
  font-size: 18px;
  font-weight: 700;
  display: flex;
  align-items: center;
  gap: 8px;
}

/* log æ¨£å¼å·²ç§»åˆ° center-log */

#controls {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  margin-top: 12px;
  justify-content: center;
}

.badge {
  padding: 4px 10px;
  border-radius: 6px;
  background: linear-gradient(135deg, #003D7A 0%, #002855 100%);
  border: 2px solid #0066CC;
  font-size: 12px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.you {
  color: #8BC34A;
  font-weight: 700;
}

.dealer {
  /* ä½¿èŠå®¶æ¨™ç¤ºæ›´é¡¯çœ¼ï¼šåŠ ç²—é‚Šæ¡†èˆ‡æŸ”å’Œé‡‘å…‰èƒŒæ™¯ */
  border: 4px solid #FFC107 !important;
  box-shadow: 0 0 16px rgba(255, 193, 7, 0.7);
  background: rgba(255, 193, 7, 0.08);
}

/* ç”¨æ–¼å±€é¢è³‡è¨Šä¸­é¡¯ç¤ºç•¶å‰é¢¨åœˆçš„è† å›Šæ¨£å¼ï¼Œå°‡å­—é«”åŠ ç²—åŠ å¤§ä»¥é†’ç›®é¡¯ç¤º */
.round-pill {
  background: linear-gradient(135deg, #0066CC 0%, #003D7A 100%);
  border: 2px solid #0088FF;
  color: #ffffff;
  font-weight: 700;
  font-size: 16px;
  padding: 6px 14px;
  border-radius: 999px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  margin-right: 6px;
}

/* æ¨™ç¤ºèŠå®¶ç”¨çš„å°å¾½ç«  */
.dealer-badge {
  display: inline-block;
  margin-left: 4px;
  padding: 0 6px;
  background: linear-gradient(180deg, #FFC107 0%, #FFA000 100%);
  color: #ffffff;
  border-radius: 4px;
  font-weight: 700;
  font-size: 14px;
  line-height: 1.2;
  box-shadow: 0 2px 4px rgba(255, 193, 7, 0.4);
}

/* èª¿æ•´ä½ çš„å‰¯éœ²å€é¡¯ç¤ºï¼Œè®“åƒç¢°æ§“ä¸æœƒé®æ“‹æ‰‹ç‰Œ */
#yourMelds {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 8px;
  margin-top: 8px;
}

.danger {
  color: #ff8a8a;
  font-weight: 700;
}

.ok {
  color: #8BC34A;
  font-weight: 700;
}

#goldbar {
  background: linear-gradient(135deg, #003D7A 0%, #002855 100%);
  border: 2px solid #FFC107;
  border-radius: 10px;
  padding: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

#goldbar .tilekey {
  display: inline-block;
  margin-right: 8px;
  padding: 4px 10px;
  border-radius: 8px;
  background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
  border: 2px solid #d4af37;
  color: #1a1a1a;
  font-weight: 700;
  box-shadow: 0 2px 6px rgba(255, 215, 0, 0.4);
}

.player-info {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px;
  align-items: center;
  padding: 8px;
  background: linear-gradient(135deg, #002855 0%, #001a3d 100%);
  border-radius: 8px;
  margin-bottom: 6px;
}

.player-name {
  font-weight: 700;
  font-size: 15px;
}

/* è½ç‰Œæç¤ºæ¨£å¼ï¼šåƒ…é¡¯ç¤ºæ–¼ç©å®¶è‡ªå·±å€å¡Šï¼Œæ¡ç”¨è¼ƒå¤§å­—é«”å’Œé†’ç›®é¡è‰² */
.player-wait {
  font-size: 20px;
  font-weight: 700;
  color: #8BC34A;
  margin-top: 4px;
}

/* Dice icon displayed next to the dealer's name to indicate the number of consecutive dealer hands (é€£èŠ).
   Unicode characters âš€-âš… are used. */
.dice {
  font-size: 18px;
  margin-left: 4px;
}

.player-points {
  font-weight: 700;
  font-size: 16px;
  color: #8BC34A;
}

.reaction-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: transparent;
  border: none;
  border-radius: 12px;
  padding: 24px;
  box-shadow: none;
  backdrop-filter: none;
  z-index: 200;
  min-width: 280px;
  text-align: center;
}

.reaction-panel h3 {
  margin: 0 0 16px 0;
  color: #8BC34A;
  font-size: 20px;
  font-weight: 700;
}

.reaction-panel .row {
  justify-content: center;
  margin-top: 12px;
}

.overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: transparent;
  z-index: 199;
  pointer-events: none;
}

/* æ‰‹æ©ŸéŸ¿æ‡‰å¼è¨­è¨ˆ */
@media (max-width: 768px) {
  header {
    padding: 8px 10px;
  }
  
  .pill {
    font-size: 10px;
    padding: 3px 6px;
  }
  
  button {
    padding: 6px 10px;
    font-size: 12px;
  }
  
  #table {
    padding: 0 6px;
    margin: 8px auto;
  }
  
  .tile {
    min-width: 32px;
    padding: 6px 4px;
    font-size: 13px;
  }
  
  .tile.ai {
    min-width: 28px;
    padding: 5px 3px;
    font-size: 11px;
  }
  
  .tile.small {
    min-width: 22px;
    padding: 3px 2px;
    font-size: 10px;
  }
  
  .tile-drawn {
    margin-left: 8px;
  }
  
  .hand {
    gap: 3px;
  }
  
  .sec h3 {
    font-size: 14px;
  }
  
  #log {
    height: 120px;
    font-size: 11px;
  }
  
  .score {
    padding: 8px;
    margin-bottom: 8px;
  }
  
  .player-info {
    padding: 6px;
    font-size: 13px;
  }
  
  .player-name {
    font-size: 13px;
  }
  
  .player-points {
    font-size: 14px;
  }
  
  /* å››æ–¹ä½ç‰Œæ¡Œä½ˆå±€å„ªåŒ– */
  .players-grid {
    gap: 8px;
    margin-top: 12px;
  }
  
  .player-area {
    padding: 6px;
    font-size: 11px;
  }
  
  .player-header {
    font-size: 12px;
    margin-bottom: 3px;
  }
  
  .player-discard,
  .player-meld,
  .player-handcount {
    font-size: 10px;
    margin: 2px 0;
  }
  
  /* ä¸­å¤®ç‰Œæ²³å€åŸŸå„ªåŒ– */
  .center-discard {
    padding: 6px;
    border-width: 1px;
  }
  
  .center-discard h4 {
    font-size: 11px;
    margin-bottom: 6px;
  }
  
  .center-discard-content {
    gap: 2px;
  }
  
  #controls {
    gap: 5px;
    flex-wrap: wrap;
  }
  
  .badge {
    font-size: 10px;
    padding: 3px 6px;
  }
  
  .dealer-badge {
    font-size: 11px;
    padding: 0 4px;
  }
  
  .round-pill {
    font-size: 13px;
    padding: 4px 10px;
  }
}

@media (max-width: 480px) {
  header {
    padding: 6px 8px;
  }
  
  .pill {
    font-size: 9px;
    padding: 2px 5px;
  }
  
  button {
    padding: 5px 8px;
    font-size: 11px;
  }
  
  #table {
    padding: 0 4px;
    margin: 6px auto;
  }
  
  .tile {
    min-width: 28px;
    padding: 5px 3px;
    font-size: 12px;
  }
  
  .tile-drawn {
    margin-left: 6px;
  }
  
  .tile.ai {
    min-width: 24px;
    padding: 4px 2px;
    font-size: 10px;
  }
  
  .tile.small {
    min-width: 18px;
    padding: 2px 1px;
    font-size: 9px;
  }
  
  .hand {
    gap: 2px;
  }
  
  .hand-row {
    gap: 2px;
    flex-wrap: wrap !important;
    max-width: 100%;
  }
  
  .hand-container {
    gap: 2px;
    overflow-x: visible !important;
  }
  
  #controls {
    gap: 4px;
  }
  
  .sec h3 {
    font-size: 13px;
  }
  
  #log {
    height: 80px;
    font-size: 10px;
  }
  
  .score {
    padding: 5px;
    margin-bottom: 6px;
  }
  
  .player-info {
    padding: 4px;
    font-size: 11px;
  }
  
  .player-name {
    font-size: 11px;
  }
  
  .player-points {
    font-size: 12px;
  }
  
  .players-grid {
    gap: 6px;
    margin-top: 8px;
  }
  
  .player-area {
    padding: 4px;
    font-size: 10px;
  }
  
  .player-header {
    font-size: 11px;
    margin-bottom: 2px;
  }
  
  .player-discard,
  .player-meld,
  .player-handcount {
    font-size: 9px;
    margin: 1px 0;
    line-height: 1.2;
  }
  
  .center-discard {
    padding: 4px;
  }
  
  .center-discard h4 {
    font-size: 10px;
    margin-bottom: 4px;
  }
  
  .center-discard-content {
    gap: 1px;
  }
  
  .meld {
    margin-right: 3px;
    padding: 4px 6px;
  }
  
  .badge {
    font-size: 9px;
    padding: 2px 5px;
  }
  
  .dealer-badge {
    font-size: 10px;
    padding: 0 3px;
  }
  
  .round-pill {
    font-size: 12px;
    padding: 3px 8px;
  }
  
  .tile.placeholder {
    min-width: 28px;
    padding: 5px 3px;
  }
}

/* æ‰‹ç‰Œå®¹å™¨æ¨£å¼ */
/* å–®è¡Œæ‰‹ç‰Œï¼šå…¨éƒ¨æ‰‹ç‰Œæ’æˆä¸€è¡Œï¼Œå¦‚æ‰‹ç‰Œéé•·å‰‡è‡ªå‹•æ›è¡Œä½†ä¿æŒåŒä¸€å®¹å™¨ */
.hand-container {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
  align-items: center;
  margin: 12px 0;
}

.hand-row {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  justify-content: center;
}

.tile {
  min-width: 42px;
  padding: 8px 6px;
  background: linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%);
  border: 2px solid #ccc;
  border-radius: 6px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.15);
  user-select: none;
}

.tile:hover {
  transform: translateY(-4px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.25);
}

.tile-drawn {
  margin-left: 12px;
  border: 3px solid #ffd36f;
  box-shadow: 0 0 12px rgba(255, 211, 111, 0.6), 0 2px 4px rgba(0,0,0,0.15);
  /* åœæ­¢é–ƒçˆæ•ˆæœ */
  animation: none;
}

@keyframes blink {
  0%, 100% {
    filter: brightness(1);
  }
  50% {
    filter: brightness(1.4);
  }
}

/* ä½”ä½æ ¼ï¼šç”¨æ–¼é¡¯ç¤ºæ‘¸ç‰Œèˆ‡ä¸‹æ’ä¹‹é–“çš„ç©ºæ ¼ */
.tile.placeholder {
  visibility: hidden;
  min-width: 42px;
  padding: 8px 6px;
  border: 2px solid transparent;
}

/* å°å‹ç‰Œé¢ï¼šç”¨æ–¼å…¶ä»–ç©å®¶çš„æ¨ç‰Œé¡¯ç¤º */
.tile.small {
  min-width: 28px;
  padding: 4px 2px;
  font-size: 12px;
  border-width: 1px;
  box-shadow: none;
  margin: 1px;
  cursor: default;
}

/* å‰¯éœ²å€å¡Šæ¨£å¼ */
.meld {
  display: inline-flex;
  align-items: center;
  margin-right: 8px;
}

/* å‹•ç•«æ•ˆæœ */
@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.tile {
  /* åœç”¨æ¯æ¬¡é‡æ–°æ¸²æŸ“æ™‚çš„æ»‘å…¥å‹•ç•«ï¼Œé¿å…æ•´å‰¯ç‰Œé »ç¹åˆ·æ–°çš„é–ƒçˆæ„Ÿ */
  animation: none;
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
}

.tile:hover {
  animation: pulse 0.5s ease infinite;
}
  /* ===== çœŸå¯¦ç‰Œæ¡Œä½ˆå±€ ===== */
  .mahjong-table {
    display: grid;
    grid-template-columns: 100px 1fr 100px;
    grid-template-rows: 80px 1fr 140px;
    grid-template-areas:
      ". top-area ."
      "left-area center-area right-area"
      ". bottom-area .";
    gap: 3px;
    margin-top: 8px;
    margin-bottom: 12px;
    min-height: 350px;
    max-height: 450px;
    padding: 6px;
    background: rgba(0, 40, 85, 0.2);
    border-radius: 8px;
  }
  
  /* ä¸Šæ–¹å€åŸŸï¼šå‰¯éœ²-æ£„ç‰Œ-ç©å®¶ï¼ˆæ©«å‘ï¼‰ */
  .top-area {
    grid-area: top-area;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: 5px;
    background: rgba(0, 0, 0, 0.3);
    border: 2px solid #CC0000;
    border-radius: 8px;
    padding: 8px;
  }
  
  /* ä¸‹æ–¹å€åŸŸï¼šæˆ‘çš„ç©å®¶è³‡è¨Šã€å‰¯éœ²å’Œæ£„ç‰Œ */
  .bottom-area {
    grid-area: bottom-area;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: 5px;
    min-height: 80px;
    background: rgba(0, 0, 0, 0.3);
    border: 2px solid #CC0000;
    border-radius: 8px;
    padding: 8px;
  }
  
  .bottom-hand-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    width: 100%;
  }
  
  .my-discard-meld {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }
  
  /* å·¦æ–¹å€åŸŸï¼šç©å®¶-æ£„ç‰Œ-å‰¯éœ²ï¼ˆç›´å‘ï¼‰ */
  .left-area {
    grid-area: left-area;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 5px;
    background: rgba(0, 0, 0, 0.3);
    border: 2px solid #CC0000;
    border-radius: 8px;
    padding: 8px;
  }
  
  /* å³æ–¹å€åŸŸï¼šå‰¯éœ²-æ£„ç‰Œ-ç©å®¶ï¼ˆç›´å‘ï¼‰ */
  .right-area {
    grid-area: right-area;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 5px;
    background: rgba(0, 0, 0, 0.3);
    border: 2px solid #CC0000;
    border-radius: 8px;
    padding: 8px;
  }
  
  /* ä¸­å¤®å€åŸŸ */
  .center-area {
    grid-area: center-area;
    display: flex;
    flex-direction: column;
    background: transparent;
    border: none;
    border-radius: 6px;
    padding: 8px;
    min-height: 200px;
    gap: 8px;
    justify-content: space-between;
  }
  
  /* ä¸­å¤®æ‰‹ç‰Œå€åŸŸ */
  .center-hand-area {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 8px;
  }
  
  .hand-area {
    flex: 0.6;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 6px;
    background: rgba(0, 0, 0, 0.5);
    border: 2px solid #000000;
    border-radius: 8px;
    padding: 12px;
  }
  
  .hand-label {
    font-size: 14px;
    font-weight: 700;
    color: #8BC34A;
  }
  
  .hand-tiles {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    justify-content: center;
  }
  
  /* ä¸­å¤®å€åŸŸå…§å®¹ */
  .center-log-container {
    flex: 0.4;
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 12px;
    overflow: hidden;
    background: rgba(0, 0, 0, 0.5);
    border: 2px solid #000000;
    border-radius: 8px;
    padding: 12px;
  }
  
  .center-log-container h4 {
    margin: 0 0 8px 0;
    font-size: 14px;
    color: #8BC34A;
    font-weight: 700;
  }
  
  .center-log-left {
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  
  .center-log-right {
    display: flex;
    flex-direction: column;
    gap: 8px;
    overflow: hidden;
  }
  
  .center-info-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: center;
  }
  
  .center-log {
    flex: 1;
    background: linear-gradient(135deg, #001428 0%, #002855 100%);
    border: 2px solid #0066CC;
    border-radius: 6px;
    padding: 6px;
    overflow-y: auto;
    overflow-x: hidden;
    font-size: 10px;
    line-height: 1.4;
    margin-top: 4px;
    max-height: 120px;
    word-wrap: break-word;
  }
  
  .center-log::-webkit-scrollbar {
    width: 8px;
  }
  
  .center-log::-webkit-scrollbar-track {
    background: #001428;
    border-radius: 3px;
  }
  
  .center-log::-webkit-scrollbar-thumb {
    background: #0066CC;
    border-radius: 3px;
  }
  
  .center-log::-webkit-scrollbar-thumb:hover {
    background: #0088FF;
  }
  
  .center-discard h4 {
    margin: 0;
    font-size: 14px;
    color: #8BC34A;
    font-weight: 700;
  }
  
  .center-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    font-size: 12px;
  }
  
  .center-round {
    font-size: 16px;
    font-weight: 700;
    color: #8BC34A;
    background: rgba(139, 195, 74, 0.15);
    padding: 4px 12px;
    border-radius: 8px;
  }
  
  .center-gold {
    font-size: 11px;
    color: #8BC34A;
  }
  
  .center-remain {
    font-size: 11px;
    color: #e9f0f6;
  }
  
  /* æ£„ç‰Œå€å’Œå‰¯éœ²å€å®¹å™¨ */
  .discard-meld-container {
    display: flex;
    gap: 6px;
    align-items: center;
  }
  
  .discard-meld-container.vertical {
    flex-direction: column;
  }  /* ç©å®¶è³‡è¨Šinlineé¡¯ç¤º */
  .player-info-inline {
    background: rgba(0, 61, 122, 0.6);
    border: 2px solid #0066CC;
    border-radius: 6px;
    padding: 8px;
    color: #e9f0f6;
    font-size: 12px;
    font-weight: 600;
    text-align: center;
    min-width: 100px;
    display: block;
    position: relative;
    transition: all 0.3s ease;
  }
  
  /* è¼ªåˆ°å‡ºç‰Œçš„ç©å®¶é«˜äº® */
  .player-info-inline.active-turn {
    border: 3px solid #FFC107;
    box-shadow: 0 0 20px rgba(255, 193, 7, 0.8), 0 0 40px rgba(255, 193, 7, 0.4);
    background: rgba(255, 193, 7, 0.2);
  }
  
  /* ç®­é ­æ¨™ç¤º */
  .turn-indicator {
    position: absolute;
    font-size: 32px;
    color: #FFC107;
    animation: bounce 1s ease-in-out infinite;
    text-shadow: 0 0 10px rgba(255, 193, 7, 0.8), 0 0 20px rgba(255, 193, 7, 0.6);
    z-index: 10;
  }
  
  /* ä¸Šæ–¹ç©å®¶çš„ç®­é ­ï¼ˆå¾€ä¸Šï¼‰ */
  .info-top .turn-indicator {
    top: -45px;
    left: 50%;
    transform: translateX(-50%);
  }
  
  /* å·¦æ–¹ç©å®¶çš„ç®­é ­ï¼ˆå¾€å·¦ï¼‰ */
  .info-left .turn-indicator {
    left: -45px;
    top: 50%;
    transform: translateY(-50%);
  }
  
  /* å³æ–¹ç©å®¶çš„ç®­é ­ï¼ˆå¾€å³ï¼‰ */
  .info-right .turn-indicator {
    right: -45px;
    top: 50%;
    transform: translateY(-50%);
  }
  
  /* ä¸‹æ–¹ç©å®¶çš„ç®­é ­ï¼ˆå¾€ä¸‹ï¼‰ */
  .info-bottom .turn-indicator {
    bottom: -45px;
    left: 50%;
    transform: translateX(-50%);
  }
  
  @keyframes bounce {
    0%, 100% { transform: translateX(-50%) translateY(0); }
    50% { transform: translateX(-50%) translateY(-10px); }
  }
  
  /* å·¦å³æ–¹å‘çš„å½ˆè·³å‹•ç•« */
  .info-left .turn-indicator {
    animation: bounceLeft 1s ease-in-out infinite;
  }
  
  .info-right .turn-indicator {
    animation: bounceRight 1s ease-in-out infinite;
  }
  
  @keyframes bounceLeft {
    0%, 100% { transform: translateY(-50%) translateX(0); }
    50% { transform: translateY(-50%) translateX(-10px); }
  }
  
  @keyframes bounceRight {
    0%, 100% { transform: translateY(-50%) translateX(0); }
    50% { transform: translateY(-50%) translateX(10px); }
  }
  
  /* ä¸Šä¸‹æ–¹å‘çš„å½ˆè·³å‹•ç•« */
  .info-top .turn-indicator {
    animation: bounceUp 1s ease-in-out infinite;
  }
  
  .info-bottom .turn-indicator {
    animation: bounceDown 1s ease-in-out infinite;
  }
  
  @keyframes bounceUp {
    0%, 100% { transform: translateX(-50%) translateY(0); }
    50% { transform: translateX(-50%) translateY(-10px); }
  }
  
  @keyframes bounceDown {
    0%, 100% { transform: translateX(-50%) translateY(0); }
    50% { transform: translateX(-50%) translateY(10px); }
  }
  
  .player-info-inline .player-name {
    font-size: 13px;
    font-weight: 700;
    margin-bottom: 6px;
    line-height: 1.4;
  }
  
  .player-info-inline .player-score {
    font-size: 13px;
    color: #8BC34A;
    font-weight: 700;
    margin-bottom: 4px;
  }
  
  /* æ£„ç‰Œå€åŸŸåŸºæœ¬æ¨£å¼ */
  .discard-area {
    background: rgba(0, 0, 0, 0.3);
    border: none;
    border-radius: 6px;
    padding: 4px;
    display: flex;
    flex-wrap: wrap;
    gap: 2px;
    justify-content: flex-start;
    align-content: flex-start;
  }
  
  /* ä¸Šä¸‹æ–¹æ£„ç‰Œå€ï¼šæ©«å‘ */
  .discard-top, .discard-bottom {
    width: 250px;
    height: 60px;
  }
  
  /* å·¦å³æ–¹æ£„ç‰Œå€ï¼šç›´å‘ï¼Œæ·»åŠ æ»¾å‹•åŠŸèƒ½ */
  .discard-left, .discard-right {
    width: 80px;
    height: 180px;
    overflow-y: auto;
    overflow-x: hidden;
  }
  
  /* æ»¾å‹•æ¢æ¨£å¼ */
  .discard-left::-webkit-scrollbar,
  .discard-right::-webkit-scrollbar {
    width: 6px;
  }
  
  .discard-left::-webkit-scrollbar-track,
  .discard-right::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 3px;
  }
  
  .discard-left::-webkit-scrollbar-thumb,
  .discard-right::-webkit-scrollbar-thumb {
    background: rgba(0, 102, 204, 0.6);
    border-radius: 3px;
  }
  
  .discard-left::-webkit-scrollbar-thumb:hover,
  .discard-right::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 102, 204, 0.8);
  }
  
  /* å‰¯éœ²å€åŸŸ */
  .meld-area {
    background: rgba(139, 195, 74, 0.1);
    border: none;
    border-radius: 6px;
    padding: 4px;
    display: flex;
    flex-wrap: wrap;
    gap: 2px;
  }
  
  /* ä¸Šä¸‹æ–¹å‰¯éœ²å€ï¼šæ©«å‘ */
  .meld-top, .meld-bottom {
    width: 150px;
    height: 60px;
  }
  
  /* å·¦å³æ–¹å‰¯éœ²å€ï¼šç›´å‘ */
  .meld-left, .meld-right {
    width: 80px;
    height: 150px;
  }
  
  /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
  @media (max-width: 768px) {
    .mahjong-table {
      grid-template-columns: 80px 1fr 80px;
      grid-template-rows: 60px 1fr 60px;
      min-height: 300px;
      max-height: 350px;
      padding: 3px;
      gap: 2px;
      margin-top: 4px;
    }
    
    .center-area {
      min-height: 150px;
      max-height: 180px;
      padding: 4px;
    }
    
    .center-log {
      font-size: 9px;
      padding: 4px;
      max-height: 80px;
    }
    
    .discard-top, .discard-bottom {
      width: 150px !important;
      height: 40px !important;
    }
    
    .discard-left, .discard-right {
      width: 50px !important;
      height: 100px !important;
    }
    
    .meld-top, .meld-bottom {
      width: 100px !important;
      height: 40px !important;
    }
    
    .meld-left, .meld-right {
      width: 50px !important;
      height: 80px !important;
    }
    
    .player-info-inline {
      min-width: 90px;
      padding: 6px 8px;
      font-size: 11px;
    }
    
    .player-info-inline .player-name {
      font-size: 12px;
    }
    
    .player-info-inline .player-score {
      font-size: 11px;
    }
    
    .discard-area {
      min-width: 80px;
      min-height: 60px;
      padding: 4px;
    }
    
    .meld-area {
      min-width: 80px;
      min-height: 50px;
      padding: 4px;
    }
    
    .center-area {
      padding: 8px;
      min-height: 200px;
    }
    
    .center-log-container h4 {
      font-size: 12px;
    }
  }
  
  .discard-area-header {
    font-size: 11px;
    font-weight: 700;
    color: #ffd36f;
    text-align: center;
    margin-bottom: 2px;
  }
  
  .discard-area-content {
    display: flex;
    flex-wrap: wrap;
    gap: 3px;
    flex: 1;
  }
  
  /* ä¸Šæ–¹æ£„ç‰Œå€ï¼ˆæ±å®¶ï¼‰ */
  .discard-area.top {
    grid-area: discard-top;
  }
  
  .discard-area.top .discard-area-content {
    justify-content: center;
    align-items: flex-start;
  }
  
  /* å·¦æ–¹æ£„ç‰Œå€ï¼ˆåŒ—å®¶ï¼‰ */
  .discard-area.left {
    grid-area: discard-left;
  }
  
  .discard-area.left .discard-area-content {
    justify-content: flex-end;
    align-items: center;
  }
  
  /* å³æ–¹æ£„ç‰Œå€ï¼ˆå—å®¶ï¼‰ */
  .discard-area.right {
    grid-area: discard-right;
  }
  
  .discard-area.right .discard-area-content {
    justify-content: flex-start;
    align-items: center;
  }
  
  /* ä¸‹æ–¹æ£„ç‰Œå€ï¼ˆè¥¿å®¶ï¼‰ */
  .discard-area.bottom {
    grid-area: discard-bottom;
  }
  
  .discard-area.bottom .discard-area-content {
    justify-content: center;
    align-items: flex-end;
  }
  
  /* ç©å®¶è³‡è¨Šå€åŸŸ */
  .players-info {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-top: 16px;
  }
  
  .player-info-card {
    background: rgba(0, 0, 0, 0.25);
    border: 1px solid #2a4766;
    border-radius: 6px;
    padding: 8px;
    font-size: 12px;
  }
  
  .player-info-card .info-name {
    font-weight: 700;
    font-size: 13px;
    margin-bottom: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .player-info-card .info-points {
    font-size: 12px;
    color: #9cf39c;
    font-weight: 600;
  }
  
  .player-info-card .info-melds,
  .player-info-card .info-handcount {
    font-size: 11px;
    margin: 2px 0;
  }
  
  /* ä½ çš„æ‰‹ç‰Œå€åŸŸ */
  .your-hand-section {
    margin-top: 16px;
    padding: 12px;
    background: rgba(0, 0, 0, 0.3);
    border: 2px solid #2a4766;
    border-radius: 8px;
  }
  
  .your-hand-section h3 {
    margin-top: 0;
    margin-bottom: 12px;
    font-size: 16px;
  }

  .player-area {
    padding: 8px;
    background: rgba(0, 0, 0, 0.25);
    border: 1px solid #2a4766;
    border-radius: 6px;
    color: #e9f0f6;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  /* å€åŸŸå®šä½ */
  .player-area.top { grid-area: top; }
  .player-area.bottom { grid-area: bottom; }
  .player-area.left { grid-area: left; }
  .player-area.right { grid-area: right; }

  /* åŒ—å®¶é¡¯ç¤ºå€ï¼ˆå°å®¶ï¼‰ç‰Œé¢è¼ƒå°ï¼Œæ©«å‘é¡¯ç¤ºï¼Œç½®ä¸­ */
  .player-area.top .tile.small { margin: 0 2px; }

  /* å·¦å³å®¶å€å¡Šè®“å…§å®¹è²¼é½Šé‚Šç·£ */
  .player-area.left, .player-area.right {
    align-items: flex-start;
  }

  /* æ¨ç‰Œèˆ‡å‰¯éœ²åœ¨å…¶ä»–å®¶é¡¯ç¤ºç‚ºå°è¡Œ */
  .player-discard, .player-meld { margin-top: 4px; }

/*
 * æ‰‹ç‰Œå®¹å™¨èˆ‡æ’åˆ—ï¼šç‚ºäº†æ»¿è¶³ã€Œ16 å¼µä¸€è¡Œã€çš„éœ€æ±‚ï¼Œä¸å†åˆ†ä¸Šä¸‹æ’ï¼Œè€Œæ˜¯ä½¿ç”¨å–®è¡Œ flex æ’åˆ—ã€‚
 * è‹¥å¯¬åº¦ä¸è¶³ï¼Œè‡ªå‹•å‡ºç¾æ©«å‘å·è»¸ï¼›åŒæ™‚ç¦æ­¢å‚ç›´æ²å‹•ã€‚é€™äº›æ¨£å¼æ”¾ç½®æ–¼çµå°¾è™•ä¾¿æ–¼è¦†å¯«å…ˆå‰å®šç¾©ã€‚
 */
.hand-container {
  width: 100%;
  overflow-x: visible;
  overflow-y: visible;
}
.hand-row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
}
/* ä½”ä½ç¬¦è™Ÿï¼Œç”¨æ–¼æ‘¸ç‰Œåˆ†éš”ï¼Œéš±è—ä¸å¯é»æ“Š */
.tile.placeholder {
  visibility: hidden;
  pointer-events: none;
}
/* æ–°æ‘¸é€²çš„ç‰Œçš„å°ˆç”¨æ¨£å¼ï¼Œç¨å¾®åŠ å¼·é‚Šæ¡†èˆ‡å…‰å½±è¾¨è­˜ */
.tile.tile-drawn {
  border-color: #ffcf4e;
  box-shadow: 0 0 8px rgba(255, 207, 78, 0.6), inset 0 1px 2px rgba(255, 255, 255, 0.5);
}

/* ========== æˆ°æ³ç´€éŒ„æ¨£å¼æ”¹é€² ========== */
/* è®“å°ç‰Œåœ¨ç´€éŒ„ä¸­æ¸…æ™°å¯è¾¨ï¼Œä¸¦ç•™å‡ºäº›è¨±é–“è· */
#log .tile {
  display: inline-block;
  margin: 0 3px;
  padding: 4px 6px;
  min-width: 28px;
  width: 28px;
  height: 36px;
  font-size: 13px;
  font-weight: 700;
  line-height: 1;
  vertical-align: middle;
  border-radius: 4px;
  border: 1.5px solid #4a6d8c;
  background: linear-gradient(180deg, #ffffff 0%, #f0f8ff 100%);
  box-shadow: 0 1px 3px rgba(0,0,0,0.2), inset 0 1px 1px rgba(255,255,255,0.5);
  text-align: center;
  flex-shrink: 0;
}
/* é«˜äº®é¡¯ç¤ºç©å®¶è‡ªå·±çš„ç´€éŒ„è¡Œ */
#log .my-log {
  font-size: 13px;
  font-weight: 700;
  color: #ffdf75;
}

</style>
</head>
<body>
<header>
  <div class="row">
    <span class="pill">ğŸ€„ å°ç£ 16 å¼µéº»å°‡ï¼ˆå–®æ©Ÿï¼‰</span>
    <label class="pill" style="cursor: pointer;">
      <input id="goldSwitch" type="checkbox" checked style="margin-right: 4px;"> å•Ÿç”¨é‡‘ç‰Œ
    </label>
    <span class="pill">ğŸ’° åº• 2000ï¼æ¯å° 1000</span>
    <span class="pill">ğŸ¯ èµ·å§‹ 100,000</span>
  </div>
  <div class="row">
    <button id="newGameBtn">ğŸ² é–‹å§‹æ–°å±€</button>
  </div>
</header>

<div id="table">
  <!-- éš±è—çš„å…ƒç´ ï¼Œä¿ç•™ä»¥é˜²JavaScriptéŒ¯èª¤ -->
  <div id="scoreboard" style="display: none;"></div>
  <div class="row sec" id="goldbar" style="display: none;"></div>
  <div class="sec" style="display: none;">
    <div id="roundinfo" class="row"></div>
  </div>

  <!-- çœŸå¯¦ç‰Œæ¡Œä½ˆå±€ï¼šå››æ–¹ä½ -->
  <div id="playersGrid" class="mahjong-table">
    <!-- ä¸Šæ–¹ç©å®¶å€åŸŸ -->
    <div class="top-area">
      <div id="meldArea1" class="meld-area meld-top"></div>
      <div id="discardArea1" class="discard-area discard-top"></div>
      <div id="playerInfo1" class="player-info-inline info-top"></div>
    </div>
    
    <!-- å·¦æ–¹ç©å®¶å€åŸŸ -->
    <div class="left-area">
      <div id="playerInfo2" class="player-info-inline info-left"></div>
      <div id="discardArea2" class="discard-area discard-left"></div>
      <div id="meldArea2" class="meld-area meld-left"></div>
    </div>
    
    <!-- ä¸­å¤®å€åŸŸ -->
    <div class="center-area">
      <!-- æˆ°æ³è¨˜éŒ„å’Œç‰Œå±€è³‡è¨Š -->
      <div class="center-log-container">
        <!-- å·¦å´ï¼šæˆ°æ³è¨˜éŒ„ -->
        <div class="center-log-left">
          <h4>ğŸ“£ æˆ°æ³</h4>
          <div id="log" class="center-log"></div>
        </div>
        
        <!-- å³å´ï¼šç‰Œå±€è³‡è¨Š -->
        <div class="center-log-right">
          <h4>ğŸ² ç‰Œå±€</h4>
          <div id="centerRound" class="center-round"></div>
          <div id="centerGold" class="center-gold"></div>
          <div id="centerRemain" class="center-remain"></div>
        </div>
      </div>
      
      <!-- æˆ‘çš„æ‰‹ç‰Œå€åŸŸ -->
      <div id="yourHandArea" class="hand-area">
        <div class="hand-label">ğŸ€„ ä½ çš„æ‰‹ç‰Œ</div>
        <div id="btnListenHint" class="listen-hint" style="display:none;"></div>
        <div id="yourHand" class="hand-tiles"></div>
      </div>
    </div>
    
    <!-- å³æ–¹ç©å®¶å€åŸŸ -->
    <div class="right-area">
      <div id="meldArea3" class="meld-area meld-right"></div>
      <div id="discardArea3" class="discard-area discard-right"></div>
      <div id="playerInfo3" class="player-info-inline info-right"></div>
    </div>
    
    <!-- ä¸‹æ–¹å€åŸŸï¼šæˆ‘çš„ç©å®¶è³‡è¨Šã€å‰¯éœ²å’Œæ£„ç‰Œ -->
    <div class="bottom-area">
      <div id="playerInfo0" class="player-info-inline info-bottom"></div>
      <div id="meldArea0" class="meld-area meld-bottom"></div>
      <div id="discardArea0" class="discard-area discard-bottom"></div>
    </div>
  </div>
  
  <!-- æˆ°æ³è¨˜éŒ„å·²ç§»åˆ°ä¸­å¤®ç‰Œæ¡Œå€åŸŸ -->
  
  <!-- æ‰‹ç‰Œå€åŸŸå·²ç§»åˆ°ä¸­å¤®å€åŸŸ -->
  
  <!-- æ“ä½œæŒ‰éˆ• -->
  <div class="sec controls-section">
    <div id="controls" class="row">
      <button id="btnHu" disabled>ğŸ‰ èƒ¡ç‰Œ</button>
      <button id="btnChow" disabled>ğŸœ åƒ</button>
      <button id="btnPong" disabled>ğŸ”¥ ç¢°</button>
      <button id="btnKong" disabled>ğŸ’¥ æ§“</button>
      <button id="btnListen" disabled>ğŸ”” è½</button>
      <button id="btnPass" disabled>â­ï¸ é</button>
    </div>
  </div>

<div id="reactionPanel" style="display: none;"></div>
<div id="overlay" class="overlay" style="display: none;"></div>

<script>
/* ========= åŸºæœ¬å·¥å…· ========= */
const rng = (n) => Math.floor(Math.random() * n);
const clone = (o) => JSON.parse(JSON.stringify(o));

// éŸ³æ•ˆç³»çµ±
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(freq, duration, type = 'sine') {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.frequency.value = freq;
  osc.type = type;
  gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + duration);
}

// ç‰¹æ•ˆç³»çµ±
function showEffect(text, color, size = '48px') {
  const effect = document.createElement('div');
  effect.textContent = text;
  effect.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: ${size};
    color: ${color};
    font-weight: bold;
    text-shadow: 0 0 20px ${color}, 0 0 40px ${color};
    z-index: 9999;
    pointer-events: none;
    animation: effectPop 1s ease-out forwards;
  `;
  document.body.appendChild(effect);
  setTimeout(() => effect.remove(), 1000);
}

// CSS å‹•ç•«
if (!document.getElementById('effectStyle')) {
  const style = document.createElement('style');
  style.id = 'effectStyle';
  style.textContent = `
    @keyframes effectPop {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
    }
  `;
  document.head.appendChild(style);
}

function log(msg) {
  const el = document.getElementById('log');
  // å»ºç«‹æ–°çš„ç´€éŒ„è¡Œå…ƒç´ ï¼Œé€é formatLogString å°‡ç‰Œåè½‰æˆå°ç‰Œåœ–ç¤º
  const line = document.createElement('div');
  // æ ¼å¼åŒ–è¨Šæ¯ï¼šå°‡æ•¸å­—ç‰Œã€é¢¨ç‰Œã€ä¸‰å…ƒç‰Œè½‰æˆå°ç‰Œæ¨£å¼
  const formatted = formatLogString(msg);
  line.innerHTML = formatted;
  line.style.marginBottom = '4px';
  // è‹¥è¨Šæ¯åŒ…å«ã€Œä½ ã€ï¼Œä»£è¡¨ç‚ºç©å®¶è‡ªèº«ç›¸é—œï¼Œå¥—ç”¨é«˜äº®æ¨£å¼
  if (/ä½ /.test(msg)) {
    line.classList.add('my-log');
  }
  el.appendChild(line);
  // è‡ªå‹•æ²å‹•åˆ°åº•éƒ¨
  el.scrollTop = el.scrollHeight;
}

/*
 * å°‡æˆ°æ³æ–‡å­—ä¸­çš„ç‰Œåè½‰æ›ç‚ºé¡¯ç¤ºç”¨çš„å°ç‰Œåœ–ç¤ºã€‚
 * æ”¯æ´æ•¸å­—èˆ‡ä¸­æ–‡è¡¨ç¤ºçš„æ•¸å­—ç‰Œï¼ˆå¦‚ 1è¬ã€äºŒç­’ã€9æ¢ï¼‰ï¼Œä»¥åŠé¢¨ç‰Œã€ä¸‰å…ƒç‰Œã€‚
 */
function formatLogString(text) {
  // æ˜ å°„ä¸­æ–‡æ•¸å­—åˆ°é˜¿æ‹‰ä¼¯æ•¸å­—
  const cnNumMap = { 'ä¸€': 1, 'äºŒ': 2, 'ä¸‰': 3, 'å››': 4, 'äº”': 5, 'å…­': 6, 'ä¸ƒ': 7, 'å…«': 8, 'ä¹': 9 };
  // ä¸»æ­£å‰‡ï¼šåŒ¹é…æ•¸å­—ç‰Œï¼ˆ1è¬/ä¸€è¬ï¼‰ã€é¢¨ç‰Œï¼ˆæ±å—è¥¿åŒ—ï¼‰ã€ä¸‰å…ƒç‰Œï¼ˆä¸­ç™¼ç™½ï¼‰
  return text.replace(/([1-9]|[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹])([è¬ç­’æ¢ç´¢])|([æ±å—è¥¿åŒ—ä¸­ç™¼ç™½])/g, (m, p1, p2, p3) => {
    // å¦‚æœæ˜¯æ•¸å­—ç‰Œ
    if (p1 && p2) {
      const rank = /[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹]/.test(p1) ? cnNumMap[p1] : parseInt(p1);
      const suitChar = p2;
      let suitKey;
      if (suitChar === 'è¬') suitKey = 'W';
      else if (suitChar === 'ç­’') suitKey = 'T';
      else if (suitChar === 'æ¢' || suitChar === 'ç´¢') suitKey = 'B';
      else suitKey = '?';
      // ä½¿ç”¨åŸæ–‡å­—å…§å®¹ä½œç‚ºç‰Œé¢é¡¯ç¤º
      return `<span class="tile small suit-${suitKey}">${m}</span>`;
    }
    // å¦‚æœæ˜¯å–®å€‹é¢¨ç‰Œæˆ–ä¸‰å…ƒç‰Œ
    if (p3) {
      let suitKey;
      // é¢¨ç‰Œ
      if ('æ±å—è¥¿åŒ—'.includes(p3)) suitKey = 'F';
      else if ('ä¸­ç™¼ç™½'.includes(p3)) suitKey = 'D';
      else suitKey = '?';
      return `<span class="tile small suit-${suitKey}">${p3}</span>`;
    }
    return m;
  });
}

/* ========= ç‰Œå‹å®šç¾© ========= */
const SUIT_W = 'W', SUIT_T = 'T', SUIT_B = 'B', SUIT_F = 'F', SUIT_D = 'D';
const WINDS = ['E', 'S', 'W', 'N'];
const DRAGONS = ['C', 'F', 'B'];
// èŠ±ç‰Œå·²ç§»é™¤

function tileKey(t) {
  if (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) return t.suit + String(t.rank);
  if (t.suit === SUIT_F || t.suit === SUIT_D) return t.suit + t.name;
  return '?';
}

function keyToText(k) {
  const s = k[0], v = k.slice(1);
  if (s === SUIT_W) return v + 'è¬';
  if (s === SUIT_T) return v + 'ç­’';
  if (s === SUIT_B) return v + 'æ¢';
  if (s === SUIT_F) {
    const m = { E: 'æ±', S: 'å—', W: 'è¥¿', N: 'åŒ—' };
    return m[v] || k;
  }
  if (s === SUIT_D) {
    const m = { C: 'ä¸­', F: 'ç™¼', B: 'ç™½' };
    return m[v] || k;
  }
  return k;
}

function generateTiles() {
  const tiles = [];
  const push4 = (suit, rank) => {
    for (let i = 0; i < 4; i++) tiles.push({ suit, rank, id: tiles.length });
  };
  for (let r = 1; r <= 9; r++) {
    push4(SUIT_W, r);
    push4(SUIT_T, r);
    push4(SUIT_B, r);
  }
  WINDS.forEach(n => {
    for (let i = 0; i < 4; i++) tiles.push({ suit: SUIT_F, name: n, id: tiles.length });
  });
  DRAGONS.forEach(n => {
    for (let i = 0; i < 4; i++) tiles.push({ suit: SUIT_D, name: n, id: tiles.length });
  });
  // èŠ±ç‰Œå·²ç§»é™¤ï¼Œç¸½ç‰Œæ•¸136å¼µ
  return tiles;
}

function shuffle(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = rng(i + 1);
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* ========= éŠæˆ²è¦å‰‡èˆ‡ç‹€æ…‹ ========= */
const RULES = {
  handSize: 16,
  gold: { enabled: true, initial: 3, maxExtra: 2, totalMax: 5, perGold: 1, winOnGold: 3 },
  scoring: {
    SelfDraw: 1,
    MenqingSelfDraw: 3,
    AllPungs: 2,
    SevenPairs: 4,
    HalfFlush: 3,
    PureOneSuit: 5,
    Flower: 1,
    Wind: 1,
    RobKong: 1,
    Rinshan: 1,
    Haitei: 1
    ,
    // åœ°è½ï¼šèµ·ç‰Œå¾Œæµ·åº•æ‰“é€²8å¼µç‰Œå…§ä¸”ç„¡äººåƒç¢°æ™‚å®£å‘Šè½ç‰Œ
    EarthReady: 4,
    // å¤©è½ï¼šèŠå®¶ç¬¬ä¸€å¼µæ‰“å‡ºå¾Œå³è½ç‰Œ
    HeavenReady: 8
  },
  points: { base: 2000, perFan: 1000 },
  initialPoints: 100000
};

let S = null;
// Seat names (wind positions) for each player. Determined at the start of each new game
// based on the dealer determined by dice. seatNames[i] stores the wind ('æ±','å—','è¥¿','åŒ—') of player i.
let seatNames = ['æ±','å—','è¥¿','åŒ—'];

// è¼”åŠ©å‡½æ•¸ï¼šè¨ˆç®—ä¸‹ä¸€å€‹ç©å®¶ï¼ˆæŒ‰ç…§é †æ™‚é‡é †åºï¼‰
function getNextTurn(currentTurn) {
  // é †æ™‚é‡é †åºï¼š0(ä¸‹) -> 3(å³) -> 1(ä¸Š) -> 2(å·¦)
  const clockwiseOrder = [0, 3, 1, 2];
  const currentIndex = clockwiseOrder.indexOf(currentTurn);
  return clockwiseOrder[(currentIndex + 1) % 4];
}
// éš¨æ©Ÿç”Ÿæˆçš„ç©å®¶åç¨±é™£åˆ—ã€‚åœ¨æ¯æ¬¡æ–°é–‹å±€æ™‚æœƒé‡æ–°ç”¢ç”Ÿï¼Œç”¨æ–¼å–ä»£ã€Œæ±å®¶ã€ã€Œå—å®¶ã€ç­‰ç¨±è¬‚ã€‚
const NAME_POOL = [
  'å°æ˜','å°è¯','å°ç¾','é˜¿ç','å¿—å¼·','å¿—ç²','å»ºåœ‹','ç‰æ¢…','é˜¿èŠ¬','åœ‹è¯','ç¾æƒ ','æ”¿å®','æ·‘èŠ¬','å¿—è±ª','ç§‹é¦™','ä½©ç²','æ¬£æ€¡','å®¶è±ª','æ˜æ…§','å»ºè±'
];

// ç”¨ä¾†è¨˜éŒ„æœ¬å±€æ‰€ä½¿ç”¨çš„å››å€‹éš¨æ©Ÿç©å®¶åå­—ã€‚åªåœ¨ç¬¬ä¸€æ¬¡é–‹å±€æ™‚ç”Ÿæˆï¼Œä¹‹å¾Œæ–°å±€æ²¿ç”¨ã€‚
let randomNames = null;
// Global variables to track the dealer's consecutive wins (é€£èŠ). When the same player
// remains the dealer across hands, we increment dealerStreak. This streak is
// displayed as a dice icon next to the dealer's name on the scoreboard.
let dealerStreak = 0;

function startNewHand(isFirstGame = false) {
  const useGold = document.getElementById('goldSwitch').checked;
  
  let newDealer = S?.dealer ?? 0;
  let newRound = S?.round ?? 1;
  // å„²å­˜èˆŠéŠæˆ²ç‹€æ…‹ä¸­çš„ç©å®¶åå­—ï¼Œç”¨æ–¼æ–°å±€ç„¡é ˆé‡æ–°ç”Ÿæˆ
  const prevNames = S?.names || null;
  
  if (isFirstGame || !S) {
    const dice1 = Math.floor(Math.random() * 6) + 1;
    const dice2 = Math.floor(Math.random() * 6) + 1;
    const diceSum = dice1 + dice2;
    newDealer = (diceSum - 1) % 4;
    newRound = 1;
    // Assign seat names based on the initial dealer. The dealer is always East ('æ±'),
    // the next player clockwise is South ('å—'), then West ('è¥¿') and North ('åŒ—').
    // é †æ™‚é‡é †åºï¼šç©å®¶ä½ç½® 0(ä¸‹) -> 3(å³) -> 1(ä¸Š) -> 2(å·¦)
    // å¾èŠå®¶é–‹å§‹é †æ™‚é‡åˆ†é…ï¼šæ± -> å— -> è¥¿ -> åŒ—
    // ä½†ç©å®¶ç·¨è™Ÿé †åºæ˜¯ 0 -> 1 -> 2 -> 3ï¼Œæ‰€ä»¥éœ€è¦æ˜ å°„ç‚º 0 -> 3 -> 1 -> 2
    const clockwiseOrder = [0, 3, 1, 2]; // é †æ™‚é‡çš„ç©å®¶ä½ç½®é †åº
    seatNames = [];
    for (let offset = 0; offset < 4; offset++) {
      // æ‰¾åˆ°èŠå®¶åœ¨ clockwiseOrder ä¸­çš„ä½ç½®
      const dealerIndex = clockwiseOrder.indexOf(newDealer);
      // é †æ™‚é‡åˆ†é…é¢¨ä½
      const playerPos = clockwiseOrder[(dealerIndex + offset) % 4];
      seatNames[playerPos] = ['æ±', 'å—', 'è¥¿', 'åŒ—'][offset];
    }
    const dealerWindInit = seatNames[newDealer];
    const dealerNameInit = dealerWindInit + 'å®¶' + (newDealer === 0 ? '(ä½ )' : '');
    // éš¨æ©Ÿç”Ÿæˆå››å€‹ç©å®¶çš„åå­—ï¼Œç”¨å…©å€‹ä¸­æ–‡å­—å–ä»£æ±å—è¥¿åŒ—ç¨±è¬‚ã€‚åœ¨åˆæ¬¡é–‹å±€æ™‚é‡æ–°è¨­å®šã€‚
    const pool = NAME_POOL.slice();
    const names = [];
    for (let i = 0; i < 4; i++) {
      const rIndex = Math.floor(Math.random() * pool.length);
      names.push(pool.splice(rIndex, 1)[0]);
    }
    // å°‡ç”Ÿæˆçš„éš¨æ©Ÿåå­—å­˜å…¥å…¨å±€ randomNames ä»¥ä¾¿å¾ŒçºŒæ–°å±€æ²¿ç”¨
    randomNames = names;
    log(`ğŸ² æ“²éª°ï¼š${dice1} + ${dice2} = ${diceSum}ï¼ŒèŠå®¶ç‚º${dealerNameInit}`);
  } else if (S.winner === null) {
    // æµå±€ï¼ŒèŠå®¶ç¹¼çºŒç•¶èŠï¼ˆé€£èŠï¼‰
    log(`ğŸ” æµå±€é€£èŠï¼ŒèŠå®¶ç¹¼çºŒç•¶èŠ`);
  } else if (S.winner === S.dealer) {
    // èŠå®¶èƒ¡ç‰Œï¼Œç¹¼çºŒç•¶èŠï¼ˆé€£èŠï¼‰
    log(`ğŸ† èŠå®¶èƒ¡ç‰Œï¼Œç¹¼çºŒç•¶èŠ`);
  } else {
    // é–‘å®¶èƒ¡ç‰Œï¼ŒèŠå®¶è¼ªæ›¿ï¼ˆæŒ‰ç…§é †æ™‚é‡é †åºï¼‰
    // é †æ™‚é‡é †åºï¼š0(ä¸‹) -> 3(å³) -> 1(ä¸Š) -> 2(å·¦)
    const clockwiseOrder = [0, 3, 1, 2];
    const currentIndex = clockwiseOrder.indexOf(S.dealer);
    newDealer = clockwiseOrder[(currentIndex + 1) % 4];
    // ä¿®æ­£ï¼šç•¶èŠå®¶è¼ªå›åˆ°åˆå§‹èŠå®¶æ™‚ï¼Œæ‰é€²å…¥ä¸‹ä¸€åœˆ
    // åˆå§‹èŠå®¶æ˜¯ç¬¬ä¸€å±€æ™‚çš„èŠå®¶ï¼Œå„²å­˜åœ¨ S.initialDealer
    if (!S.initialDealer && S.initialDealer !== 0) {
      // ç¬¬ä¸€å±€ï¼Œè¨˜éŒ„åˆå§‹èŠå®¶
      // é€™å€‹æƒ…æ³ä¸æ‡‰ç™¼ç”Ÿï¼Œå› ç‚º initialDealer æ‡‰è©²åœ¨ç¬¬ä¸€å±€å°±è¨­å®š
    }
    if (newDealer === S.initialDealer) {
      // èŠå®¶è¼ªå›åˆ°åˆå§‹èŠå®¶ï¼Œé€²å…¥ä¸‹ä¸€åœˆ
      newRound++;
      if (newRound > 4) {
        log(`ğŸ å››åœˆå·²æ‰“å®Œï¼ŒéŠæˆ²çµæŸï¼`);
        showFinalScore();
        return;
      }
      log(`ğŸ”„ é€²å…¥ç¬¬${newRound}åœˆ`);
    }
    const rotatedWind = seatNames?.[newDealer] || ['æ±','å—','è¥¿','åŒ—'][newDealer];
    const rotatedName = rotatedWind + 'å®¶' + (newDealer === 0 ? '(ä½ )' : '');
    log(`ğŸ” èŠå®¶è¼ªæ›¿è‡³${rotatedName}`);
  }

  // Update dealerStreak: if the dealer remains the same as the previous hand, increment
  // the streak. Otherwise reset it. This logic should run before S is reset below.
  if (isFirstGame || !S) {
    // Starting a new game: no consecutive dealer from a previous hand.
    dealerStreak = 0;
  } else {
    if (newDealer === S.dealer) {
      dealerStreak = (dealerStreak || 0) + 1;
    } else {
      dealerStreak = 0;
    }
  }
  
  S = {
    wall: shuffle(generateTiles()),
    deadWall: [],
    players: Array.from({ length: 4 }, (_, i) => ({
      hand: [],
      discards: [],
      flowers: [],
      melds: [],
      points: prevNames ? S.players[i].points : RULES.initialPoints,
      declaredListen: false,
      waitKeys: [],
      tianTing: false,
      diTing: false,
      isAI: i !== 0,
      rinshan: false
    })),
    goldKeys: [],
    kongCount: 0, // æ§“ç‰Œæ¬¡æ•¸ï¼Œæ¯æ§“ä¸€æ¬¡æµ·åº•å¤šä¿ç•™ï¼‘å¼µ
    rules: clone(RULES),
    turn: newDealer,
    dealer: newDealer,
    round: newRound,
    // è¨˜éŒ„åˆå§‹èŠå®¶ï¼ˆç¬¬ä¸€å±€æ™‚çš„èŠå®¶ï¼‰ï¼Œç”¨æ–¼åˆ¤æ–·ä½•æ™‚é€²å…¥ä¸‹ä¸€åœˆ
    initialDealer: (isFirstGame || !S) ? newDealer : (S.initialDealer ?? newDealer),
    // Record the current dealer streak in the game state so the UI can display it.
    dealerStreak: dealerStreak,
    lastDiscard: null,
    waitReact: null,
    winner: null,
    fromPlayer: null,
    winTile: null,
    phase: 'deal',
    remain: 0,
    // æ‘¸ç‰Œæ¬¡æ•¸ï¼Œç”¨æ–¼åˆ¤æ–·åœ°è½/å¤©è½
    drawCount: 0,
    // æ˜¯å¦å·²æœ‰ç©å®¶åšå‡ºæ˜åƒç¢°æ§“ï¼Œè‹¥æœ‰å‰‡åœ°è½ä¸å†æˆç«‹
    anyOpenMeld: false,
    robKong: false,
    // ç”¨æ–¼åˆ¤æ–·æ‘¸ç‰Œé‚è¼¯ï¼šç´€éŒ„ä¸Šä¸€å€‹å‹•ä½œåŠå…¶åŸ·è¡Œè€…
    lastAction: null,
    lastActor: null,
    names: prevNames || randomNames
  };
  // Keep player names generated at the start of the game to the new game state.
  // randomNames is set during the first game and reused for subsequent hands. If not yet generated, fallback to previous S.names.
  // è‹¥ randomNames å°šæœªç”¢ç”Ÿï¼Œä¸” prevNames å­˜åœ¨ï¼Œæ²¿ç”¨ prevNames
  if (!randomNames && prevNames) {
    randomNames = prevNames;
  }
  // è¨­ç½®æ–°çš„ S.namesï¼šè‹¥å·²æœ‰ randomNamesï¼Œæ¡ç”¨å…¶å€¼ï¼›å¦å‰‡ä½¿ç”¨ prevNames
  S.names = randomNames ? randomNames.slice() : (prevNames ? prevNames.slice() : []);
  S.rules.gold.enabled = useGold;

  dealTiles();
  if (S.rules.gold.enabled) initGoldTiles();
  S.phase = 'play';
  S.remain = S.wall.length;
  renderAll();
  
  const dealerWind = seatNames?.[S.dealer] || ['æ±', 'å—', 'è¥¿', 'åŒ—'][S.dealer];
  const dealerName = dealerWind + 'å®¶' + (S.dealer === 0 ? '(ä½ )' : '');
  const roundName = ['æ±', 'å—', 'è¥¿', 'åŒ—'][newRound - 1];
  log(`ğŸ® ç¬¬${newRound}åœˆ ${roundName}é¢¨ï¼ŒèŠå®¶ï¼š${dealerName}${S.rules.gold.enabled ? 'ï¼Œå•Ÿç”¨é‡‘ç‰Œ' : ''}`);
  
  if (S.dealer === 0) {
    log(`ğŸ‘‰ èŠå®¶æŒæœ‰17å¼µç‰Œï¼Œè«‹ç›´æ¥å‡ºç‰Œ`);
  } else {
    log(`â³ AIèŠå®¶é–‹å§‹å‡ºç‰Œ...`);
    setTimeout(stepAI, 1000 + Math.random() * 1000);  // 1-2ç§’éš¨æ©Ÿå»¶é²
  }
}

function dealTiles() {
  const dead = 16; // æµ·åº•ç‰Œ16å¼µ
  // ç™¼ç‰Œï¼šèŠå®¶ï¼ˆdealerï¼Œå›ºå®šç‚º0ï¼‰ç™¼17å¼µï¼Œå…¶ä»–ç©å®¶ç™¼16å¼µ
  while (S.wall.length > dead && S.players[0].hand.length < 16) {
    for (let p = 0; p < 4; p++) {
      if (S.wall.length > dead) {
        S.players[p].hand.push(S.wall.pop());
      }
    }
  }
  // èŠå®¶å¤šæ‘¸ä¸€å¼µï¼ˆ17å¼µï¼‰
  if (S.wall.length > dead) {
    S.players[S.dealer].hand.push(S.wall.pop());
  }
  
  // è¨­å®šç‹ç‰Œå€ï¼šå¾ç‰Œå±±å°¾ç«¯å–æœ€å¾16å¼µä½œç‚ºç‹ç‰Œ
  const deadWallSize = Math.min(dead, S.wall.length);
  S.deadWall = S.wall.splice(-deadWallSize, deadWallSize);
}

// èŠ±ç‰Œè™•ç†å‡½æ•¸å·²å®Œå…¨ç§»é™¤

function processFlowersInHand_DELETED(p) {
  const pl = S.players[p];
  let hasFlower = true;
  
  while (hasFlower) {
    hasFlower = false;
    for (let i = pl.hand.length - 1; i >= 0; i--) {
      if (pl.hand[i].suit === SUIT_H) {
        const flower = pl.hand.splice(i, 1)[0];
        pl.flowers.push(flower);
        log(`ğŸŒ¸ ${playerName(p)} æ‹¿åˆ°èŠ±ï¼ˆ${keyToText(tileKey(flower))}ï¼‰ï¼Œå¾ç‹ç‰Œè£œç‰Œ`);
        
        // å¾ç‹ç‰Œå°¾ç«¯è£œç‰Œ
        if (S.deadWall.length > 0) {
          const newTile = S.deadWall.pop();
          if (newTile.suit === SUIT_H) {
            // è£œåˆ°çš„ä¹Ÿæ˜¯èŠ±ç‰Œï¼Œç¹¼çºŒè™•ç†
            pl.flowers.push(newTile);
            log(`ğŸŒ¸ ${playerName(p)} è£œç‰Œåˆæ‘¸åˆ°èŠ±ï¼ˆ${keyToText(tileKey(newTile))}ï¼‰ï¼Œå†è£œç‰Œ`);
            hasFlower = true;
          } else {
            pl.hand.push(newTile);
          }
        } else if (S.wall.length > 0) {
          // ç‹ç‰Œç”¨å®Œï¼Œå¾ç‰Œå±±è£œ
          const newTile = S.wall.pop();
          if (newTile.suit === SUIT_H) {
            pl.flowers.push(newTile);
            log(`ğŸŒ¸ ${playerName(p)} è£œç‰Œåˆæ‘¸åˆ°èŠ±ï¼ˆ${keyToText(tileKey(newTile))}ï¼‰ï¼Œå†è£œç‰Œ`);
            hasFlower = true;
          } else {
            pl.hand.push(newTile);
          }
        }
        hasFlower = true;
        break;
      }
    }
  }
}

function drawTile(p) {
  // æª¢æŸ¥æ˜¯å¦åˆ°é”æµ·åº•ï¼š16å¼µ + æ§“ç‰Œæ¬¡æ•¸
  const deadWallLimit = 16 + S.kongCount;
  if (S.wall.length <= 0) {
    log(`ğŸš« ç‰Œå±±æ¯ç«­ï¼ˆå‰©é¤˜${S.deadWall.length}å¼µæµ·åº•ç‰Œï¼‰ï¼Œæµå±€`);
    S.phase = 'end';
    S.winner = null;
    renderAll();
    // é¡¯ç¤ºæ‰€æœ‰ç©å®¶æ‰‹ç‰Œå’Œç¹¼çºŒæŒ‰éˆ•
    setTimeout(() => showHandsAndContinue(), 1000);
    return;
  }
  // éæ§“è£œç‰Œæ‘¸ç‰Œå‰ï¼Œé‡ç½®æ§“ä¸Šé–‹èŠ±æ——æ¨™
  const pl = S.players[p];
  pl.rinshan = false;
  const t = S.wall.pop();
  // è¨˜éŒ„æ‘¸ç‰Œæ¬¡æ•¸ï¼šåƒ…è¨ˆç®—å¾ç‰Œå±±æ‘¸ç‰Œï¼Œä¸å«è£œç‹ç‰Œ
  S.drawCount++;
  if (false) { // èŠ±ç‰Œè™•ç†å·²ç§»é™¤
    pl.flowers.push(t);
    log(`ğŸŒ¸ ${playerName(p)} æ‘¸åˆ°èŠ±ï¼ˆ${keyToText(tileKey(t))}ï¼‰ï¼Œå¾ç‹ç‰Œè£œç‰Œ`);
    renderAll();
    // æ‘¸åˆ°èŠ±ç‰Œï¼Œå¾ç‹ç‰Œè£œç‰Œ
    if (S.deadWall.length > 0) {
      constè¡¥ç‰Œ = S.deadWall.pop();
      if (è¡¥ç‰Œ.suit === SUIT_H) {
        // è£œåˆ°çš„ä¹Ÿæ˜¯èŠ±ç‰Œ
        pl.flowers.push(è¡¥ç‰Œ);
        log(`ğŸŒ¸ ${playerName(p)} è£œç‰Œåˆæ‘¸åˆ°èŠ±ï¼ˆ${keyToText(tileKey(è¡¥ç‰Œ))}ï¼‰ï¼Œå†å¾ç‹ç‰Œè£œç‰Œ`);
        renderAll();
        drawFlowerReplacement(p);
      } else {
        pl.hand.push(è¡¥ç‰Œ);
        S.remain = S.wall.length;
        renderAll();
      }
    } else {
      // ç‹ç‰Œç”¨å®Œï¼Œå¾ç‰Œå±±è£œ
      drawFlowerReplacement(p);
    }
    return;
  }
  pl.hand.push(t);
  // è¨˜éŒ„å‰›æ‘¸é€²çš„ç‰Œï¼Œæ–¹ä¾¿è½ç‰Œå¾Œé™åˆ¶åªèƒ½æ‰“è©²å¼µ
  pl.drawnTile = t;
  S.remain = S.wall.length;
  // æ‘¸ç‰ŒéŸ³æ•ˆ
  playSound(600, 0.1, 'sine');

  // è‹¥æ˜¯ç©å®¶æ‘¸ç‰Œï¼Œå°‡æ‘¸åˆ°çš„ç‰Œè¨˜éŒ„åˆ°æˆ°æ³
  if (p === 0) {
    // è¨˜éŒ„ç©å®¶æ‘¸åˆ°çš„ç‰Œè³‡è¨Šï¼Œåªåœ¨ç©å®¶å›åˆé¡¯ç¤º
    const k = tileKey(t);
    log(`ğŸ¤² ä½ æ‘¸åˆ° ${keyToText(k)}`);
  }

  // æ›´æ–°æœ€å¾Œå‹•ä½œèˆ‡åŸ·è¡Œè€…ï¼Œæ–¹ä¾¿ä¹‹å¾Œåˆ¤æ–·æ˜¯å¦éœ€è¦å†æ‘¸ç‰Œ
  S.lastAction = 'draw';
  S.lastActor = p;
}

function drawFlowerReplacement_DELETED(p) {
  // éè¿´è£œèŠ±ç‰Œ
  if (!S.wall.length && !S.deadWall.length) {
    log('âš ï¸ ç„¡ç‰Œå¯è£œ');
    renderAll();
    return;
  }
  
  const pl = S.players[p];
  let tile;
  
  if (S.deadWall.length > 0) {
    tile = S.deadWall.pop();
  } else if (S.wall.length > 0) {
    tile = S.wall.pop();
  } else {
    renderAll();
    return;
  }
  
  if (tile.suit === SUIT_H) {
    pl.flowers.push(tile);
    log(`ğŸŒ¸ ${playerName(p)} è£œç‰Œåˆæ‘¸åˆ°èŠ±ï¼ˆ${keyToText(tileKey(tile))}ï¼‰ï¼Œç¹¼çºŒè£œç‰Œ`);
    renderAll();
    drawFlowerReplacement(p);
  } else {
    pl.hand.push(tile);
    S.remain = S.wall.length;
    renderAll();
  }
}

function initGoldTiles() {
  const candidates = [];
  for (let r = 1; r <= 9; r++) {
    candidates.push('W' + r, 'T' + r, 'B' + r);
  }
  WINDS.forEach(n => candidates.push('F' + n));
  DRAGONS.forEach(n => candidates.push('D' + n));
  while (S.goldKeys.length < 3) {
    const k = candidates[rng(candidates.length)];
    if (!S.goldKeys.includes(k)) S.goldKeys.push(k);
  }
}

function playerName(i) {
  // å›å‚³ç©å®¶åç¨±ï¼šå„ªå…ˆä½¿ç”¨éš¨æ©Ÿç”Ÿæˆçš„ä¸­æ–‡åç¨±ï¼Œè‹¥æœªè¨­å®šå‰‡ä½¿ç”¨é¢¨ä½å
  const name = (S && S.names && S.names[i]) ? S.names[i] : (seatNames?.[i] || ['æ±', 'å—', 'è¥¿', 'åŒ—'][i]);
  return name + (i === 0 ? '(ä½ )' : '');
}

// è¨ˆç®—ç©å®¶å·²ç¶“å½¢æˆçš„æ§“çµ„æ•¸
function countKongs(pl) {
  return pl.melds.filter(m => m.type === 'kong').length;
}

// æª¢æŸ¥ä¸¦è¨­å®šå¤©è½/åœ°è½ç‹€æ…‹ã€‚ç•¶ç©å®¶å®£å‘Šè½ç‰Œæ™‚èª¿ç”¨ã€‚
// å¤©è½ï¼šèŠå®¶æ‘¸å®Œç¬¬ä¸€å¼µç‰Œæ‰“å‡ºå¾Œå³è™•æ–¼è½ç‰Œï¼Œä¸”ç„¡å…¶ä»–æ˜åƒç¢°æ§“ï¼›åœ°è½ï¼šèµ·ç‰Œå¾Œæµ·åº•æ‰“é€²8å¼µç‰Œå…§ä¸”å››å®¶çš†æœªåƒç¢°ï¼Œå®£å‘Šè½ç‰Œã€‚
function updateTianDiTing(pid) {
  const pl = S.players[pid];
  // å·²æœ‰é–‹æ˜ç‰Œå‰‡ä¸è¨ˆå¤©è½/åœ°è½
  if (S.anyOpenMeld) return;
  // å¤©è½åƒ…é©ç”¨æ–¼èŠå®¶ç¬¬ä¸€è¼ªæ‘¸æ‰“çµæŸå¾Œå³è½ç‰Œ
  if (pid === S.dealer && S.drawCount === 1) {
    pl.tianTing = true;
    return;
  }
  // åœ°è½ï¼šå‰8æ¬¡æ‘¸ç‰Œå…§
  if (S.drawCount <= 8) {
    pl.diTing = true;
  }
}

/* ========= èƒ¡ç‰Œåˆ¤å®š ========= */
function isWinningNow(hand, melds, winTile) {
  const tiles = hand.slice().sort((a, b) => tileSortKey(a) - tileSortKey(b));
  // è‹¥æ²’æœ‰ä»»ä½•å‰¯éœ²ï¼Œä¸”æ‰‹ç‰Œé•·åº¦ç‚º16å¼µï¼Œå¯æª¢æŸ¥ä¸ƒå°
  if (melds.length === 0 && isSevenPairs(tiles)) return true;
  // åœ¨ 16 å¼µéº»å°‡ä¸­ï¼Œä¸€æ‰‹ç‰Œç”± 5 çµ„é¢å­å’Œä¸€å°å°‡ç‰Œçµ„æˆï¼ˆç¸½è¨ˆ 17 å¼µï¼‰ã€‚
  // æ¯å€‹é¢å­å¯ç‚ºé †å­ã€åˆ»å­æˆ–æ§“ï¼›å‰¯éœ²æ•¸é‡ä»£è¡¨å·²ç¶“å®Œæˆçš„çµ„æ•¸ã€‚
  // å°šéœ€å®Œæˆçš„çµ„æ•¸ = 5 - å‰¯éœ²æ•¸ï¼ˆè‡³å°‘ 0ï¼‰ã€‚
  const neededSets = Math.max(0, 5 - melds.length);
  return canStandardWin(tiles, neededSets);
}

// æª¢æŸ¥æ˜¯å¦è½ç‰Œï¼ˆåªå·®ä¸€å¼µç‰Œå°±èƒ½èƒ¡ï¼‰
function isListening(hand, melds) {
  // æª¢æŸ¥æ˜¯å¦åªå·®ä¸€å¼µç‰Œå°±èƒ½èƒ¡
  // éæ­·æ‰€æœ‰å¯èƒ½çš„ç‰Œï¼Œçœ‹æ˜¯å¦èƒ½èƒ¡
  const allPossibleTiles = [];
  for (let suit of [SUIT_W, SUIT_T, SUIT_B]) {
    for (let rank = 1; rank <= 9; rank++) {
      allPossibleTiles.push({ suit, rank, id: -1 });
    }
  }
  WINDS.forEach(name => allPossibleTiles.push({ suit: SUIT_F, name, id: -1 }));
  DRAGONS.forEach(name => allPossibleTiles.push({ suit: SUIT_D, name, id: -1 }));
  
  return allPossibleTiles.some(tile => {
    const testHand = hand.concat([tile]);
    return isWinningNow(testHand, melds, tile);
  });
}

// è¨ˆç®—è½ç‰Œæ™‚å¯ä»¥èƒ¡å“ªäº›ç‰Œ
// çµ¦å®šç›®å‰æ‰‹ç‰Œèˆ‡å‰¯éœ²ï¼Œå›å‚³ä¸€å€‹ç‰ŒKeyé™£åˆ—ï¼Œè¡¨ç¤ºå“ªäº›ç‰Œèƒ½è®“æ‰‹ç‰Œèƒ¡ç‰Œ
function calcWaitingTiles(hand, melds) {
  const waits = [];
  // å»ºç«‹æ‰€æœ‰å¯èƒ½çš„ç‰Œæ¨£ï¼ˆ1-9ç´¢ç­’è¬ã€æ±å—è¥¿åŒ—ã€ç´…ä¸­ç™¼ç™½ï¼‰
  const allPossibleTiles = [];
  for (let suit of [SUIT_W, SUIT_T, SUIT_B]) {
    for (let rank = 1; rank <= 9; rank++) {
      allPossibleTiles.push({ suit, rank, id: -1 });
    }
  }
  WINDS.forEach(name => allPossibleTiles.push({ suit: SUIT_F, name, id: -1 }));
  DRAGONS.forEach(name => allPossibleTiles.push({ suit: SUIT_D, name, id: -1 }));
  const seen = new Set();
  allPossibleTiles.forEach(tile => {
    // æ¸¬è©¦æ‰‹ç‰ŒåŠ ä¸Šæ­¤ç‰Œæ˜¯å¦èƒ½èƒ¡ç‰Œ
    const testHand = hand.concat([tile]);
    if (isWinningNow(testHand, melds, tile)) {
      const k = tileKey(tile);
      if (!seen.has(k)) {
        waits.push(k);
        seen.add(k);
      }
    }
  });
  // ä¾ç…§ç‰Œæ’åºå‡½å¼æ’åº
  waits.sort((a, b) => {
    // è§£æç‰Œ key ç‚ºç‰Œç‰©ä»¶ï¼Œä»¥ä¾¿ä½¿ç”¨ tileSortKey é€²è¡Œæ’åº
    const parseKey = (k) => {
      const s = k[0];
      const v = k.slice(1);
      if (s === SUIT_W || s === SUIT_T || s === SUIT_B) {
        return { suit: s, rank: parseInt(v), id: -1 };
      }
      if (s === SUIT_F || s === SUIT_D) {
        return { suit: s, name: v, id: -1 };
      }
      return { suit: s, id: -1 };
    };
    const ta = parseKey(a);
    const tb = parseKey(b);
    return tileSortKey(ta) - tileSortKey(tb);
  });
  return waits;
}

function isSevenPairs(tiles) {
  if (tiles.length !== 16) return false;
  const m = countByKey(tiles);
  const vals = Object.values(m);
  return vals.filter(x => x === 2).length === 8 && vals.every(x => x === 2 || x === 0);
}

function canStandardWin(tiles, need = 5) {
  const counts = countByKey(tiles);
  for (const k in counts) {
    if (counts[k] >= 2) {
      counts[k] -= 2;
      if (canSplitMelds(counts, need)) return true;
      counts[k] += 2;
    }
  }
  return false;
}

function canSplitMelds(counts, need) {
  if (need === 0) return Object.values(counts).every(v => v === 0);
  let first = null;
  for (const k in counts) {
    if (counts[k] > 0) {
      first = k;
      break;
    }
  }
  if (!first) return need === 0;
  
  if (counts[first] >= 3) {
    counts[first] -= 3;
    if (canSplitMelds(counts, need - 1)) return true;
    counts[first] += 3;
  }
  
  const s = first[0];
  const v = parseInt(first.slice(1));
  if ((s === SUIT_W || s === SUIT_T || s === SUIT_B) && v <= 7) {
    const k2 = s + (v + 1), k3 = s + (v + 2);
    if ((counts[k2] || 0) > 0 && (counts[k3] || 0) > 0) {
      counts[first]--;
      counts[k2]--;
      counts[k3]--;
      if (canSplitMelds(counts, need - 1)) return true;
      counts[first]++;
      counts[k2]++;
      counts[k3]++;
    }
  }
  return false;
}

function countByKey(tiles) {
  const m = {};
  for (const t of tiles) {
    const k = tileKey(t);
    m[k] = (m[k] || 0) + 1;
  }
  return m;
}

function tileSortKey(t) {
  const order = { W: 0, T: 1, B: 2, F: 3, D: 4, H: 5 };
  const o = order[t.suit];
  const v = (t.suit === SUIT_W || t.suit === SUIT_T || t.suit === SUIT_B) ? t.rank : ({ E: 1, S: 2, W: 3, N: 4, C: 5, F: 6, B: 7 }[t.name] || 0);
  return o * 100 + v;
}

/* ========= AI é‚è¼¯ ========= */
function shantenAfterRemove(hand) {
  function approxShanten14(tiles) {
    if (isWinningNow(tiles, [], null)) return 0;
    const m = countByKey(tiles);
    let pairs = 0, triples = 0, singles = 0;
    for (const k in m) {
      const c = m[k];
      if (c >= 3) triples++;
      else if (c === 2) pairs++;
      else singles++;
    }
    let est = Math.max(0, 5 - (pairs + triples));
    est += Math.ceil(singles / 4) * 0.5;
    return est;
  }
  
  let best = 99;
  const n = hand.length;
  for (let i = 0; i < n; i++) {
    const take = hand.filter((_, k) => k !== i);
    best = Math.min(best, approxShanten14(take));
  }
  
  const m = countByKey(hand);
  let pairs = 0;
  for (const k in m) {
    pairs += Math.floor(m[k] / 2);
  }
  const sevenNeed = Math.max(0, 8 - pairs);
  return Math.min(best, sevenNeed);
}

function aiChooseDiscard(pid) {
  const me = S.players[pid];
  const visible = [];
  S.players.forEach(p => visible.push(...p.discards, ...p.flowers));
  
  // æª¢æŸ¥å…¶ä»–ç©å®¶æ˜¯å¦å·²è½ç‰Œ
  const listeningPlayers = [];
  for (let i = 0; i < 4; i++) {
    if (i !== pid && S.players[i].declaredListen) {
      listeningPlayers.push(i);
    }
  }
  
  // åŠ å¼· AIï¼šå„ªå…ˆè½ç‰Œï¼Œé¿å…æ”¾ç‚®ï¼Œæ›´ç²¾æº–çš„å‡ºç‰Œåˆ¤æ–·
  let cands = me.hand.map(t => {
    const after = me.hand.filter(x => x !== t);
    const sh = shantenAfterRemove(after);
    let risk = riskOf(t);
    let waitCount = 0;
    let maxWaitTiles = 0;  // æ¯ç¨®ç­‰ç‰Œçš„å‰©é¤˜å¼µæ•¸
    
    // æª¢æŸ¥æ˜¯å¦æœƒæ”¾ç‚®ï¼šå¦‚æœæœ‰ç©å®¶å·²è½ç‰Œï¼Œæª¢æŸ¥é€™å¼µç‰Œæ˜¯å¦æœƒè®“ä»–å€‘èƒ¡ç‰Œ
    let dangerLevel = 0;
    if (listeningPlayers.length > 0) {
      listeningPlayers.forEach(lp => {
        if (canWinOn(lp, t)) {
          dangerLevel += 1000;  // æ¥µé«˜é¢¨éšªï¼Œæœƒæ”¾ç‚®
        }
      });
    }
    
    // å¢åŠ é¢¨éšªè©•ä¼°ï¼šæª¢æŸ¥å…¶ä»–ç©å®¶æ˜¯å¦æ‰“éé¡ä¼¼çš„ç‰Œ
    const tileKey_t = tileKey(t);
    const discardedSimilar = visible.filter(vt => {
      const vk = tileKey(vt);
      // æª¢æŸ¥æ˜¯å¦æ˜¯ç›¸åŒçš„ç‰Œ
      if (vk === tileKey_t) return true;
      // æª¢æŸ¥æ˜¯å¦æ˜¯ç›¸é„°çš„ç‰Œï¼ˆå¢åŠ é¢¨éšªï¼‰
      if (t.suit === 'W' || t.suit === 'T' || t.suit === 'B') {
        const vt_tile = keyToTile(vk);
        if (vt_tile.suit === t.suit && Math.abs(vt_tile.rank - t.rank) <= 1) {
          return true;
        }
      }
      return false;
    }).length;
    
    // å¦‚æœå…¶ä»–ç©å®¶æ‰“éé¡ä¼¼çš„ç‰Œï¼Œé¢¨éšªé™ä½
    if (discardedSimilar > 0) {
      risk *= 0.5;  // é™ä½é¢¨éšª
    }
    
    if (isListening(after, me.melds)) {
      const waits = calcWaitingTiles(after, me.melds);
      waitCount = waits.length;
      // è¨ˆç®—æ¯ç¨®ç­‰ç‰Œçš„å‰©é¤˜å¼µæ•¸
      waits.forEach(wk => {
        const total = 4;
        const used = visible.filter(vt => tileKey(vt) === wk).length;
        const remain = total - used;
        maxWaitTiles += remain;
      });
    }
    
    // è¨ˆç®—æ‰“å‡ºé€™å¼µç‰Œå¾Œçš„æ‰‹ç‰Œçµæ§‹å„ªåŠ£
    const m = countByKey(after);
    let pairs = 0, triples = 0, isolated = 0, sequences = 0;
    const keys = Object.keys(m);
    
    keys.forEach(k => {
      const c = m[k];
      if (c >= 3) triples++;
      else if (c === 2) pairs++;
      else if (c === 1) {
        // æª¢æŸ¥æ˜¯å¦å­¤ç«‹ç‰Œï¼ˆæ²’æœ‰é€£æ¥ï¼‰
        const tile = keyToTile(k);
        if (tile.suit === 'W' || tile.suit === 'T' || tile.suit === 'B') {
          const rank = tile.rank;
          const hasLeft = m[`${tile.suit}${rank-1}`] || m[`${tile.suit}${rank-2}`];
          const hasRight = m[`${tile.suit}${rank+1}`] || m[`${tile.suit}${rank+2}`];
          if (!hasLeft && !hasRight) isolated++;
          else sequences++;
        } else {
          isolated++;  // å­—ç‰Œå–®å¼µè¦–ç‚ºå­¤ç«‹
        }
      }
    });
    
    // å„ªåŒ–è©•åˆ†ï¼šæ¸›å°‘å°å­æ¬Šé‡ï¼Œæé«˜é †å­å’Œåˆ»å­æ¬Šé‡
    const structureScore = (triples * 80) + (sequences * 60) + (pairs * 20) - (isolated * 40);
    
    // åŠ å¼·ç­–ç•¥ï¼šå¤§å¹…æé«˜è½ç‰Œæ¬Šé‡ï¼Œè€ƒæ…®å‰©é¤˜ç‰Œæ•¸ï¼Œå¤§å¹…é™ä½æ”¾ç‚®é¢¨éšªï¼ŒåŠ å…¥çµæ§‹è©•åˆ†
    const score = (waitCount * 500) + (maxWaitTiles * 50) - (sh * 30) - (risk * 5) - dangerLevel + structureScore;
    return { tile: t, score };
  });
  
  cands.sort((a, b) => b.score - a.score);
  return cands[0].tile;
}

function riskOf(tile) {
  if (tile.suit === SUIT_F || tile.suit === SUIT_D) return 0.4;
  if (tile.rank === 1 || tile.rank === 9) return 0.65;
  return 1.0;
}

function keyToTile(k) {
  const s = k[0], v = k.slice(1);
  if (s === 'W' || s === 'T' || s === 'B') return { suit: s, rank: parseInt(v), id: -1 };
  if (s === 'F') return { suit: SUIT_F, name: v, id: -1 };
  if (s === 'D') return { suit: SUIT_D, name: v, id: -1 };
  return { suit: '?', id: -1 };
}

/* ========= åƒç‰Œã€ç¢°ç‰Œèˆ‡æ§“ç‰Œé‚è¼¯ ========= */

// åƒç‰Œï¼šåªèƒ½åƒä¸Šå®¶çš„ç‰Œï¼Œä¸”åªèƒ½åƒæ•¸å­—ç‰Œï¼ˆè¬ç­’æ¢ï¼‰
function canChow(pid, tile) {
  const pl = S.players[pid];
  const k = tileKey(tile);

  // æœ€å¤šå…è¨±5çµ„å‰¯éœ²ï¼ˆ16å¼µéº»å°‡éœ€è¦ 5 çµ„é¢å­ï¼‹1 å°å°‡ç‰Œï¼‰
  if (pl.melds.length >= 5) return [];
  
  // åªèƒ½åƒä¸Šå®¶çš„ç‰Œï¼šåƒ…ä¸‹ä¸€å®¶å¯ä»¥åƒï¼ˆæŒ‰ç…§é †æ™‚é‡é †åºï¼‰
  // é †æ™‚é‡é †åºï¼š0(ä¸‹) -> 3(å³) -> 1(ä¸Š) -> 2(å·¦)
  // ç•¶å‰ S.turn ç‚ºæ‰“ç‰Œè€…ï¼Œåªæœ‰ä¸‹å®¶å¯ä»¥åƒ
  const clockwiseOrder = [0, 3, 1, 2];
  const currentIndex = clockwiseOrder.indexOf(S.turn);
  const nextPlayer = clockwiseOrder[(currentIndex + 1) % 4];
  if (pid !== nextPlayer) return [];
  
  // åªèƒ½åƒæ•¸å­—ç‰Œ
  if (tile.suit !== SUIT_W && tile.suit !== SUIT_T && tile.suit !== SUIT_B) return [];
  
  const rank = tile.rank;
  const suit = tile.suit;
  const patterns = [];
  
  // æª¢æŸ¥ä¸‰ç¨®åƒç‰Œå‹æ…‹ï¼šä¸Šåƒã€ä¸­åƒã€ä¸‹åƒ
  // ä¸Šåƒï¼šåƒçš„ç‰Œ + å¾Œé¢å…©å¼µ (ä¾‹ï¼šåƒ 1ï¼Œæ‰‹ç‰Œæœ‰ 2,3)
  if (rank <= 7) {
    const has1 = pl.hand.some(t => t.suit === suit && t.rank === rank + 1);
    const has2 = pl.hand.some(t => t.suit === suit && t.rank === rank + 2);
    if (has1 && has2) patterns.push([rank, rank + 1, rank + 2]);
  }
  
  // ä¸­åƒï¼šåƒçš„ç‰Œåœ¨ä¸­é–“ (ä¾‹ï¼šåƒ 2ï¼Œæ‰‹ç‰Œæœ‰ 1,3)
  if (rank >= 2 && rank <= 8) {
    const has1 = pl.hand.some(t => t.suit === suit && t.rank === rank - 1);
    const has2 = pl.hand.some(t => t.suit === suit && t.rank === rank + 1);
    if (has1 && has2) patterns.push([rank - 1, rank, rank + 1]);
  }
  
  // ä¸‹åƒï¼šåƒçš„ç‰Œ + å‰é¢å…©å¼µ (ä¾‹ï¼šåƒ 3ï¼Œæ‰‹ç‰Œæœ‰ 1,2)
  if (rank >= 3) {
    const has1 = pl.hand.some(t => t.suit === suit && t.rank === rank - 2);
    const has2 = pl.hand.some(t => t.suit === suit && t.rank === rank - 1);
    if (has1 && has2) patterns.push([rank - 2, rank - 1, rank]);
  }
  
  return patterns;
}

function doChow(pid, tile, pattern) {
  const pl = S.players[pid];
  const suit = tile.suit;
  const tiles = [tile];
  
  // å¾æ‰‹ç‰Œä¸­ç§»é™¤å°æ‡‰çš„ç‰Œ
  pattern.forEach(rank => {
    if (rank !== tile.rank) {
      const idx = pl.hand.findIndex(t => t.suit === suit && t.rank === rank);
      if (idx >= 0) {
        tiles.push(pl.hand.splice(idx, 1)[0]);
      }
    }
  });
  
  // æ’åºç‰Œçµ„
  tiles.sort((a, b) => a.rank - b.rank);
  
  // ç´€éŒ„åƒçš„ä¸­å¿ƒç‰Œç´¢å¼•ï¼šåƒçš„ç‰Œåœ¨æ’åºå¾Œçš„ä½ç½®
  const centerIdx = tiles.findIndex(t => t === tile);
  pl.melds.push({ type: 'chow', tiles, centerIdx });
  // åƒç‰Œå±¬æ–¼æ˜ç‰Œ
  S.anyOpenMeld = true;
  log(`ğŸœ ${playerName(pid)} åƒäº† ${tiles.map(t => keyToText(tileKey(t))).join(' ')}`);
  // åƒç‰Œç‰¹æ•ˆèˆ‡éŸ³æ•ˆï¼ˆæ‰€æœ‰ç©å®¶ï¼‰
  showEffect('ğŸœ åƒ', '#8BC34A');
  playSound(500, 0.2, 'triangle');
  
  S.turn = pid;
  S.lastDiscard = null;
  S.waitReact = null;
  hideReactionPanel();
  renderAll();

  // å¦‚æœæ˜¯ç©å®¶åƒç‰Œï¼Œæª¢æŸ¥æ˜¯å¦å¯å ±è½ï¼ˆåƒç‰Œå¾Œç¸½ç‰Œæ•¸ç‚º17 + æ§“æ•¸ï¼‰
  if (pid === 0) {
    const me = S.players[0];
    if (!me.declaredListen) {
      const kongCount = countKongs(me);
      const totalTiles = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
      const expectedFull = 17 + kongCount;
      if (totalTiles === expectedFull) {
        const canListenNow = me.hand.some(tile2 => {
          const testHand = me.hand.filter(t => t !== tile2);
          return isListening(testHand, me.melds);
        });
        // ä¸åœ¨åƒç‰Œå¾Œç«‹å³å½ˆå‡ºå ±è½é¢æ¿ï¼›æ–¼ä¸Ÿç‰Œå®Œæˆå¾Œå¦è¡Œæç¤º
      }
    }
  }

  // æ›´æ–°æœ€å¾Œå‹•ä½œèˆ‡åŸ·è¡Œè€…ï¼šåƒç‰Œå¾Œä¸‹ä¸€æ­¥æ‡‰å‡ºç‰Œï¼Œä¸å†æ‘¸ç‰Œ
  S.lastAction = 'chow';
  S.lastActor = pid;
}

function canPong(pid, tile) {
  const pl = S.players[pid];

  // è‹¥å·²ç¶“æœ‰5çµ„å‰¯éœ²ï¼Œå‰‡ä¸å…è¨±å†ç¢°
  if (pl.melds.length >= 5) return false;
  const k = tileKey(tile);
  const cnt = pl.hand.filter(t => tileKey(t) === k).length;
  return cnt >= 2;
}

function canKong(pid, tile) {
  const pl = S.players[pid];
  // ä¸å…è¨±åŒä¸€å®¶æ“æœ‰è¶…éä¸‰å€‹æ§“
  if (countKongs(pl) >= 3) return false;

  // è‹¥å·²æœ‰5çµ„å‰¯éœ²ï¼Œå‰‡ä¸å¯å†æ§“ï¼ˆæ–°æ§“æœƒå¢åŠ ä¸€å‰¯éœ²ï¼‰
  if (pl.melds.length >= 5) return false;
  const k = tileKey(tile);
  const cnt = pl.hand.filter(t => tileKey(t) === k).length;
  return cnt >= 3;
}

// æª¢æŸ¥æ˜¯å¦å¯ä»¥é€²è¡Œæš—æ§“ï¼šæ‰‹ç‰Œä¸­æœ‰å››å¼µç›¸åŒç‰Œ
function canConcealedKong(pid) {
  const pl = S.players[pid];
  // ç•¶å‰æ§“æ•¸å·²é”ä¸Šé™3çµ„æ™‚ï¼Œä¸å…è¨±å†æš—æ§“
  if (countKongs(pl) >= 3) return [];

  // è‹¥å·²æœ‰5çµ„å‰¯éœ²ï¼Œå‰‡ä¸å…è¨±å†æš—æ§“ï¼ˆæ–°æš—æ§“æœƒå¢åŠ ä¸€å‰¯éœ²ï¼‰
  if (pl.melds.length >= 5) return [];
  // ä¸å…è¨±åœ¨å‰©é¤˜ç‰Œæ•¸éå°‘æ™‚æš—æ§“ï¼šè‹¥ç‰Œç‰†+ç‹ç‰Œå‰©é¤˜3å¼µæˆ–æ›´å°‘ï¼Œç¦æ­¢æš—æ§“
  if ((S.wall.length + S.deadWall.length) <= 3) return [];
  const counts = countByKey(pl.hand);
  return Object.keys(counts).filter(k => counts[k] >= 4);
}

// æª¢æŸ¥æ˜¯å¦å¯ä»¥åŠ æ§“ï¼šå·²ç¢°çš„ç‰Œä¸­è‹¥æœ‰3å¼µç›¸åŒï¼Œä¸”æ‰‹ç‰Œè£¡é‚„æœ‰ç¬¬4å¼µ
function canAddedKong(pid) {
  const pl = S.players[pid];
  const res = [];
  // ä¸å…è¨±åœ¨å‰©é¤˜ç‰Œæ•¸éå°‘æ™‚åŠ æ§“ï¼šè‹¥ç‰Œç‰†+ç‹ç‰Œå‰©é¤˜3å¼µæˆ–æ›´å°‘ï¼Œç¦æ­¢åŠ æ§“
  if ((S.wall.length + S.deadWall.length) <= 3) return res;
  // å¦‚æœå·²ç¶“æœ‰ä¸‰å€‹æ§“ï¼Œå‰‡ä¸å†å…è¨±åŠ æ§“
  if (countKongs(pl) >= 3) return res;
  pl.melds.forEach((m, idx) => {
    if (m.type === 'pong') {
      const k = tileKey(m.tiles[0]);
      // æª¢æŸ¥æ‰‹ç‰Œä¸­æ˜¯å¦é‚„æœ‰åŒæ¨£ä¸€å¼µ
      const hasFourth = pl.hand.some(t => tileKey(t) === k);
      if (hasFourth) {
        res.push({ meldIndex: idx, key: k });
      }
    }
  });
  return res;
}

// åŸ·è¡Œæš—æ§“
function doConcealedKong(pid, key) {
  const pl = S.players[pid];
  // å¾æ‰‹ç‰Œä¸­å–å‡ºå››å¼µç›¸åŒçš„ç‰Œ
  const tiles = [];
  for (let i = pl.hand.length - 1; i >= 0; i--) {
    const t = pl.hand[i];
    if (tileKey(t) === key) {
      tiles.push(pl.hand.splice(i, 1)[0]);
      if (tiles.length === 4) break;
    }
  }
  // å°‡æ­¤çµ„åŠ å…¥å‰¯éœ²ï¼Œæ¨™è¨˜ç‚ºæš—æ§“
  pl.melds.push({ type: 'kong', tiles: tiles, concealed: true });
  S.kongCount++; // æ§“ç‰Œæ¬¡æ•¸+1ï¼Œæµ·åº•å¤šä¿ç•™1å¼µ
  // å…¶ä»–å®¶æš—æ§“æ™‚ä¸é¡¯ç¤ºæ§“å“ªå¼µç‰Œ
  if (pid === 0) {
    log(`ğŸ’¥ ${playerName(pid)} æš—æ§“ ${keyToText(key)}`);
  } else {
    log(`ğŸ’¥ ${playerName(pid)} æš—æ§“`);
  }
  // æš—æ§“ç‰¹æ•ˆèˆ‡éŸ³æ•ˆï¼ˆæ‰€æœ‰ç©å®¶ï¼‰
  showEffect('ğŸ’¥ æš—æ§“', '#9C27B0');
  playSound(700, 0.3, 'sawtooth');
  // æš—æ§“å¾Œå¾ç‹ç‰Œè£œç‰Œ
  if (S.deadWall.length > 0) {
    const newTile = S.deadWall.pop();
    pl.hand.push(newTile);
  } else if (S.wall.length > 0) {
    const newTile = S.wall.pop();
    pl.hand.push(newTile);
  }
  S.remain = S.wall.length;
  renderAll();
  // æª¢æŸ¥æ§“å¾Œæ˜¯å¦å¯ä»¥è‡ªæ‘¸
  const t = pl.hand[pl.hand.length - 1];
  if (pid === 0) {
    // ç©å®¶æš—æ§“å¾Œæª¢æŸ¥æ˜¯å¦è‡ªæ‘¸
    if (isWinningNow(pl.hand, pl.melds, t)) {
      document.getElementById('btnHu').disabled = false;
      log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
    }
    // æª¢æŸ¥æ˜¯å¦å¯ä»¥å ±è½ï¼šæš—æ§“å¾Œä¸ç«‹å³å½ˆå‡ºå ±è½é¢æ¿ï¼Œå¾…å‡ºç‰Œæˆ–æŒ‰éˆ•æ™‚è™•ç†
  } else {
    // AIæš—æ§“å¾Œï¼Œç›´æ¥æª¢æŸ¥è‡ªæ‘¸
    if (isWinningNow(pl.hand, pl.melds, t)) {
      doWin(pid, -1, t, true);
      return;
    }
    // AIç¹¼çºŒè¡Œå‹•
    setTimeout(stepAI, 1000 + Math.random() * 1000);  // 1-2ç§’éš¨æ©Ÿå»¶é²
  }

  // æ›´æ–°æœ€å¾Œå‹•ä½œèˆ‡åŸ·è¡Œè€…ï¼šæš—æ§“å¾Œå·²è£œç‰Œï¼Œä¸å†ç«‹å³æ‘¸ç‰Œ
  S.lastAction = 'concealedKong';
  S.lastActor = pid;
}

// åŸ·è¡ŒåŠ æ§“ï¼šå°‡å·²ç¢°çš„ä¸‰å¼µç‰Œè£œç‚ºå››å¼µ
function doAddedKong(pid, meldIndex) {
  const pl = S.players[pid];
  const meld = pl.melds[meldIndex];
  // å·²ç¶“æ˜¯æ§“ç‰Œçš„ä¸å†åŠ æ§“
  if (!meld || meld.type !== 'pong') return;
  const key = tileKey(meld.tiles[0]);
  // å¾æ‰‹ç‰Œä¸­å–å‡ºç¬¬4å¼µ
  let idx = -1;
  for (let i = 0; i < pl.hand.length; i++) {
    if (tileKey(pl.hand[i]) === key) {
      idx = i;
      break;
    }
  }
  if (idx < 0) return;
  const tile = pl.hand.splice(idx, 1)[0];
  meld.tiles.push(tile);
  meld.type = 'kong';
  meld.added = true;
  // åŠ æ§“ä»å±¬æ˜ç‰Œï¼Œå·²ç¶“å­˜åœ¨ç¢°
  S.anyOpenMeld = true;
  S.kongCount++;
  log(`ğŸ’¥ ${playerName(pid)} åŠ æ§“ ${keyToText(key)}`);
  // åŠ æ§“ç‰¹æ•ˆèˆ‡éŸ³æ•ˆï¼ˆæ‰€æœ‰ç©å®¶ï¼‰
  showEffect('ğŸ’¥ æ§“', '#FF5722');
  playSound(650, 0.3, 'sawtooth');
  // å¾ç‹ç‰Œè£œç‰Œ
  if (S.deadWall.length > 0) {
    const newTile = S.deadWall.pop();
    pl.hand.push(newTile);
  } else if (S.wall.length > 0) {
    const newTile = S.wall.pop();
    pl.hand.push(newTile);
  }
  S.remain = S.wall.length;
  // æ¨™è¨˜æ§“ä¸Šé–‹èŠ±æ——æ¨™
  pl.rinshan = true;
  renderAll();
  // æ§“å¾Œæª¢æŸ¥æ˜¯å¦è‡ªæ‘¸
  const t = pl.hand[pl.hand.length - 1];
  if (pid === 0) {
    if (isWinningNow(pl.hand, pl.melds, t)) {
      document.getElementById('btnHu').disabled = false;
      log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
    }
    // æª¢æŸ¥æ˜¯å¦å¯ä»¥å ±è½ï¼šåŠ æ§“å¾Œä¸ç«‹å³å½ˆå‡ºå ±è½é¢æ¿ï¼Œå¾…å‡ºç‰Œæˆ–æŒ‰éˆ•æ™‚è™•ç†
  } else {
    // AI åŠ æ§“å¾Œæª¢æŸ¥è‡ªæ‘¸
    if (isWinningNow(pl.hand, pl.melds, t)) {
      doWin(pid, -1, t, true);
      return;
    }
    setTimeout(stepAI, 1000 + Math.random() * 1000);  // 1-2ç§’éš¨æ©Ÿå»¶é²
  }

  // æ›´æ–°æœ€å¾Œå‹•ä½œèˆ‡åŸ·è¡Œè€…ï¼šåŠ æ§“å¾Œå·²è£œç‰Œï¼Œä¸å†ç«‹å³æ‘¸ç‰Œ
  S.lastAction = 'addedKong';
  S.lastActor = pid;
}

function doPong(pid, tile) {
  const pl = S.players[pid];

  const k = tileKey(tile);
  const tiles = [tile];
  for (let i = 0; i < 2; i++) {
    const idx = pl.hand.findIndex(t => tileKey(t) === k);
    if (idx >= 0) {
      tiles.push(pl.hand.splice(idx, 1)[0]);
    }
  }

  // æ›´æ–°æœ€å¾Œå‹•ä½œèˆ‡åŸ·è¡Œè€…ï¼šç¢°ç‰Œå¾Œä¸‹ä¸€æ­¥æ‡‰å‡ºç‰Œï¼Œä¸å†æ‘¸ç‰Œ
  S.lastAction = 'pong';
  S.lastActor = pid;
  pl.melds.push({ type: 'pong', tiles });
  // åšç¢°å±¬æ–¼æ˜ç‰Œï¼Œè¨­å®šå·²å‡ºç¾æ˜åƒç¢°æ§“
  S.anyOpenMeld = true;
  log(`ğŸ”¥ ${playerName(pid)} ç¢°äº† ${keyToText(k)}`);
  // ç¢°ç‰Œç‰¹æ•ˆèˆ‡éŸ³æ•ˆï¼ˆæ‰€æœ‰ç©å®¶ï¼‰
  showEffect('ğŸ”¥ ç¢°', '#FFC107');
  playSound(550, 0.25, 'square');
  S.turn = pid;
  S.lastDiscard = null;
  S.waitReact = null;
  hideReactionPanel();
  renderAll();

  // è‹¥æ˜¯ç©å®¶ç¢°ç‰Œï¼Œä¸ç«‹å³å½ˆå‡ºå ±è½é¢æ¿ï¼›å¾…ä¸Ÿç‰Œå¾Œå†åˆ¤æ–·è½ç‰Œ
}

function doKong(pid, tile) {
  const pl = S.players[pid];


  // å·²ç§»é™¤4çµ„å‰¯éœ²é™åˆ¶çš„æ—©æœŸè¿”å›ï¼Œé™åˆ¶å·²ç”± canKong æ§åˆ¶
  const k = tileKey(tile);
  const tiles = [tile];
  for (let i = 0; i < 3; i++) {
    const idx = pl.hand.findIndex(t => tileKey(t) === k);
    if (idx >= 0) {
      tiles.push(pl.hand.splice(idx, 1)[0]);
    }
  }
  pl.melds.push({ type: 'kong', tiles });
  // æ˜æ§“å±¬æ–¼æ˜ç‰Œï¼Œè¨˜éŒ„å·²é–‹ç¢°åƒæ§“
  S.anyOpenMeld = true;
  S.kongCount++; // æ§“ç‰Œæ¬¡æ•¸+1ï¼Œæµ·åº•å¤šä¿ç•™1å¼µ
  log(`ğŸ’¥ ${playerName(pid)} æ§“äº† ${keyToText(k)}ï¼Œå¾ç‹ç‰Œè£œç‰Œ`);
  // æ˜æ§“ç‰¹æ•ˆèˆ‡éŸ³æ•ˆï¼ˆæ‰€æœ‰ç©å®¶ï¼‰
  showEffect('ğŸ’¥ æ§“', '#FF5722');
  playSound(650, 0.3, 'sawtooth');
  
  // æ§“ç‰Œå¾Œå¾ç‹ç‰Œè£œç‰Œ
  if (S.deadWall.length > 0) {
    const newTile = S.deadWall.pop();
    pl.hand.push(newTile);
  } else if (S.wall.length > 0) {
    const newTile = S.wall.pop();
    pl.hand.push(newTile);
  }
  S.remain = S.wall.length;
  // æ›´æ–°æœ€å¾Œå‹•ä½œèˆ‡åŸ·è¡Œè€…ï¼šæ˜æ§“å¾Œå·²è£œç‰Œï¼Œä¸å†ç«‹å³æ‘¸ç‰Œ
  S.lastAction = 'kong';
  S.lastActor = pid;
  S.turn = pid;
  S.lastDiscard = null;
  S.waitReact = null;
  hideReactionPanel();
  renderAll();

  // è‹¥ç”±ç©å®¶é€²è¡Œæ˜æ§“ï¼Œè£œç‰Œå¾Œæª¢æŸ¥è‡ªæ‘¸åŠè½ç‰Œ
  if (pid === 0) {
    const me = S.players[0];
    // æª¢æŸ¥è£œç‰Œå¾Œæ˜¯å¦è‡ªæ‘¸
    const t = me.hand[me.hand.length - 1];
    if (isWinningNow(me.hand, me.melds, t)) {
      document.getElementById('btnHu').disabled = false;
      log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
    }
    // æª¢æŸ¥æ˜¯å¦å¯å ±è½
    if (!me.declaredListen) {
      const kongCount = countKongs(me);
      const totalTiles = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
      const expectedFull = 17 + kongCount;
      if (totalTiles === expectedFull) {
        const canListenNow = me.hand.some(tile2 => {
          const testHand = me.hand.filter(t => t !== tile2);
          return isListening(testHand, me.melds);
        });
        if (canListenNow) showListenPanel();
      }
    }
  }
}

/* ========= å‡ºç‰Œèˆ‡åæ‡‰ ========= */
function discard(p, tile) {
  const hand = S.players[p].hand;
  const i = hand.indexOf(tile);
  if (i < 0) return;
  hand.splice(i, 1);
  // æ‰“å‡ºç‰Œå¾Œï¼Œé‡ç½®æœ¬å®¶å‰›æ‘¸çš„ç‰Œè¨˜éŒ„
  S.players[p].drawnTile = null;
  S.players[p].discards.push(tile);
  S.lastDiscard = { tile, from: p };
  // ä¸Ÿç‰ŒéŸ³æ•ˆ
  playSound(400, 0.1, 'square');

  // æ›´æ–°æœ€å¾Œå‹•ä½œèˆ‡åŸ·è¡Œè€…ç‚ºå‡ºç‰Œ
  S.lastAction = 'discard';
  S.lastActor = p;
  log(`ğŸ´ ${playerName(p)} æ‰“å‡º ${keyToText(tileKey(tile))}`);

  // æ‰“å‡ºç‰Œå¾Œï¼Œéæ§“è£œç‰Œçš„è‡ªæ‘¸æ——æ¨™é‡ç½®
  S.players[p].rinshan = false;
  renderAll();
  // æ‰“å‡ºç‰Œå¾Œï¼Œè‹¥ç•¶å‰æ‰‹ç‰Œåœ¨è½ç‰Œç‹€æ…‹ï¼Œé¡¯ç¤ºç­‰å¾…ç‰Œæç¤ºï¼ˆä¸ç”¨å®£å‘Šè½ç‰Œï¼‰ã€‚
  {
    const pl = S.players[p];
    const kc = countKongs(pl);
    const totalP = pl.hand.length + pl.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    const expFull = 17 + kc;
    const expEmpty = 16 + kc;
    let ting = false;
    if (totalP === expFull) {
      // æ¸¬è©¦æ‰“å‡ºä»»ä½•ä¸€å¼µæ˜¯å¦èƒ½è½ç‰Œ
      ting = pl.hand.some(tt => {
        const test = pl.hand.filter(x => x !== tt);
        return isListening(test, pl.melds);
      });
    } else if (totalP === expEmpty) {
      ting = isListening(pl.hand, pl.melds);
    }
    if (ting) {
      const waits = calcWaitingTiles(pl.hand, pl.melds);
      pl.waitKeys = waits.slice();
      if (waits.length > 0) {
        const waitText = waits.map(k => keyToText(k)).join(' ');
        // åƒ…ç•¶è‡ªå·±æ‰“ç‰Œæ™‚æ‰åœ¨æˆ°æ³è¨˜éŒ„é¡¯ç¤ºç­‰å¾…ç‰Œï¼Œå…¶ä»–å®¶ä¸éœ€è¦æé†’
        if (p === 0) {
          log('ğŸ‘‚ ç­‰ç‰Œï¼š' + waitText);
        }
      }
    } else {
      pl.waitKeys = [];
    }
  }
  
  // æª¢æŸ¥å…¶ä»–ç©å®¶æ˜¯å¦å¯ä»¥èƒ¡ã€ç¢°ã€æ§“ã€åƒï¼ˆæ”¶é›†æ‰€æœ‰å¯èƒ½çš„åæ‡‰ï¼‰
  let reactions = [];
  for (let k = 1; k <= 3; k++) {
    const pid = (p + k) % 4;
    if (pid === p) continue;
    
    // èƒ¡ç‰Œå„ªå…ˆç´šæœ€é«˜
    if (canWinOn(pid, tile)) {
      reactions.push({ pid, type: 'hu', tile });
    }
    // æ”¶é›†æ‰€æœ‰å¯èƒ½çš„åæ‡‰ï¼ˆä¸ä½¿ç”¨ elseï¼Œè®“ç©å®¶å¯ä»¥é¸æ“‡ï¼‰
    if (canKong(pid, tile)) {
      reactions.push({ pid, type: 'kong', tile });
    }
    if (canPong(pid, tile)) {
      reactions.push({ pid, type: 'pong', tile });
    }
    const chowPatterns = canChow(pid, tile);
    if (chowPatterns.length > 0) {
      reactions.push({ pid, type: 'chow', tile, patterns: chowPatterns });
    }
  }
  
  if (reactions.length > 0) {
    S.waitReact = reactions;
    if (reactions.some(r => r.pid === 0)) {
      showReactionPanel(reactions.filter(r => r.pid === 0));
    } else {
      setTimeout(() => handleAIReaction(reactions), 1000 + Math.random() * 1000);  // 1-2ç§’éš¨æ©Ÿå»¶é²
    }
  } else {
    S.turn = getNextTurn(S.turn);
    stepNext();
  }
}

function showReactionPanel(reactions) {
  // æ–°è¦å‰‡ï¼šå¦‚æœå·²å ±è½ï¼Œéæ¿¾æ‰åƒã€ç¢°ã€æ˜æ§“çš„é¸é …
  const me = S.players[0];
  if (me.declaredListen) {
    // å·²è½ç‰Œï¼Œåªä¿ç•™èƒ¡ç‰Œé¸é …ï¼Œç§»é™¤åƒç¢°æ§“
    reactions = reactions.filter(r => r.type === 'hu');
    if (reactions.length === 0) {
      // æ²’æœ‰å¯ç”¨é¸é …ï¼Œè‡ªå‹•é
      clearReactionButtons();
      S.turn = getNextTurn(S.lastDiscard.from);
      S.lastDiscard = null;
      S.waitReact = null;
      stepNext();
      return;
    }
  }
  
  // æ¸…é™¤æ‰€æœ‰æŒ‰éˆ•çš„äº®ç‡ˆç‹€æ…‹
  clearReactionButtons();
  
  // å„²å­˜ç•¶å‰åæ‡‰é¸é …ï¼Œä¾›æŒ‰éˆ•é»æ“Šæ™‚ä½¿ç”¨
  S.currentReactions = reactions;
  
  // æ ¹æ“šåæ‡‰é¡å‹äº®èµ·å°æ‡‰æŒ‰éˆ•
  reactions.forEach(r => {
    if (r.type === 'hu') {
      document.getElementById('btnHu').classList.add('active');
      document.getElementById('btnHu').disabled = false;
    } else if (r.type === 'pong') {
      document.getElementById('btnPong').classList.add('active');
      document.getElementById('btnPong').disabled = false;
    } else if (r.type === 'kong') {
      document.getElementById('btnKong').classList.add('active');
      document.getElementById('btnKong').disabled = false;
    } else if (r.type === 'chow') {
      document.getElementById('btnChow').classList.add('active');
      document.getElementById('btnChow').disabled = false;
    }
  });
  
  // äº®èµ·ã€Œéã€æŒ‰éˆ•
  document.getElementById('btnPass').classList.add('active');
  document.getElementById('btnPass').disabled = false;
}

function hideReactionPanel() {
  document.getElementById('reactionPanel').style.display = 'none';
  document.getElementById('overlay').style.display = 'none';
}

// æ¸…é™¤æ‰€æœ‰åæ‡‰æŒ‰éˆ•çš„äº®ç‡ˆç‹€æ…‹
function clearReactionButtons() {
  const buttons = ['btnHu', 'btnChow', 'btnPong', 'btnKong', 'btnPass'];
  buttons.forEach(id => {
    const btn = document.getElementById(id);
    if (btn) {
      btn.classList.remove('active');
      btn.disabled = true;
    }
  });
}

// è™•ç†åƒç‰ŒæŒ‰éˆ•é»æ“Š
function handleChowClick() {
  if (!S.currentReactions) return;
  const chowReact = S.currentReactions.find(r => r.type === 'chow');
  if (!chowReact) return;
  
  // å¦‚æœæœ‰å¤šç¨®åƒæ³•ï¼Œé¡¯ç¤ºé¸æ“‡é¢æ¿
  if (chowReact.patterns && chowReact.patterns.length > 1) {
    showChowSelectionPanel(chowReact);
  } else {
    // åªæœ‰ä¸€ç¨®åƒæ³•ï¼Œç›´æ¥åŸ·è¡Œ
    doChow(chowReact.pid, chowReact.tile, chowReact.patterns[0]);
    clearReactionButtons();
  }
}

// é¡¯ç¤ºåƒç‰Œé¸æ“‡é¢æ¿
function showChowSelectionPanel(chowReact) {
  const panel = document.getElementById('reactionPanel');
  const overlay = document.getElementById('overlay');
  
  let html = '<div class="reaction-panel"><h3>ğŸœ é¸æ“‡åƒæ³•</h3><div class="row">';
  chowReact.patterns.forEach((pat, idx) => {
    const patText = [...pat].sort((a, b) => a - b).join(' ');
    html += `<button class="chowOpt" data-idx="${idx}">ğŸœ ${patText}</button>`;
  });
  html += '</div><div class="row"><button id="cancelChow">âŒ å–æ¶ˆ</button></div></div>';
  
  panel.innerHTML = html;
  panel.style.display = 'block';
  overlay.style.display = 'block';
  
  // ç¶å®šæ¯å€‹åƒæ³•æŒ‰éˆ•çš„äº‹ä»¶
  const opts = panel.querySelectorAll('.chowOpt');
  opts.forEach(btn => {
    const idx = parseInt(btn.getAttribute('data-idx'));
    btn.onclick = () => {
      doChow(chowReact.pid, chowReact.tile, chowReact.patterns[idx]);
      panel.style.display = 'none';
      overlay.style.display = 'none';
      clearReactionButtons();
    };
  });
  
  // å–æ¶ˆæŒ‰éˆ•
  document.getElementById('cancelChow').onclick = () => {
    panel.style.display = 'none';
    overlay.style.display = 'none';
  };
}

// è™•ç†ç¢°ç‰ŒæŒ‰éˆ•é»æ“Š
function handlePongClick() {
  if (!S.currentReactions) return;
  const pongReact = S.currentReactions.find(r => r.type === 'pong');
  if (!pongReact) return;
  
  doPong(pongReact.pid, pongReact.tile);
  clearReactionButtons();
}

// è™•ç†æ§“ç‰ŒæŒ‰éˆ•é»æ“Š
function handleKongClick() {
  if (!S.currentReactions) return;
  const kongReact = S.currentReactions.find(r => r.type === 'kong');
  if (!kongReact) return;
  
  doKong(kongReact.pid, kongReact.tile);
  clearReactionButtons();
}

// è™•ç†èƒ¡ç‰ŒæŒ‰éˆ•é»æ“Š
function handleHuClick() {
  if (!S.currentReactions) return;
  const huReact = S.currentReactions.find(r => r.type === 'hu');
  if (!huReact) return;
  
  doWin(huReact.pid, S.lastDiscard.from, huReact.tile, false);
  clearReactionButtons();
}

// è™•ç†éæŒ‰éˆ•é»æ“Š
function handlePassClick() {
  clearReactionButtons();
  S.turn = getNextTurn(S.lastDiscard.from);
  S.lastDiscard = null;
  S.waitReact = null;
  S.currentReactions = null;
  stepNext();
}

// é¡¯ç¤ºå ±è½é¸æ“‡é¢æ¿ï¼šç•¶ç©å®¶å¯ä»¥å®£å‘Šè½ç‰Œæ™‚ï¼Œå½ˆå‡ºæ­¤é¢æ¿è®“ç©å®¶é¸æ“‡æ˜¯å¦å ±è½
function showListenPanel() {
  const panel = document.getElementById('reactionPanel');
  const overlay = document.getElementById('overlay');
  let html = '<div class="reaction-panel">';
  html += '<h3>ğŸ”” æ˜¯å¦å ±è½ï¼Ÿ</h3>';
  html += '<div class="row">';
  html += '<button id="listenYes">ğŸ”” è½ç‰Œ</button>';
  html += '<button id="listenNo">â­ï¸ ä¸è½</button>';
  html += '</div></div>';
  panel.innerHTML = html;
  panel.style.display = 'block';
  overlay.style.display = 'block';
  document.getElementById('listenYes').onclick = () => {
    const me = S.players[0];
    if (!me.declaredListen) {
      // æ¨™è¨˜å·²å ±è½ä½†å°šæœªé–å®š
      me.declaredListen = true;
      me.tingLocked = false; // æ–°å¢ï¼šæ¨™è¨˜è½ç‰Œå°šæœªé–å®š
      // æª¢æŸ¥å¤©è½/åœ°è½
      updateTianDiTing(0);
      // è¨ˆç®—è½ç‰Œæ™‚å¯ä»¥èƒ¡å“ªäº›ç‰Œï¼Œä¸¦æç¤º
      const waitKeys = calcWaitingTiles(me.hand, me.melds);
      const waitText = waitKeys.map(k => keyToText(k)).join(' ');
      // è¨˜éŒ„æ—¥èªŒï¼Œä¸åŒç‹€æ³é¡¯ç¤ºä¸åŒè¨Šæ¯
      if (me.tianTing) {
        log('ğŸ”” ä½ å®£å‘Šå¤©è½ï¼èƒ¡ç‰Œæ™‚å¤š ' + RULES.scoring.HeavenReady + ' å°');
      } else if (me.diTing) {
        log('ğŸ”” ä½ å®£å‘Šåœ°è½ï¼èƒ¡ç‰Œæ™‚å¤š ' + RULES.scoring.EarthReady + ' å°');
      } else {
        log('ğŸ”” ä½ å®£å‘Šè½ç‰Œï¼èƒ¡ç‰Œæ™‚å¤š 1 å°');
      }
      log('âš ï¸ è«‹ä¸Ÿä¸€å¼µæ‰‹ç‰Œå¾Œé–å®šè½ç‰Œ');
      // é¡¯ç¤ºç­‰å¾…ç‰Œæç¤º
      if (waitKeys.length > 0) {
        // å°‡ç­‰å¾…ç‰Œå„²å­˜æ–¼ç©å®¶ç‹€æ…‹ï¼Œä»¥ä¾¿åœ¨ç©å®¶å€å¡Šæˆ–è¨˜åˆ†æ¿é¡¯ç¤º
        me.waitKeys = waitKeys.slice();
        log('ğŸ‘‚ ç­‰å¾…ç‰Œï¼š' + waitText);
      } else {
        me.waitKeys = [];
      }
    }
    hideReactionPanel();
    renderAll();
  };
  document.getElementById('listenNo').onclick = () => {
    hideReactionPanel();
    // ç©å®¶é¸æ“‡ä¸å ±è½ï¼Œç¶­æŒåŸç‹€ç¹¼çºŒéŠæˆ²
  };
}

function handleAIReaction(reactions) {
  const huReact = reactions.find(r => r.type === 'hu');
  if (huReact) {
    doWin(huReact.pid, S.lastDiscard.from, huReact.tile, false);
    return;
  }
  
  // æ–°è¦å‰‡ï¼šAIå ±è½å¾Œä¸èƒ½åƒç¢°ï¼Œåªèƒ½æ§“æˆ–èƒ¡
  // éæ¿¾æ‰AIå·²è½ç‰Œç©å®¶çš„åƒç¢°åæ‡‰
  reactions = reactions.filter(r => {
    const p = S.players[r.pid];
    // å¦‚æœå·²è½ç‰Œï¼Œåªä¿ç•™èƒ¡ç‰Œå’Œæ§“ç‰Œåæ‡‰
    if (p.declaredListen) {
      return r.type === 'hu' || r.type === 'kong';
    }
    return true;
  });
  
  // è®Šæ…ŠAIï¼šæ›´æ¿€é€²çš„ç¢°æ§“ç­–ç•¥
  const kongReact = reactions.find(r => r.type === 'kong');
  if (kongReact && Math.random() > 0.2) {  // 80%æ©Ÿç‡æ§“
    doKong(kongReact.pid, kongReact.tile);
    setTimeout(stepAI, 1000 + Math.random() * 1000);  // 1-2ç§’éš¨æ©Ÿå»¶é²
    return;
  }
  
  const pongReact = reactions.find(r => r.type === 'pong');
  if (pongReact && Math.random() > 0.3) {  // 70%æ©Ÿç‡ç¢°
    doPong(pongReact.pid, pongReact.tile);
    setTimeout(stepAI, 1000 + Math.random() * 1000);  // 1-2ç§’éš¨æ©Ÿå»¶é²
    return;
  }
  
  // æ–°å¢ï¼šAIåƒç‰Œé‚è¼¯ï¼Œæ™ºèƒ½åˆ¤æ–·æ˜¯å¦æœ‰åˆ©
  const chowReact = reactions.find(r => r.type === 'chow');
  if (chowReact) {
    const me = S.players[chowReact.pid];
    // è©•ä¼°åƒç‰Œå¾Œæ˜¯å¦æœ‰åˆ©ï¼šæª¢æŸ¥å‘è½æ•¸
    const pattern = chowReact.patterns[0];  // å–ç¬¬ä¸€å€‹åƒç‰Œå‹æ…‹
    const tile = chowReact.tile;
    const suit = tile.suit;
    
    // æ¨¡æ“¬åƒç‰Œå¾Œçš„æ‰‹ç‰Œ
    const afterChow = me.hand.filter(t => {
      const key = tileKey(t);
      const needed = pattern.map(r => suit + r);
      const idx = needed.indexOf(key);
      if (idx >= 0) {
        needed.splice(idx, 1);
        return false;
      }
      return true;
    });
    
    // è¨ˆç®—åƒç‰Œå‰å¾Œçš„å‘è½æ•¸
    const shBefore = shantenAfterRemove(me.hand);
    const shAfter = shantenAfterRemove(afterChow);
    
    // å¦‚æœåƒç‰Œå¾Œå‘è½æ•¸æ¸›å°‘æˆ–ä¸è®Šï¼Œä¸”æœ‰ä¸€å®šæ©Ÿç‡ï¼Œå‰‡åƒç‰Œ
    if (shAfter <= shBefore && Math.random() > 0.4) {  // 60%æ©Ÿç‡åƒ
      doChow(chowReact.pid, chowReact.tile, pattern);
      setTimeout(stepAI, 1000 + Math.random() * 1000);  // 1-2ç§’éš¨æ©Ÿå»¶é²
      return;
    }
  }
  
  S.turn = getNextTurn(S.lastDiscard.from);
  S.lastDiscard = null;
  S.waitReact = null;
  stepNext();
}

function canWinOn(pid, tile) {
  const pl = S.players[pid];
  // åˆ¤æ–·ä»–å®¶æ‰“å‡ºçš„ç‰Œæ˜¯å¦èƒ½èƒ¡ç‰Œï¼Œä¸é™åˆ¶å‰¯éœ²çµ„æ•¸ï¼ˆå‰¯éœ²ä¸Šé™ç”±å…¶ä»–é‚è¼¯æ§åˆ¶ï¼‰
  const tmp = pl.hand.concat([tile]);
  return isWinningNow(tmp, pl.melds, tile);
}

function doWin(winner, from, tile, selfDraw) {
  S.winner = winner;
  S.fromPlayer = from;
  S.winTile = tile;
  S.phase = 'end';
  // èƒ¡ç‰Œç‰¹æ•ˆèˆ‡éŸ³æ•ˆï¼ˆæ‰€æœ‰ç©å®¶ï¼‰
  showEffect('ğŸ‰ èƒ¡äº†ï¼', '#FFD700', '64px');
  playSound(800, 0.5, 'sine');
  setTimeout(() => playSound(1000, 0.5, 'sine'), 200);
  // è¨ˆç®—å°æ•¸èˆ‡çå‹µç´°ç¯€
  const detail = calcFanDetails(winner, tile, selfDraw);
  const fan = detail.fan;
  const delta = RULES.points.base + fan * RULES.points.perFan;
  
  const catStr = detail.categories.join('ã€');
  if (selfDraw) {
    for (let i = 0; i < 4; i++) {
      if (i !== winner) {
        S.players[i].points -= delta;
      }
    }
    S.players[winner].points += delta * 3;
    log(`ğŸ‰ ${playerName(winner)} è‡ªæ‘¸ ${keyToText(tileKey(tile))}ï¼ˆ${catStr}ï¼Œå…±${fan}å°ï¼‰â†’ æ¯å®¶ä»˜ ${delta.toLocaleString()}`);
  } else {
    S.players[from].points -= delta * 3;
    S.players[winner].points += delta * 3;
    log(`ğŸ‰ ${playerName(winner)} é»èƒ¡ ${playerName(from)}ï¼ˆ${keyToText(tileKey(tile))}ï¼Œ${catStr}ï¼Œå…±${fan}å°ï¼‰â†’ æ”¾æ§è€…ä»˜ ${(delta * 3).toLocaleString()}`);
  }
  
  renderAll();

  // æ¸…é™¤æ§“ä¸Šé–‹èŠ±åŠæ¶æ§“æ——æ¨™
  S.players[winner].rinshan = false;
  S.robKong = false;

  // æ¸…é™¤æ§“ä¸Šé–‹èŠ±æ——æ¨™
  S.players[winner].rinshan = false;
  
  for (let i = 0; i < 4; i++) {
    if (S.players[i].points <= 0) {
      log(`âš ï¸ ${playerName(i)} ç ´ç”¢ï¼ŒéŠæˆ²çµæŸ`);
      setTimeout(() => showFinalScore(), 1500);
      return;
    }
  }
  
  // é¡¯ç¤ºæ‰€æœ‰ç©å®¶æ‰‹ç‰Œå’Œç¹¼çºŒæŒ‰éˆ•
  setTimeout(() => showHandsAndContinue(), 1000);
}

function calcFan(winner, winTile, selfDraw) {
  const pl = S.players[winner];
  const allTiles = pl.hand.concat(pl.melds.flatMap(m => m.tiles));
  let fan = 0;
  
  if (isSevenPairs(pl.hand.concat([winTile]))) fan += RULES.scoring.SevenPairs;
  
  const kinds = countByKey(pl.hand.concat([winTile]));
  const allTrip = isAllPungsPossible(kinds);
  if (allTrip) fan += RULES.scoring.AllPungs;
  
  const suitCnt = { W: 0, T: 0, B: 0 };
  let honors = 0;
  for (const t of allTiles) {
    const k = tileKey(t)[0];
    if (suitCnt[k] != null) suitCnt[k]++;
    else if (k === 'F' || k === 'D') honors++;
  }
  
  const nz = Object.values(suitCnt).filter(x => x > 0).length;
  if (nz === 1) fan += RULES.scoring.PureOneSuit;
  else if (nz === 2 && honors > 0) fan += RULES.scoring.HalfFlush;
  
  // èŠ±ç‰Œå°æ•¸å·²ç§»é™¤
  
  // å¤©è½/åœ°è½æˆ–æ™®é€šå ±è½å°æ•¸
  // å¤©è½æˆ–åœ°è½ä¸èˆ‡ä¸€èˆ¬è½ç‰Œé‡è¤‡è¨ˆå°
  if (pl.tianTing) {
    fan += RULES.scoring.HeavenReady;
  } else if (pl.diTing) {
    fan += RULES.scoring.EarthReady;
  } else if (pl.declaredListen) {
    fan += 1;
  }
  
  if (selfDraw) {
    const menqing = pl.melds.length === 0;
    fan += menqing ? RULES.scoring.MenqingSelfDraw : RULES.scoring.SelfDraw;
  }

  // æ¶æ§“èƒ¡ç‰ŒåŠ å°
  if (S.robKong) {
    fan += RULES.scoring.RobKong;
  }

  // æ§“ä¸Šé–‹èŠ±åŠ å°ï¼šè‹¥æ˜¯è‡ªæ‘¸ä¸”ä¾†è‡ªæ§“å¾Œè£œç‰Œ
  if (selfDraw && pl.rinshan) {
    fan += RULES.scoring.Rinshan;
  }
  
  if (S.rules.gold.enabled) {
    const keys = allTiles.map(tileKey);
    const goldOwned = keys.filter(k => S.goldKeys.includes(k)).length;
    fan += goldOwned * S.rules.gold.perGold;
    if (S.goldKeys.includes(tileKey(winTile))) fan += S.rules.gold.winOnGold;
  }
  
  return Math.max(1, fan);
}

/**
 * è¨ˆç®—èƒ¡ç‰Œæ™‚å„å€‹çå‹µå°æ•¸ç´°ç¯€ã€‚
 * æœƒå›å‚³ä¸€å€‹ç‰©ä»¶ï¼ŒåŒ…å«ç¸½å°æ•¸ fan å’Œä¸€çµ„ categories ç”¨æ–¼é¡¯ç¤ºåç¨±ã€‚
 */
function calcFanDetails(winner, winTile, selfDraw) {
  const pl = S.players[winner];
  const allTiles = pl.hand.concat(pl.melds.flatMap(m => m.tiles));
  let fan = 0;
  const categories = [];
  // ä¸ƒå°å­
  if (isSevenPairs(pl.hand.concat([winTile]))) {
    fan += RULES.scoring.SevenPairs;
    categories.push('ä¸ƒå°');
  }
  // å°å°èƒ¡ / ç¢°ç¢°èƒ¡ï¼šå…¨ç‚ºåˆ»å­/æ§“å­çµ„åˆ
  const kinds = countByKey(pl.hand.concat([winTile]));
  const allTrip = isAllPungsPossible(kinds);
  if (allTrip) {
    fan += RULES.scoring.AllPungs;
    categories.push('å°å°èƒ¡');
  }
  // ç´”è‰²ï¼æ··ä¸€è‰²
  const suitCnt = { W: 0, T: 0, B: 0 };
  let honors = 0;
  for (const t of allTiles) {
    const k = tileKey(t)[0];
    if (suitCnt[k] != null) suitCnt[k]++;
    else if (k === 'F' || k === 'D') honors++;
  }
  const nz = Object.values(suitCnt).filter(x => x > 0).length;
  if (nz === 1) {
    fan += RULES.scoring.PureOneSuit;
    categories.push('æ¸…ä¸€è‰²');
  } else if (nz === 2 && honors > 0) {
    fan += RULES.scoring.HalfFlush;
    categories.push('æ··ä¸€è‰²');
  }
  // å¤©è½/åœ°è½/è½ç‰Œ
  if (pl.tianTing) {
    fan += RULES.scoring.HeavenReady;
    categories.push('å¤©è½');
  } else if (pl.diTing) {
    fan += RULES.scoring.EarthReady;
    categories.push('åœ°è½');
  } else if (pl.declaredListen) {
    fan += 1;
    categories.push('è½ç‰Œ');
  }
  // è‡ªæ‘¸ç›¸é—œ
  if (selfDraw) {
    const menqing = pl.melds.length === 0;
    if (menqing) {
      fan += RULES.scoring.MenqingSelfDraw;
      categories.push('é–€æ¸…è‡ªæ‘¸');
    } else {
      fan += RULES.scoring.SelfDraw;
      categories.push('è‡ªæ‘¸');
    }
  }
  // æ¶æ§“èƒ¡
  if (S.robKong) {
    fan += RULES.scoring.RobKong;
    categories.push('æ¶æ§“èƒ¡');
  }
  // æ§“ä¸Šé–‹èŠ±
  if (selfDraw && pl.rinshan) {
    fan += RULES.scoring.Rinshan;
    categories.push('æ§“ä¸Šé–‹èŠ±');
  }
  // é‡‘ç‰Œå°æ•¸
  if (S.rules.gold.enabled) {
    const keys = allTiles.map(tileKey);
    const goldOwned = keys.filter(k => S.goldKeys.includes(k)).length;
    // æ¯å¼µé‡‘ç‰Œä¸€å°
    if (goldOwned > 0) {
      fan += goldOwned * S.rules.gold.perGold;
      categories.push(`${goldOwned}é‡‘ç‰Œ`);
    }
    // èƒ¡ç‰Œæ‰€ç”¨çš„ç‰Œè‹¥æ˜¯é‡‘ç‰Œ
    if (S.goldKeys.includes(tileKey(winTile))) {
      fan += S.rules.gold.winOnGold;
      categories.push('æ‘¸é‡‘èƒ¡');
    }
  }
  // é€£èŠå°æ•¸ï¼šèŠå®¶èƒ¡ç‰Œæ™‚ï¼ŒåŠ ä¸Šé€£èŠå°æ•¸ï¼ˆ2n+1ï¼‰
  if (winner === S.dealer && S.dealerStreak > 0) {
    const streakFan = 2 * S.dealerStreak + 1;
    fan += streakFan;
    categories.push(`é€£${S.dealerStreak}èŠ`);
  } else if (winner === S.dealer) {
    // èŠå®¶åŸºæœ¬ 1 å°
    fan += 1;
    categories.push('ä½œèŠ');
  }
  // ç¸½å°æ•¸è‡³å°‘ 1 å°
  if (fan < 1) fan = 1;
  return { fan, categories };
}

function isAllPungsPossible(counts) {
  for (const k in counts) {
    if (counts[k] >= 2) {
      counts[k] -= 2;
      let ok = true;
      for (const kk in counts) {
        if (counts[kk] % 3 !== 0) {
          ok = false;
          break;
        }
      }
      counts[k] += 2;
      if (ok) return true;
    }
  }
  return false;
}

/* ========= å›åˆæ¨é€² ========= */
function stepNext() {
  renderAll();
  if (S.phase === 'end') return;
  if (S.turn === 0) {
    // è¼ªåˆ°ç©å®¶
    const me = S.players[0];
    // ä¾ç¸½ç‰Œæ•¸ï¼ˆæ‰‹ç‰Œï¼‹å‰¯éœ²ï¼‰æ±ºå®šæ˜¯å¦éœ€è¦æ‘¸ç‰Œ
    const kongCount = countKongs(me);
    const totalTiles = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    const expectedFull = 17 + kongCount;
    const expectedEmpty = 16 + kongCount;

    if (totalTiles <= expectedEmpty) {
      // æŒæœ‰å¼µæ•¸ä¸è¶³ï¼Œå¿…é ˆæ‘¸ç‰Œ
      drawTile(0);
      const t = me.hand[me.hand.length - 1];
      if (isWinningNow(me.hand, me.melds, t)) {
        document.getElementById('btnHu').disabled = false;
        log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
      }
      renderAll();
      // æª¢æŸ¥æ˜¯å¦å¯å ±è½
      if (!me.declaredListen) {
        const canListenNow = me.hand.some(tile => {
          const testHand = me.hand.filter(tt => tt !== tile);
          return isListening(testHand, me.melds);
        });
        // ä¸åœ¨æ‘¸ç‰Œéšæ®µè‡ªå‹•å½ˆå‡ºå ±è½é¢æ¿
      }
    } else {
      // ç„¡éœ€æ‘¸ç‰Œï¼Œç›´æ¥å‡ºç‰Œï¼›è‹¥å‰›è£œç‰Œæˆ–æ‘¸ç‰Œï¼Œä»æª¢æŸ¥æ˜¯å¦è‡ªæ‘¸
      if (me.hand.length > 0) {
        const last = me.hand[me.hand.length - 1];
        if (isWinningNow(me.hand, me.melds, last)) {
          document.getElementById('btnHu').disabled = false;
          log('âœ¨ ä½ å¯ä»¥è‡ªæ‘¸ï¼ˆæŒ‰ã€Œèƒ¡ç‰Œã€ï¼‰æˆ–ç¹¼çºŒå‡ºç‰Œ');
        }
      }
      log('ğŸ‘‰ è«‹é¸æ“‡è¦æ‰“å‡ºçš„ç‰Œ');
      renderAll();
      if (!me.declaredListen) {
        const canListenNow = me.hand.some(tile => {
          const testHand = me.hand.filter(tt => tt !== tile);
          return isListening(testHand, me.melds);
        });
        // ä¸åœ¨å‡ºç‰Œæç¤ºéšæ®µè‡ªå‹•å½ˆå‡ºå ±è½é¢æ¿
      }
    }
    // è‹¥ç‰Œæ•¸ç•°å¸¸ï¼Œä»è¨˜éŒ„è­¦å‘Šï¼Œä½†ä¸å½±éŸ¿æ‘¸ç‰Œé‚è¼¯
    if (totalTiles < expectedEmpty || totalTiles > expectedFull) {
      log(`âš ï¸ ç©å®¶ç•°å¸¸ï¼šç¸½ç‰Œæ•¸=${totalTiles}ï¼Œæ‰‹ç‰Œ=${me.hand.length}ï¼Œå‰¯éœ²=${me.melds.length}çµ„ï¼Œæ§“æ•¸=${kongCount}`);
    }
  } else {
    setTimeout(stepAI, 1000 + Math.random() * 1000);  // 1-2ç§’éš¨æ©Ÿå»¶é²
  }
}

function stepAI() {
  if (S.phase === 'end') return;
  const p = S.turn;
  const me = S.players[p];
  // ä¾ç¸½ç‰Œæ•¸æ±ºå®šæ˜¯å¦éœ€è¦æ‘¸ç‰Œ
  const kongCount = countKongs(me);
  const totalTiles = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
  const expectedFull = 17 + kongCount;
  const expectedEmpty = 16 + kongCount;
  if (totalTiles <= expectedEmpty) {
    drawTile(p);
    if (S.phase === 'end') return;
  }
  renderAll();
  // æª¢æŸ¥è‡ªæ‘¸ï¼ˆæ‘¸ç‰Œæˆ–è£œç‰Œå¾Œï¼‰ï¼šå„ªå…ˆæ–¼æ§“ç‰Œè¡Œç‚º
  const lastTile = me.hand[me.hand.length - 1];
  if (isWinningNow(me.hand, me.melds, lastTile)) {
    doWin(p, -1, lastTile, true);
    return;
  }
  // è‹¥ç‰Œæ•¸ç•°å¸¸ï¼Œç´€éŒ„è­¦å‘Šï¼ˆä½†ä¸å½±éŸ¿æ‘¸ç‰Œé‚è¼¯ï¼‰
  if (totalTiles < expectedEmpty || totalTiles > expectedFull) {
    log(`âš ï¸ AI ç•°å¸¸ï¼šç¸½ç‰Œæ•¸=${totalTiles}ï¼Œæ‰‹ç‰Œ=${me.hand.length}ï¼Œå‰¯éœ²=${me.melds.length}çµ„ï¼Œæ§“æ•¸=${kongCount}`);
  }

  // AI æª¢æŸ¥åŠ æ§“
  const aks = canAddedKong(p);
  if (aks.length > 0) {
    // æª¢æŸ¥æ¶æ§“
    const cand = aks[0];
    const key = cand.key;
    const tile = me.hand.find(t => tileKey(t) === key);
    for (let pid = 0; pid < 4; pid++) {
      if (pid !== p && canWinOn(pid, tile)) {
        S.robKong = true;
        doWin(pid, p, tile, false);
        return;
      }
    }
    doAddedKong(p, cand.meldIndex);
    return;
  }
  // AI æª¢æŸ¥æš—æ§“
  const cks = canConcealedKong(p);
  if (cks.length > 0) {
    doConcealedKong(p, cks[0]);
    return;
  }
  // æª¢æŸ¥è‡ªæ‘¸ï¼ˆå†æ¬¡æª¢æŸ¥ï¼Œç†è«–ä¸Šåœ¨åŠ æ§“èˆ‡æš—æ§“è™•ç†å¾Œï¼‰
  if (isWinningNow(me.hand, me.melds, lastTile)) {
    doWin(p, -1, lastTile, true);
    return;
  }
  // AI è½ç‰Œåˆ¤æ–·ï¼šæ™ºèƒ½é¸æ“‡æ˜¯å¦å ±è½
  if (!me.declaredListen) {
    const total = me.hand.length + me.melds.reduce((s, m) => s + m.tiles.length, 0);
    const kongCount = countKongs(me);
    const expectedFull = 17 + kongCount;
    let canListen = false;
    
    if (total === expectedFull) {
      // æª¢æŸ¥æ˜¯å¦å¯è½ç‰Œ
      canListen = me.hand.some(t => {
        const after = me.hand.filter(x => x !== t);
        return isListening(after, me.melds);
      });
      
      // AI æ™ºèƒ½åˆ¤æ–·ï¼šå¦‚æœå¯è½ç‰Œï¼Œä¸”æœ‰ 70% æ©Ÿç‡å ±è½
      if (canListen && Math.random() > 0.3) {
        me.declaredListen = true;
        me.tingLocked = false;
        log(`ğŸ”” ${playerName(p)} å ±è½äº†ï¼`);
        renderAll();
      }
    }
  }
  
  // AIå ±è½å¾Œçš„å‡ºç‰Œé™åˆ¶
  const aiPlayer = S.players[p];
  let out;
  
  if (aiPlayer.declaredListen && !aiPlayer.tingLocked) {
    // AIå ±è½ä½†å°šæœªé–å®šï¼Œåªèƒ½ä¸Ÿæœƒå½¢æˆè½ç‰Œçš„ç‰Œ
    const validTiles = aiPlayer.hand.filter(t => {
      const after = aiPlayer.hand.filter(x => x !== t);
      return isListening(after, aiPlayer.melds);
    });
    if (validTiles.length > 0) {
      out = validTiles[0];  // é¸æ“‡ç¬¬ä¸€å¼µå¯ä»¥è½çš„ç‰Œ
    } else {
      out = aiPlayer.hand[0];  // å¦‚æœæ²’æœ‰ï¼Œä¸Ÿç¬¬ä¸€å¼µï¼ˆä¸æ‡‰ç™¼ç”Ÿï¼‰
    }
  } else if (aiPlayer.declaredListen && aiPlayer.tingLocked) {
    // AIå ±è½ä¸”å·²é–å®šï¼Œåªèƒ½ä¸Ÿå‰›æ‘¸çš„ç‰Œ
    const lastIdx = aiPlayer.hand.length - 1;
    out = aiPlayer.hand[lastIdx];
  } else {
    // ä¸€èˆ¬å‡ºç‰Œ
    out = aiChooseDiscard(p);
  }
  
  setTimeout(() => {
    discard(p, out);
    // AIå ±è½å¾Œä¸Ÿç‰Œï¼Œé–å®šè½ç‰Œ
    if (aiPlayer.declaredListen && !aiPlayer.tingLocked) {
      aiPlayer.tingLocked = true;
      log(`ğŸ”’ ${playerName(p)} è½ç‰Œå·²é–å®š`);
    }
  }, 1000 + Math.random() * 1000);  // 1-2ç§’éš¨æ©Ÿå»¶é²
}

/* ========= UI æ“ä½œ ========= */

document.getElementById('btnHu').onclick = () => {
  // å€åˆ†è‡ªæ‘¸å’Œé»ç‚®
  if (S.currentReactions) {
    // æœ‰åæ‡‰é¸é …ï¼Œè¡¨ç¤ºæ˜¯é»ç‚®
    handleHuClick();
  } else {
    // æ²’æœ‰åæ‡‰é¸é …ï¼Œè¡¨ç¤ºæ˜¯è‡ªæ‘¸
    const me = S.players[0];
    const t = me.hand[me.hand.length - 1];
    if (!isWinningNow(me.hand, me.melds, t)) return;
    doWin(0, -1, t, true);
  }
};

document.getElementById('btnListen').onclick = () => {
  const me = S.players[0];
  // å¦‚æœå·²å ±è½ï¼Œä¸æ‡‰è©²èƒ½é»æ“Šï¼ˆæŒ‰éˆ•æ‡‰è©²æ˜¯ç¦ç”¨çš„ï¼‰
  if (me.declaredListen) {
    return;
  }
  // æª¢æŸ¥æ˜¯å¦å¯è½ç‰Œï¼šä¾æ“šç›®å‰æ‰‹ç‰Œå¼µæ•¸é¸æ“‡ä¸åŒæª¢æŸ¥æ–¹å¼
  const total = me.hand.length + me.melds.reduce((s, m) => s + m.tiles.length, 0);
  const kongCount = countKongs(me);
  const expectedFull = 17 + kongCount;
  const expectedEmpty = 16 + kongCount;
  let canListen = false;
  if (total === expectedFull) {
    // æ“æœ‰å®Œæ•´å¼µæ•¸ï¼šæ‰“å‡ºå…¶ä¸­ä¸€å¼µå¾Œæ˜¯å¦è½ç‰Œ
    canListen = me.hand.some(tile => {
      const testHand = me.hand.filter(t => t !== tile);
      return isListening(testHand, me.melds);
    });
  } else if (total === expectedEmpty) {
    // å°‘ä¸€å¼µçš„ç‹€æ…‹ï¼šç•¶å‰æ‰‹ç‰Œæ˜¯å¦å·²ç¶“è½ç‰Œ
    canListen = isListening(me.hand, me.melds);
  } else {
    // å…¶ä»–å¼µæ•¸ä¸å…è¨±å ±è½
    canListen = false;
  }
  if (!canListen) {
    log('âš ï¸ ä½ é‚„æ²’æœ‰è½ç‰Œï¼Œç„¡æ³•å ±è½');
    return;
  }
  // ç›´æ¥è¨­å®šè½ç‰Œç‹€æ…‹ï¼Œä¸é¡¯ç¤ºæç¤ºæ¬„
  me.declaredListen = true;
  me.tingLocked = false;  // å°šæœªé–å®šï¼Œéœ€è¦ä¸Ÿä¸€å¼µç‰Œå¾Œæ‰é–å®š
  updateTianDiTing(0);
  const waits = calcWaitingTiles(me.hand, me.melds);
  me.waitKeys = waits.slice();
  const waitText = waits.map(k => keyToText(k)).join(' ');
  log('ğŸ”” ä½ å ±è½äº†ï¼è«‹ä¸Ÿä¸€å¼µæ‰‹ç‰Œ');
  log('ğŸ‘‚ ç­‰ç‰Œï¼š' + waitText);
  renderAll();
};

// ç©å®¶åŸ·è¡Œæš—æ§“ï¼ˆæ‰‹ç‰Œå››å¼µç›¸åŒï¼‰
document.getElementById('btnKong').onclick = () => {
  if (S.turn !== 0 || S.phase === 'end' || S.lastDiscard !== null) return;
  const me = S.players[0];
  // è½ç‰Œå¾Œä»å¯ä»¥æš—æ§“å’ŒåŠ æ§“
  const added = canAddedKong(0);
  const concealed = canConcealedKong(0);
  // å„ªå…ˆè™•ç†åŠ æ§“
  if (added.length > 0) {
    const cand = added[0];
    const key = cand.key;
    // æ‰¾å‡ºæ‰‹ç‰Œä¸­çš„ç¬¬å››å¼µ
    const tile = me.hand.find(t => tileKey(t) === key);
    // æª¢æŸ¥æ˜¯å¦æœ‰ç©å®¶å¯ä»¥æ¶æ§“
    for (let pid = 1; pid < 4; pid++) {
      if (canWinOn(pid, tile)) {
        // æ¶æ§“èƒ¡ç‰Œ
        S.robKong = true;
        doWin(pid, 0, tile, false);
        return;
      }
    }
    // ç„¡äººæ¶æ§“ï¼ŒåŸ·è¡ŒåŠ æ§“
    doAddedKong(0, cand.meldIndex);
    return;
  }
  // è‹¥æ²’æœ‰åŠ æ§“å‰‡æª¢æŸ¥æš—æ§“
  if (concealed.length > 0) {
    const key = concealed[0];
    doConcealedKong(0, key);
    return;
  }
};

document.getElementById('newGameBtn').onclick = () => {
  S = { players: Array.from({ length: 4 }, () => ({ points: RULES.initialPoints })) };
  // æ¸…ç©ºæˆ°æ³è¨˜éŒ„ï¼ˆinnerHTMLï¼‰ï¼Œä»¥å…æ®˜ç•™å…ˆå‰è¨Šæ¯èˆ‡æ¨™ç±¤
  document.getElementById('log').innerHTML = '';
  // When starting a brand new game, reset the dealer streak counter.
  dealerStreak = 0;
  startNewHand(true);
};

// åƒç¢°éæŒ‰éˆ•äº‹ä»¶ç›£è½å™¨
document.getElementById('btnChow').onclick = handleChowClick;
document.getElementById('btnPong').onclick = handlePongClick;
document.getElementById('btnPass').onclick = handlePassClick;

function onClickYourTile(idx) {
  if (S.turn !== 0 || S.phase === 'end') return;
  const me = S.players[0];
  // æ–°å¢ï¼šç•¶æœ‰åæ‡‰é¢æ¿æ™‚ï¼Œä¸å…è¨±ä¸Ÿç‰Œ
  if (S.waitReact !== null) {
    log('âš ï¸ è«‹å…ˆé¸æ“‡åƒã€ç¢°ã€æ§“æˆ–é');
    return;
  }
  
  // æ–°å¢ï¼šå ±è½å¾Œä¸”å°šæœªé–å®šï¼Œåªèƒ½ä¸Ÿæœƒå½¢æˆè½ç‰Œçš„æ‰‹ç‰Œ
  if (me.declaredListen && !me.tingLocked) {
    const tile = me.hand[idx];
    const afterDiscard = me.hand.filter(t => t !== tile);
    if (!isListening(afterDiscard, me.melds)) {
      log('âš ï¸ å ±è½å¾Œåªèƒ½ä¸Ÿæœƒå½¢æˆè½ç‰Œçš„æ‰‹ç‰Œ');
      return;
    }
  }
  // æ–°è¦å‰‡ï¼šå¦‚æœå·²å ±è½ä¸”å·²é–å®šï¼Œåªèƒ½æ‰“å‰›æ‘¸çš„é‚£å¼µç‰Œï¼ˆdrawnTileï¼‰
  if (me.declaredListen && me.tingLocked) {
    // å¦‚æœè¨˜éŒ„æœ‰å‰›æ‘¸çš„ç‰Œï¼Œå‰‡é™åˆ¶åªèƒ½æ‰“è©²ç‰Œ
    if (me.drawnTile) {
      const selected = me.hand[idx];
      if (selected !== me.drawnTile) {
        log('âš ï¸ å·²é–å®šè½ç‰Œï¼Œåªèƒ½æ‰“å‰›æ‘¸çš„ç‰Œ');
        return;
      }
    } else {
      // è‹¥ä¸å­˜åœ¨ drawnTileï¼ˆå¯èƒ½åœ¨è£œç‰Œæˆ–å…¶ä»–ç‹€æ…‹ï¼‰ï¼Œå‰‡ä½¿ç”¨åŸæœ‰åˆ¤å®šï¼šå¿…é ˆè™•æ–¼æ‘¸ç‰Œç‹€æ…‹æ‰å¯æ‰“
      const kongCount = countKongs(me);
      const expectedFull = 17 + kongCount;
      const totalTiles = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
      const hasDrawn = (totalTiles === expectedFull);
      if (hasDrawn) {
        const lastIdx = me.hand.length - 1;
        if (idx !== lastIdx) {
          log('âš ï¸ å·²é–å®šè½ç‰Œï¼Œåªèƒ½æ‰“å‰›æ‘¸çš„ç‰Œ');
          return;
        }
      }
    }
  }
  const tile = me.hand[idx];
  discard(0, tile);
  // æ–°è¦å‰‡ï¼šå¦‚æœå·²å ±è½ä½†å°šæœªé–å®šï¼Œä¸Ÿç‰Œå¾Œç«‹å³é–å®š
  if (me.declaredListen && !me.tingLocked) {
    me.tingLocked = true;
    log('ğŸ”’ è½ç‰Œå·²é–å®šï¼Œä¹‹å¾Œåªèƒ½æ‰“æ‘¸åˆ°çš„ç‰Œ');
  }
}

/* ========= UI æ¸²æŸ“ ========= */
function renderAll() {
  const goldEl = document.getElementById('goldbar');

  // æ¯æ¬¡é‡ç¹ªå‰ï¼Œç‚ºæ‰€æœ‰ç©å®¶æª¢æŸ¥è½ç‰Œç‹€æ…‹ä¸¦å³æ™‚è¨ˆç®—ç­‰å¾…ç‰Œã€‚
  // è½ç‰Œæ¢ä»¶ï¼šç•¶å‰ç¸½ç‰Œæ•¸ç‚ºæ‡‰è©²ä¸Ÿç‰Œï¼ˆ17+æ§“æ•¸ï¼‰æˆ–æ‘¸ç‰Œï¼ˆ16+æ§“æ•¸ï¼‰æ™‚ï¼Œæª¢æŸ¥æ˜¯å¦åªå·®ä¸€å¼µç‰Œå°±èƒ½èƒ¡ã€‚
  for (let i = 0; i < 4; i++) {
    const p = S.players[i];
    const kc = countKongs(p);
    const totalP = p.hand.length + p.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    const expFull = 17 + kc;
    const expEmpty = 16 + kc;
    let ting = false;
    if (totalP === expFull) {
      // æœ‰æ‘¸ç‰Œæ™‚ï¼šæ¸¬è©¦æ‰“å‡ºæ‰‹ä¸­ä»»ä¸€å¼µå¾Œæ˜¯å¦èƒ½èƒ¡
      ting = p.hand.some(t => {
        const test = p.hand.filter(x => x !== t);
        return isListening(test, p.melds);
      });
    } else if (totalP === expEmpty) {
      // å°‘ä¸€å¼µæ™‚ï¼šç›´æ¥æª¢æŸ¥æ˜¯å¦è½ç‰Œ
      ting = isListening(p.hand, p.melds);
    }
    if (ting) {
      p.waitKeys = calcWaitingTiles(p.hand, p.melds);
    } else {
      p.waitKeys = [];
    }
  }
  // ç§»é™¤æœ¬å±€é‡‘ç‰Œæ¬„ä½ï¼Œåªåœ¨ç‰Œæ¡Œä¸Šé¡¯ç¤º
  goldEl.style.display = 'none';
  
  const sc = document.getElementById('scoreboard');
  // Compose each player's information: name, points, listen state, dealer badge, and dealer streak indicator
  const diceSymbols = ['\u2680', '\u2681', '\u2682', '\u2683', '\u2684', '\u2685'];
  sc.innerHTML = '<div class="score">' + [0, 1, 2, 3].map(i => {
    const n = playerName(i);
    const p = S.players[i];
    const cls = (i === S.dealer ? 'dealer' : '');
    const bankrupt = p.points <= 0 ? '<span class="danger">ï¼ˆç ´ç”¢ï¼‰</span>' : '';
    // Listen badge: priority is å¤©è½, then åœ°è½, then ordinary è½
    let listenBadge = '';
    if (p.tianTing) {
      listenBadge = '<span class="badge ok">å¤©è½</span>';
    } else if (p.diTing) {
      listenBadge = '<span class="badge ok">åœ°è½</span>';
    } else if (p.declaredListen) {
      listenBadge = '<span class="badge ok">è½</span>';
    }
    // Dealer streak dice: if this player is the current dealer and has a streak, show the appropriate dice icon
    let diceBadge = '';
    if (i === S.dealer && S.dealerStreak && S.dealerStreak > 0) {
      const idx = Math.min(S.dealerStreak, diceSymbols.length) - 1;
      diceBadge = `<span class="dice">${diceSymbols[idx]}</span>`;
    }
    // Dealer badge: display a special label when this player is the dealer
    let dealerBadge = '';
    if (i === S.dealer) {
      dealerBadge = '<span class="dealer-badge">èŠ</span>';
    }
    return `<div class="player-info ${cls}">
      <div class="player-name">${n}${dealerBadge} ${diceBadge} ${bankrupt} ${listenBadge}</div>
      <div class="player-points">${p.points.toLocaleString()}</div>
    </div>`;
  }).join('') + '</div>';
  
  // è¨ˆç®—å‰©é¤˜å¯æ‘¸ç‰Œæ•¸ï¼šç‰Œå±± - æµ·åº•16å¼µ
  const remainDrawable = Math.max(0, S.wall.length);
  
  // Compose current round string: e.g. æ±é¢¨æ±ã€æ±é¢¨å—ã€å—é¢¨è¥¿ç­‰
  const roundStr = ['æ±','å—','è¥¿','åŒ—'][S.round - 1] + 'é¢¨' + (seatNames?.[S.dealer] || ['æ±','å—','è¥¿','åŒ—'][S.dealer]);
  // æ›´æ–°å±€é¢è³‡è¨Šå€ï¼šå°‡ç•¶å‰é¢¨åœˆä»¥æ›´é†’ç›®çš„è† å›Šé¡¯ç¤º
  document.getElementById('roundinfo').innerHTML =
    `<span class="round-pill">ğŸ“ ${roundStr}</span>` +
    `<span class="pill">ğŸ´ å‰©é¤˜ç‰Œï¼š${remainDrawable}</span>` +
    `<span class="pill">ğŸ‘¤ è¼ªåˆ°ï¼š${playerName(S.turn)}</span>`;
  
  // æ›´æ–°ä¸­å¤®ç‰Œæ¡Œè³‡è¨Š
  const centerRound = document.getElementById('centerRound');
  const centerGold = document.getElementById('centerGold');
  const centerRemain = document.getElementById('centerRemain');
  
  if (centerRound) {
    centerRound.textContent = roundStr;
  }
  
  if (centerGold) {
    if (S.rules.gold.enabled && S.goldKeys && S.goldKeys.length > 0) {
      // é¡¯ç¤ºé‡‘ç‰Œï¼Œä½¿ç”¨ç‰Œçš„æ¨£å¼è€Œä¸æ˜¯æ–‡å­—
      const goldTiles = S.goldKeys.map(k => {
        const text = keyToText(k);
        // å–å¾—é¡è‰²
        let color = '#5D4037'; // é è¨­æ£•è‰²ï¼ˆå­—ç‰Œï¼‰
        if (text.includes('è¬')) color = '#D32F2F'; // ç´…è‰²
        else if (text.includes('ç­’')) color = '#1976D2'; // è—è‰²
        else if (text.includes('æ¢')) color = '#388E3C'; // ç¶ è‰²
        return `<div style="display: inline-block; margin: 0 4px; padding: 6px 12px; background: linear-gradient(135deg, #FFD700 0%, #FFED4E 100%); border: 2px solid #FFA000; border-radius: 8px; color: ${color}; font-weight: bold; font-size: 18px; box-shadow: 0 2px 8px rgba(255,215,0,0.5);">${text}</div>`;
      }).join('');
      centerGold.innerHTML = `<div style="display: flex; align-items: center; justify-content: center;">âœ¨ ${goldTiles}</div>`;
      centerGold.style.display = 'block';
    } else {
      centerGold.style.display = 'none';
    }
  }
  
  if (centerRemain) {
    centerRemain.textContent = `ğŸ´ å‰©é¤˜ï¼š${remainDrawable}å¼µ`;
  }
  
  const you = S.players[0];
  const kongCount = countKongs(you);
  const expectedFull = 17 + kongCount;
  const hasDrawn = (you.hand.length === expectedFull);
  // æ§‹å»ºå¸¶åŸå§‹ç´¢å¼•çš„é™£åˆ—
  const origTiles = you.hand.map((t, idx) => ({ tile: t, index: idx }));
  let displayRest = [];
  let drawnObj = null;
  if (hasDrawn) {
    // æŠŠæœ€å¾Œä¸€å¼µè¦–ç‚ºå‰›æ‘¸çš„ç‰Œï¼Œä¸èˆ‡å…¶ä»–ç‰Œä¸€èµ·æ’åº
    drawnObj = origTiles[origTiles.length - 1];
    const rest = origTiles.slice(0, -1);
    displayRest = rest.sort((a, b) => tileSortKey(a.tile) - tileSortKey(b.tile));
  } else {
    // æ²’æœ‰æ‘¸ç‰Œç‹€æ…‹ï¼Œå°‡æ‰€æœ‰ç‰Œæ’åº
    displayRest = origTiles.slice().sort((a, b) => tileSortKey(a.tile) - tileSortKey(b.tile));
  }
  // å–®è¡Œé¡¯ç¤ºå…¨éƒ¨æ‰‹ç‰Œï¼Œä¸åˆ†ä¸Šä¸‹æ’
  let handHTML = '<div class="hand-container"><div class="hand-row">';
  displayRest.forEach(item => {
    const t = item.tile;
    const idx = item.index;
    const k = tileKey(t);
    const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
    const suitClass = `suit-${t.suit}`;
    handHTML += `<div class="tile ${suitClass} ${isGold ? 'gold' : ''}" onclick="onClickYourTile(${idx})">${keyToText(k)}</div>`;
  });
  // è‹¥æœ‰æ‘¸ç‰Œç‹€æ…‹ï¼ŒåŠ å…¥ç©ºæ ¼èˆ‡æ‘¸åˆ°çš„ç‰Œ
  if (hasDrawn && drawnObj) {
    handHTML += `<div class="tile placeholder"></div>`;
    const t = drawnObj.tile;
    const idx = drawnObj.index;
    const k = tileKey(t);
    const isGold = S.rules.gold.enabled && S.goldKeys.includes(k);
    const suitClass = `suit-${t.suit}`;
    handHTML += `<div class="tile tile-drawn ${suitClass} ${isGold ? 'gold' : ''}" onclick="onClickYourTile(${idx})">${keyToText(k)}</div>`;
  }
  handHTML += '</div></div>';
  document.getElementById('yourHand').innerHTML = handHTML;
  
  let meldsHTML = '';
  if (you.melds.length > 0) {
    meldsHTML = you.melds.map(m => {
      // å®šç¾©æ¨™ç±¤
      let label = '';
      if (m.type === 'pong') label = 'ç¢°';
      if (m.type === 'kong') label = m.concealed ? 'æš—æ§“' : 'æ§“';
      if (m.type === 'chow') label = 'åƒ';
      // èª¿æ•´åƒç‰Œé †åºï¼šå°‡è¢«åƒçš„ç‰Œæ”¾ç½®ä¸­é–“
      let tilesForDisp;
      if (m.type === 'chow' && typeof m.centerIdx === 'number') {
        const arr = m.tiles.slice();
        // å¾è¤‡æœ¬é™£åˆ—ä¸­æŠ½å‡ºä¸­å¿ƒç‰Œ
        const center = arr.splice(m.centerIdx, 1)[0];
        const lower = arr[0];
        const higher = arr[1];
        tilesForDisp = [lower, center, higher];
      } else {
        tilesForDisp = m.tiles;
      }
      const tilesHTML = tilesForDisp.map(t => {
        const k = tileKey(t);
        const suitClass = `suit-${t.suit}`;
        // ç©å®¶è‡ªå·±çš„å‰¯éœ²ä½¿ç”¨è¼ƒå°å°ºå¯¸çš„ç‰Œé¢ï¼Œé¿å…é®æ“‹æ‰‹ç‰Œ
        return `<span class="tile small ${suitClass}">${keyToText(k)}</span>`;
      }).join(' ');
      return `<span class="meld">${label}ï¼š${tilesHTML}</span>`;
    }).join('');
  }
  // æ›´æ–°ä½ çš„å‰¯éœ²å€
  const yourMeldsEl = document.getElementById('yourMelds');
  if (yourMeldsEl) yourMeldsEl.innerHTML = meldsHTML;
  
  // Reset the self-draw button state. It will be enabled below if the player
  // just drew a winning tile.
  const btnHu = document.getElementById('btnHu');
  btnHu.disabled = true;
  // è‹¥è¼ªåˆ°ç©å®¶ä¸”éŠæˆ²æœªçµæŸï¼Œæª¢æŸ¥æœ€è¿‘æ‘¸çš„ç‰Œæ˜¯å¦å½¢æˆè‡ªæ‘¸ï¼š
  if (S.turn === 0 && S.phase !== 'end') {
    const mePlayer = S.players[0];
    const kongCount = countKongs(mePlayer);
    const total = mePlayer.hand.length + mePlayer.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    const expectedFull = 17 + kongCount;
    if (total === expectedFull) {
      const lastTile = mePlayer.hand[mePlayer.hand.length - 1];
      if (isWinningNow(mePlayer.hand, mePlayer.melds, lastTile)) {
        btnHu.disabled = false;
      }
    }
  }
  
  // è½ç‰ŒæŒ‰éˆ•ï¼šå ±è½å¾ŒæŒ‰éˆ•è®Šç°ï¼Œä¸èƒ½å†æŒ‰
  const me = S.players[0];
  let canListenBtn = false;
  // å¦‚æœå·²å ±è½ï¼ŒæŒ‰éˆ•ç¦ç”¨
  if (me.declaredListen) {
    canListenBtn = false;
  } else if (S.turn === 0 && S.phase !== 'end') {
    const kongCount = countKongs(me);
    const totalTilesMe = me.hand.length + me.melds.reduce((sum, m) => sum + m.tiles.length, 0);
    const expectedFull = 17 + kongCount;
    const expectedEmpty = 16 + kongCount;
    // å‡ºç‰Œç‹€æ…‹ï¼šexpectedFullï¼Œæª¢æŸ¥æ‰“å‡ºä»»ä¸€ç‰Œå¾Œæ˜¯å¦è½ç‰Œ
    if (totalTilesMe === expectedFull) {
      const canListenAfterDiscard = me.hand.some(tile => {
        const testHand = me.hand.filter(t => t !== tile);
        return isListening(testHand, me.melds);
      });
      if (canListenAfterDiscard) canListenBtn = true;
    }
    // æ‘¸ç‰Œå¾Œå¾…æ‘¸ç‹€æ…‹ï¼šexpectedEmptyï¼Œæª¢æŸ¥æ‰‹ç‰Œæ˜¯å¦å·²ç¶“è½ç‰Œ
    if (totalTilesMe === expectedEmpty) {
      canListenBtn = isListening(me.hand, me.melds);
    }
  }
  document.getElementById('btnListen').disabled = !canListenBtn;

  // æš—æ§“æŒ‰éˆ•ï¼šè¼ªåˆ°ç©å®¶ï¼Œç„¡æ£„ç‰Œåæ‡‰ï¼Œä¸”æ‰‹ç‰Œä¸­å­˜åœ¨å››å¼µç›¸åŒç‰Œæ™‚å•Ÿç”¨
  // è½ç‰Œå¾Œä»å¯ä»¥æš—æ§“å’ŒåŠ æ§“ï¼ˆä¸æœƒæ”¹è®Šæ‰‹ç‰Œçµæ§‹ï¼‰
  const btnKong = document.getElementById('btnKong');
  if (S.turn === 0 && S.phase !== 'end' && S.waitReact === null) {
    const cks = canConcealedKong(0);
    const aks = canAddedKong(0);
    btnKong.disabled = (cks.length === 0 && aks.length === 0);
  } else {
    btnKong.disabled = true;
  }
  
  // æ›´æ–°å››æ–¹ä½æ£„ç‰Œå€åŸŸ
  const discardArea0 = document.getElementById('discardArea0');
  const discardArea1 = document.getElementById('discardArea1');
  const discardArea2 = document.getElementById('discardArea2');
  const discardArea3 = document.getElementById('discardArea3');
  
  // æ›´æ–°ç©å®¶è³‡è¨Šå¡ç‰‡
  const playerInfo0 = document.getElementById('playerInfo0');
  const playerInfo1 = document.getElementById('playerInfo1');
  const playerInfo2 = document.getElementById('playerInfo2');
  const playerInfo3 = document.getElementById('playerInfo3');
  // è¼”åŠ©å‡½å¼ï¼šç”¢ç”Ÿæ£„ç‰Œå€HTML
  function buildDiscardHTML(i) {
    const p = S.players[i];
    return p.discards.map((t) => {
      const k = tileKey(t);
      const text = keyToText(k);
      let color = '#5D4037';
      if (text.includes('è¬')) color = '#D32F2F';
      else if (text.includes('ç­’')) color = '#1976D2';
      else if (text.includes('æ¢')) color = '#388E3C';
      return `<span style="display: inline-block; padding: 3px 6px; background: white; border: 1px solid #ccc; border-radius: 4px; margin: 2px; font-size: 12px; color: ${color}; font-weight: bold;">${text}</span>`;
    }).join('');
  }
  
  // è¼”åŠ©å‡½å¼ï¼šç”¢ç”Ÿç©å®¶è³‡è¨ŠHTMLï¼ˆinlineæ¨£å¼ï¼‰
  function buildPlayerInfoHTML(i) {
    const p = S.players[i];
    const name = playerName(i);
    const dealerTag = (i === S.dealer) ? '<span class="dealer-badge">èŠ</span>' : '';
    // é€£èŠéª¨å­æ¨™è¨˜
    let diceTag = '';
    if (i === S.dealer && S.dealerStreak > 0) {
      const diceIcons = ['âš€', 'âš', 'âš‚', 'âšƒ', 'âš„', 'âš…'];
      const diceIcon = diceIcons[Math.min(S.dealerStreak - 1, 5)];
      diceTag = `<span class="dice" style="margin-left: 4px;">${diceIcon}</span>`;
    }
    // è½ç‰Œç‹€æ…‹é¡¯ç¤º
    const listenTag = p.declaredListen ? '<span class="listen-badge" style="background: #FFC107; color: #003D7A; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px; font-weight: bold;">ğŸ””</span>' : '';
    const points = p.points.toLocaleString();
    
    // æ–¹ä½é¡¯ç¤ºï¼šä½¿ç”¨ seatNames ä¾†é¡¯ç¤ºæ­£ç¢ºçš„é¢¨ä½ï¼Œå¢å¼·è¦–è¦ºæ•ˆæœ
    const wind = seatNames && seatNames[i] ? seatNames[i] : ['æ±', 'å—', 'è¥¿', 'åŒ—'][i];
    const windTag = `<span style="background: linear-gradient(135deg, #1976D2 0%, #0D47A1 100%); color: #ffffff; padding: 6px 12px; border-radius: 6px; font-size: 16px; font-weight: bold; margin-left: 8px; box-shadow: 0 2px 8px rgba(25, 118, 210, 0.4); display: inline-block;">${wind}</span>`;
    
    // ç­‰ç‰Œæç¤ºï¼ˆåƒ…ç©å®¶0ï¼‰
    let waitLine = '';
    if (i === 0 && Array.isArray(p.waitKeys) && p.waitKeys.length > 0) {
      const texts = p.waitKeys.map(key => keyToText(key)).join(' ');
      waitLine = `<div style="font-size: 11px; margin-top: 4px;">ğŸ‘‚ ç­‰: ${texts}</div>`;
    }
    
    return `
      <div class="player-name">${name} ${windTag}${dealerTag}${diceTag}${listenTag}</div>
      <div class="player-score">ğŸ’° ${points}</div>
      <div style="font-size: 11px; margin-top: 4px;">ğŸ´ ${p.hand.length}å¼µ</div>
      ${waitLine}
    `;
  }
  
  // è¼”åŠ©å‡½å¼ï¼šç”¢ç”Ÿå‰¯éœ²HTML
  function buildMeldHTML(i) {
    const p = S.players[i];
    if (p.melds.length === 0) return '';
    
    return p.melds.map(m => {
      let label = '';
      if (m.type === 'pong') label = 'ğŸ”¥';
      if (m.type === 'kong') label = m.concealed ? 'ğŸ’¥' : 'ğŸ’¥';
      if (m.type === 'chow') label = 'ğŸœ';
      
      let tilesForDisp;
      if (m.type === 'chow' && typeof m.centerIdx === 'number') {
        const arr = m.tiles.slice();
        const center = arr.splice(m.centerIdx, 1)[0];
        const lower = arr[0];
        const higher = arr[1];
        tilesForDisp = [lower, center, higher];
      } else {
        tilesForDisp = m.tiles;
      }
      
      const tilesStr = tilesForDisp.map(t => {
        const key = tileKey(t);
        const text = keyToText(key);
        let color = '#5D4037';
        if (text.includes('è¬')) color = '#D32F2F';
        else if (text.includes('ç­’')) color = '#1976D2';
        else if (text.includes('æ¢')) color = '#388E3C';
        return `<div class="tile" style="color: ${color}; margin: 2px;">${text}</div>`;
      }).join('');
      
      return `<div style="display: flex; align-items: center; margin: 4px 0; padding: 4px; background: rgba(0,0,0,0.2); border-radius: 4px;">
        <span style="font-size: 16px; margin-right: 4px;">${label}</span>
        <div style="display: flex; gap: 2px;">${tilesStr}</div>
      </div>`;
    }).join('');
  }
  
  // æ›´æ–°æ£„ç‰Œå€åŸŸ
  if (discardArea0) discardArea0.innerHTML = buildDiscardHTML(0);
  if (discardArea1) discardArea1.innerHTML = buildDiscardHTML(1);
  if (discardArea2) discardArea2.innerHTML = buildDiscardHTML(2);
  if (discardArea3) discardArea3.innerHTML = buildDiscardHTML(3);
  
  // æ›´æ–°å‰¯éœ²å€åŸŸ
  const meldArea0 = document.getElementById('meldArea0');
  const meldArea1 = document.getElementById('meldArea1');
  const meldArea2 = document.getElementById('meldArea2');
  const meldArea3 = document.getElementById('meldArea3');
  if (meldArea0) meldArea0.innerHTML = buildMeldHTML(0);
  if (meldArea1) meldArea1.innerHTML = buildMeldHTML(1);
  if (meldArea2) meldArea2.innerHTML = buildMeldHTML(2);
  if (meldArea3) meldArea3.innerHTML = buildMeldHTML(3);
  
  // æ›´æ–°ç©å®¶è³‡è¨Š
  if (playerInfo0) playerInfo0.innerHTML = buildPlayerInfoHTML(0);
  if (playerInfo1) playerInfo1.innerHTML = buildPlayerInfoHTML(1);
  if (playerInfo2) playerInfo2.innerHTML = buildPlayerInfoHTML(2);
  if (playerInfo3) playerInfo3.innerHTML = buildPlayerInfoHTML(3);
  
  // æ›´æ–°è¼ªåˆ°å‡ºç‰Œçš„ç®­é ­æ¨™ç¤º
  [playerInfo0, playerInfo1, playerInfo2, playerInfo3].forEach((el, i) => {
    if (!el) return;
    // ç§»é™¤æ‰€æœ‰ç©å®¶çš„é«˜äº®æ¨£å¼å’Œç®­é ­
    el.classList.remove('active-turn');
    const existingIndicator = el.querySelector('.turn-indicator');
    if (existingIndicator) {
      existingIndicator.remove();
    }
    
    // ç‚ºç•¶å‰è¼ªåˆ°çš„ç©å®¶æ·»åŠ é«˜äº®æ¨£å¼å’Œç®­é ­
    if (i === S.turn && S.phase !== 'end') {
      el.classList.add('active-turn');
      
      // æ·»åŠ ç®­é ­æ¨™ç¤ºï¼Œæ ¹æ“šä½ç½®é¡¯ç¤ºä¸åŒæ–¹å‘çš„ç®­é ­
      const arrows = ['â¬‡ï¸', 'â¬†ï¸', 'â¬…ï¸', 'â¡ï¸'];  // ä¸‹ã€ä¸Šã€å·¦ã€å³
      const arrow = document.createElement('div');
      arrow.className = 'turn-indicator';
      arrow.textContent = arrows[i];
      el.appendChild(arrow);
    }
  });
  

}

function showHandsAndContinue() {
  // é¡¯ç¤ºæ‰€æœ‰ç©å®¶çš„æ‰‹ç‰Œå’Œç¹¼çºŒæŒ‰éˆ•
  const panel = document.getElementById('reactionPanel');
  const overlay = document.getElementById('overlay');
  
  let html = '<div class="reaction-panel" style="background: rgba(0, 61, 122, 0.95); max-width: 800px; max-height: 80vh; overflow-y: auto;">';
  
  // é¡¯ç¤ºè´å®¶è³‡è¨Šæˆ–æµå±€
  if (S.winner !== null) {
    const detail = calcFanDetails(S.winner, S.winTile, S.fromPlayer === -1);
    const catStr = detail.categories.join('ã€');
    const winnerName = playerName(S.winner);
    
    if (S.fromPlayer === -1) {
      // è‡ªæ‘¸
      html += `<h3 style="color: #FFD700; margin-bottom: 20px;">ğŸ´ å±€çµæŸ - ${winnerName} è‡ªæ‘¸èƒ¡ç‰Œ</h3>`;
      html += `<div style="color: #8BC34A; font-size: 18px; margin-bottom: 15px; text-align: center;">`;
      html += `ğŸ‰ ${catStr}ï¼Œå…± <strong>${detail.fan}</strong> å°</div>`;
    } else {
      // é»èƒ¡
      const loserName = playerName(S.fromPlayer);
      html += `<h3 style="color: #FFD700; margin-bottom: 20px;">ğŸ´ å±€çµæŸ - ${winnerName} é»èƒ¡</h3>`;
      html += `<div style="color: #8BC34A; font-size: 18px; margin-bottom: 15px; text-align: center;">`;
      html += `ğŸ‰ ${catStr}ï¼Œå…± <strong>${detail.fan}</strong> å°<br>`;
      html += `ğŸ”« æ”¾æ§ï¼š<strong style="color: #FF5722;">${loserName}</strong></div>`;
    }
  } else {
    // æµå±€
    html += '<h3 style="color: #FFC107; margin-bottom: 20px;">ğŸ´ å±€çµæŸ - æµå±€</h3>';
    html += '<div style="color: #8BC34A; font-size: 18px; margin-bottom: 15px; text-align: center;">ğŸš« ç‰Œå±±æ¯ç«­ï¼Œæµå±€</div>';
  }
  
  html += '<h4 style="color: #FFC107; margin-top: 20px; margin-bottom: 10px;">æ‰€æœ‰ç©å®¶æ‰‹ç‰Œ</h4>';
  
  // é¡¯ç¤ºæ¯å€‹ç©å®¶çš„æ‰‹ç‰Œ
  for (let i = 0; i < 4; i++) {
    const p = S.players[i];
    const name = playerName(i);
    const isWinner = (S.winner === i);
    
    html += `<div style="margin-bottom: 20px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px; border: ${isWinner ? '3px solid #FFD700' : '1px solid #0066CC'};">`;
    html += `<h4 style="color: ${isWinner ? '#FFD700' : '#8BC34A'}; margin-bottom: 10px;">${isWinner ? 'ğŸ† ' : ''}${name}${isWinner ? ' - èƒ¡ç‰Œ' : ''}</h4>`;
    
    // å‰¯éœ²ï¼ˆè¦–è¦ºåŒ–é¡¯ç¤ºï¼‰
    if (p.melds.length > 0) {
      html += '<div style="margin-bottom: 8px;"><strong style="color: #FFC107;">å‰¯éœ²ï¼š</strong></div>';
      html += '<div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px;">';
      p.melds.forEach(m => {
        html += '<div style="display: flex; gap: 2px; padding: 4px; background: rgba(255,255,255,0.05); border-radius: 4px;">';
        m.tiles.forEach(t => {
          const text = keyToText(tileKey(t));
          const isGold = S.rules.gold.enabled && S.goldKeys.includes(tileKey(t));
          
          // é¡è‰²å€åˆ†
          let bgColor = '#fff';
          let textColor = '#000';
          
          if (isGold) {
            bgColor = '#FFD700';
            textColor = '#003D7A';
          } else if (t.suit === 'W') {
            textColor = '#D32F2F';  // è¬ï¼šç´…è‰²
          } else if (t.suit === 'T') {
            textColor = '#1976D2';  // ç­’ï¼šè—è‰²
          } else if (t.suit === 'B') {
            textColor = '#388E3C';  // æ¢ï¼šç¶ è‰²
          } else if (t.suit === 'F' || t.suit === 'D') {
            textColor = '#5D4037';  // å­—ç‰Œï¼šæ£•è‰²
          }
          
          html += `<div style="background: ${bgColor}; color: ${textColor}; padding: 8px 6px; border-radius: 4px; font-weight: bold; min-width: 32px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">${text}</div>`;
        });
        html += '</div>';
      });
      html += '</div>';
    }
    
    // æ‰‹ç‰Œï¼ˆè¦–è¦ºåŒ–é¡¯ç¤ºï¼Œæ’åºä¸¦åŠ å…¥é¡è‰²å€åˆ†ï¼‰
    html += '<div style="margin-top: 10px;"><strong style="color: #FFC107;">æ‰‹ç‰Œï¼š</strong></div>';
    html += '<div style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 8px;">';
    // æ’åºæ‰‹ç‰Œ
    const sortedHand = p.hand.slice().sort((a, b) => tileSortKey(a) - tileSortKey(b));
    sortedHand.forEach(t => {
      const text = keyToText(tileKey(t));
      const isGold = S.rules.gold.enabled && S.goldKeys.includes(tileKey(t));
      
      // é¡è‰²å€åˆ†ï¼šè¬ï¼ˆç´…ï¼‰ã€ç­’ï¼ˆè—ï¼‰ã€æ¢ï¼ˆç¶ ï¼‰ã€å­—ç‰Œï¼ˆç°ï¼‰
      let bgColor = '#fff';
      let textColor = '#000';
      
      if (isGold) {
        bgColor = '#FFD700';
        textColor = '#003D7A';
      } else if (t.suit === 'W') {
        textColor = '#D32F2F';  // è¬ï¼šç´…è‰²
      } else if (t.suit === 'T') {
        textColor = '#1976D2';  // ç­’ï¼šè—è‰²
      } else if (t.suit === 'B') {
        textColor = '#388E3C';  // æ¢ï¼šç¶ è‰²
      } else if (t.suit === 'F' || t.suit === 'D') {
        textColor = '#5D4037';  // å­—ç‰Œï¼šæ£•è‰²
      }
      
      html += `<div style="background: ${bgColor}; color: ${textColor}; padding: 8px 6px; border-radius: 4px; font-weight: bold; min-width: 32px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">${text}</div>`;
    });
    html += '</div>';
    
    // åˆ†æ•¸
    html += `<div style="margin-top: 8px; color: #8BC34A;"><strong>åˆ†æ•¸ï¼š</strong>${p.points.toLocaleString()}</div>`;
    html += '</div>';
  }
  
  // ç¹¼çºŒæŒ‰éˆ•
  html += '<div style="text-align: center; margin-top: 20px;">';
  html += '<button id="btnContinueNext" style="padding: 15px 40px; font-size: 18px; background: #8BC34A; color: #003D7A; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">â–¶ï¸ ç¹¼çºŒä¸‹ä¸€å±€</button>';
  html += '</div>';
  html += '</div>';
  
  panel.innerHTML = html;
  panel.style.display = 'block';
  overlay.style.display = 'block';
  
  document.getElementById('btnContinueNext').onclick = () => {
    panel.style.display = 'none';
    overlay.style.display = 'none';
    log('â€”â€” é–‹ä¸‹ä¸€å±€ â€”â€”');
    startNewHand();
  };
}

function showFinalScore() {
  S.phase = 'end';
  renderAll();
  
  const rankings = S.players.map((p, i) => ({ name: playerName(i), points: p.points, index: i }))
    .sort((a, b) => b.points - a.points);
  
  let msg = 'ğŸ† éŠæˆ²çµæŸï¼æœ€çµ‚æˆç¸¾ï¼š\n';
  rankings.forEach((r, rank) => {
    const medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', '4ä½'];
    msg += `${medals[rank]} ${r.name}ï¼š${r.points.toLocaleString()}åˆ†\n`;
  });
  
  log(msg);
  log('ğŸ”„ é»æ“Šã€Œé–‹å§‹æ–°å±€ã€é‡æ–°é–‹å§‹éŠæˆ²');
}

/* ========= å•Ÿå‹•éŠæˆ² ========= */
startNewHand(true);
</script>
</body>
</html>

